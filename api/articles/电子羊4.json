{"title":"【电子羊的奇妙冒险 】初试深度学习（4）","uid":"0ace423a65608d78c82e5378fc3daeb8","slug":"电子羊4","date":"2022-11-03T14:18:49.000Z","updated":"2022-11-08T16:16:30.225Z","comments":true,"path":"api/articles/电子羊4.json","keywords":null,"cover":[],"content":"<h2 id=\"代码注释\"><a href=\"#代码注释\" class=\"headerlink\" title=\"代码注释\"></a>代码注释</h2><h3 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>出于我们的目的，我将创建一组具有根的此类多项式。实际上，我将首先创建根，然后创建多项式，如下所示：</p></blockquote>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">import numpy as np\n\nMIN_ROOT &#x3D; -1\nMAX_ROOT &#x3D; 1\n\ndef make(n_samples, n_degree):\n    global MIN_ROOT, MAX_ROOT\n    y &#x3D; np.random.uniform(MIN_ROOT, MAX_ROOT, (n_samples, n_degree))\n    y.sort(axis&#x3D;1) #，排序，参数axis &#x3D; 1表示列,而0表示行\n    X &#x3D; np.array([np.poly(_) for _ in y])\n    #numpy.poly(seq)：给出多项式根的序列，此函数返回多项式的系数\n    #array()创建数组\n    return X, y\n#y为根，X为多项式系数\n# toy case\nX, y &#x3D; make(1, 2)\nprint(X)\nprint(y)</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>uniform() 方法将随机生成下一个实数，它在 [x, y] 范围内<br>参见<a href=\"https://www.runoob.com/python/func-number-uniform.html\">https://www.runoob.com/python/func-number-uniform.html</a></p></blockquote>\n<p>以下是 uniform() 方法的语法:</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">import numpy as np\n\nnp.random.uniform(x, y, size)</code></pre>\n<p>注意：uniform()是不能直接访问的，需要导入 random 模块，然后通过 random 静态对象调用该方法。<br><strong>参数</strong>：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>x — 随机数的最小值，包含该值。<br>y — 随机数的最大值，包含该值。<br>size: 输出样本数目，为int或元组(tuple)类型，例如，size=(m,n,k), 则输出m <em> n</em>k个样本，缺省时输出1个 实数</p></blockquote>\n<p><strong>返回值</strong>：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>取值范围为如果 x&lt;y 则 x &lt;= N &lt;= y，如果 y&lt;x 则y &lt;= N &lt;= x<br>ndarray类型，其形状和参数size中描述一致</p>\n<h3 id=\"划分数据集\"><a href=\"#划分数据集\" class=\"headerlink\" title=\"划分数据集\"></a>划分数据集</h3></blockquote>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"># make and train test split\nN_SAMPLES &#x3D; 100000  #样例数为100000\nDEGREE &#x3D; 5 #数据集根为5，多项式系数数量为5+1\nX_train, y_train &#x3D; make(int(N_SAMPLES*0.8), DEGREE)\nX_test, y_test &#x3D; make(int(N_SAMPLES*0.2), DEGREE)\n#训练集&#x2F;测试集 二八分\nprint(X_train.shape, y_train.shape)\nprint(X_test.shape, y_test.shape)\n#np.shape 读取数组长度</code></pre>\n<h3 id=\"reshape\"><a href=\"#reshape\" class=\"headerlink\" title=\"reshape\"></a>reshape</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"># some dimensionality handling below\n# this is because keras expects 3d tensors (a seq of onehot encoded characters) \n# but we have 2d tensors; just a sequence of numbers.\n\n\ndef reshape(array):\n    return np.expand_dims(array, -1)\n    \n    \nprint(reshape(X_test).shape)  # batchsize, timesteps, input_dim (or &quot;vocab_size&quot;)\nprint(reshape(y_test).shape) \n#注释上写到了，因为keras需要3d，所以使用np.expand_dims()补充一个轴的数据</code></pre>\n<h3 id=\"模型建立\"><a href=\"#模型建立\" class=\"headerlink\" title=\"模型建立\"></a>模型建立</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">from keras.models import Sequential\nfrom keras.layers import LSTM, RepeatVector, Dense, TimeDistributed\n\n\nhidden_size &#x3D; 128 #隐含层中，隐含节点的个数，LSTM里每一块都是一个全连接的神经网络，那么hidden_size就是这个神经网络的每一层的节点数目\nmodel &#x3D; Sequential()\n\n# ENCODER PART OF SEQ2SEQ\nmodel.add(LSTM(hidden_size, input_shape&#x3D;(DEGREE+1, 1)))\n#input_shape就是指输入张量的shape\n\n# DECODER PART OF SEQ2SEQ\nmodel.add(RepeatVector(DEGREE))  # this determines the length of the output sequence\n#RepeatVector（n）改变输入维数为n\n\nmodel.add((LSTM(hidden_size, return_sequences&#x3D;True)))\nmodel.add(TimeDistributed(Dense(1)))\n\nmodel.compile(loss&#x3D;&#39;mean_absolute_error&#39;,\n              optimizer&#x3D;&#39;adam&#39;,\n              metrics&#x3D;[&#39;mae&#39;])\n              \n&#39;&#39;&#39;\nmodel.compile(optimizer &#x3D; 优化器，\n\n                        loss &#x3D; 损失函数，模型模型预测的好坏，表现预测与实际数据的差距程度\n\n                        metrics &#x3D; [&quot;准确率”])\n&#39;&#39;&#39;\n\nprint(model.summary())\n</code></pre>\n<p>Sequential模型详见链接</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/mogoweb/article/details/82152174\">https://blog.csdn.net/mogoweb/article/details/82152174</a></p>\n<p>return_sequences: Boolean. 是否返回最后一个输出或是整个序列的输出，默认是False</p>\n<p>TimeDistributed用法：<br><a href=\"https://blog.csdn.net/u012193416/article/details/79477220\">https://blog.csdn.net/u012193416/article/details/79477220</a></p></blockquote>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Using TensorFlow backend.\n\n\n_________________________________________________________________\nLayer (type)                 Output Shape              Param #   \n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nlstm_1 (LSTM)                (None, 128)               66560     \n_________________________________________________________________\nrepeat_vector_1 (RepeatVecto (None, 5, 128)            0         \n_________________________________________________________________\nlstm_2 (LSTM)                (None, 5, 128)            131584    \n_________________________________________________________________\ntime_distributed_1 (TimeDist (None, 5, 1)              129       \n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nTotal params: 198,273\nTrainable params: 198,273\nNon-trainable params: 0\n_________________________________________________________________\nNone\n</code></pre>\n<p>注释：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"># Param &#x3D; （输入数据维度+1）* 神经元个数</code></pre>\n<h3 id=\"模型定义\"><a href=\"#模型定义\" class=\"headerlink\" title=\"模型定义\"></a>模型定义</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">BATCH_SIZE &#x3D; 128\nmodel.fit(reshape(X_train),\n          reshape(y_train),\n          batch_size&#x3D;BATCH_SIZE,\n          epochs&#x3D;5, #迭代次数\n          verbose&#x3D;1, #verbose：日志显示\n          validation_data&#x3D;(reshape(X_test), \n                           reshape(y_test)))\n&#39;&#39;&#39;\nbatch_size：表示单次传递给程序用以训练的参数个数。\n比如我们的训练集有1000个数据。\n这是如果我们设置batch_size&#x3D;100，\n那么程序首先会用数据集中的前100个参数，\n即第1-100个数据来训练模型。\n当训练完成后更新权重，再使用第101-200的个数据训练，\n直至第十次使用完训练集中的1000个数据后停止\n\nmodel.fit()⽅法⽤于执⾏训练过程。\nmodel.fit( 训练集的输⼊特征，\n                 训练集的标签，  \n                 batch_size,  #每⼀个batch的⼤⼩\n                 epochs,   #迭代次数\n                 validation_data &#x3D; (测试集的输⼊特征，测试集的标签），\n                 validation_split &#x3D; 从测试集中划分多少⽐例给训练集，\n                 validation_freq &#x3D; 测试的epoch间隔数）\n\nmodel.fit 中的 verbose\nverbose：日志显示\nverbose &#x3D; 0 为不在标准输出流输出日志信息\nverbose &#x3D; 1 为输出进度条记录\nverbose &#x3D; 2 为每个epoch输出一行记录\n注意： 默认为 1\n\n&#39;&#39;&#39;</code></pre>\n<h3 id=\"预测数据\"><a href=\"#预测数据\" class=\"headerlink\" title=\"预测数据\"></a>预测数据</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">y_pred &#x3D; model.predict(reshape(X_test))\ny_pred &#x3D; np.squeeze(y_pred)\n\n&#39;&#39;&#39;\nmodel.predict\n输入测试数据,输出预测结果\n(通常用在需要得到预测结果的时候)\n#模型预测,输入测试集,输出预测结果\n    y_pred &#x3D; model.predict(X_test,batch_size &#x3D; 1）\n    \nsqueeze 函数：从数组的形状中删除单维度条目，即把shape中为1的维度去掉\n用法：numpy.squeeze(a,axis &#x3D; None)\n 1）a表示输入的数组；\n 2）axis用于指定需要删除的维度，但是指定的维度必须为单维度，否则将会报错；\n 3）axis的取值可为None 或 int 或 tuple of ints, 可选。若axis为空，则删除所有单维度的条目；\n 4）返回值：数组\n 5) 不会修改原数组；\n\n&#39;&#39;&#39;\n</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>现在有一个功能可以帮助我们比较，我们可以重用</p></blockquote>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">import pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n\ndef get_evals(polynomials, roots):\n    evals &#x3D; [\n        [np.polyval(poly, r) for r in root_row]\n        for (root_row, poly) in zip(roots, polynomials)\n    ]\n    evals &#x3D; np.array(evals).ravel()\n    return evals\n    \n\ndef compare_to_random(y_pred, y_test, polynomials):\n    y_random &#x3D; np.random.uniform(MIN_ROOT, MAX_ROOT, y_test.shape)\n    y_random.sort(axis&#x3D;1)\n    \n    fig, axes &#x3D; plt.subplots(1, 2, figsize&#x3D;(12, 6)) #画图，figsize为图像尺寸\n    ax &#x3D; axes[0]\n    ax.hist(np.abs((y_random-y_test).ravel()),   #ravel()方法将数组维度拉成一维数组\n            alpha&#x3D;.4, label&#x3D;&#39;random guessing&#39;) \n     #ax.hist()绘制直方图\n    ax.hist(np.abs((y_pred-y_test).ravel()), \n            color&#x3D;&#39;r&#39;, alpha&#x3D;.4, label&#x3D;&#39;model predictions&#39;)\n    ax.set(title&#x3D;&#39;Histogram of absolute errors&#39;,\n           ylabel&#x3D;&#39;count&#39;, xlabel&#x3D;&#39;absolute error&#39;)\n    ax.legend(loc&#x3D;&#39;best&#39;)\n\n    ax &#x3D; axes[1]\n    random_evals &#x3D; get_evals(polynomials, y_random)\n    predicted_evals &#x3D; get_evals(polynomials, y_pred)\n    pd.Series(random_evals).plot.kde(ax&#x3D;ax, label&#x3D;&#39;random guessing kde&#39;)\n    pd.Series(predicted_evals).plot.kde(ax&#x3D;ax, color&#x3D;&#39;r&#39;, label&#x3D;&#39;model prediction kde&#39;)\n    title &#x3D; &#39;Kernel Density Estimate plot\\n&#39; \\\n            &#39;for polynomial evaluation of (predicted) roots&#39;\n    ax.set(xlim&#x3D;[-.5, .5], title&#x3D;title)\n    ax.legend(loc&#x3D;&#39;best&#39;)\n    \n    fig.tight_layout()\ncompare_to_random(y_pred, y_test, X_test)\n&#39;&#39;&#39;\n#polyval计算多项式的函数值。返回在x处多项式的值，p为多项式系数，元素按多项式降幂排序\ny&#x3D;polyval(p,x)\n\nravel()方法将数组维度拉成一维数组\n&#39;&#39;&#39;\n</code></pre>\n<p>关于AXES用法详见：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://article.itxueyuan.com/vOQMg9\">https://article.itxueyuan.com/vOQMg9</a></p></blockquote>\n<h3 id=\"绘图\"><a href=\"#绘图\" class=\"headerlink\" title=\"绘图\"></a>绘图</h3><p><img src=\"https://img-blog.csdnimg.cn/img_convert/a084563833119cd0ab323f1486936433.png#pic_center#pic_center\" alt=\"在这里插入图片描述\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在左图中，请注意预测的根（红色条）如何更接近真实根（即红色条在 0.25 之后较小）。在右侧，请注意红色曲线在零附近有多紧。也就是说，在模型预测的根上，多项式评估的预期分布非常紧密地包含在零附近。至少这与e随机评估之间存在明显差异。</p></blockquote>\n<h3 id=\"求解不同程度多项式\"><a href=\"#求解不同程度多项式\" class=\"headerlink\" title=\"求解不同程度多项式\"></a>求解不同程度多项式</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">MAX_DEGREE &#x3D; 15\nMIN_DEGREE &#x3D; 5 #大于4小于16次的多项式（5~15）\nMAX_ROOT &#x3D; 1\nMIN_ROOT &#x3D; -1\nN_SAMPLES &#x3D; 10000 * (MAX_DEGREE-MIN_DEGREE+1) #每一项都给出10000个示例，括号内为多项式各项总数，比如，三元一次方程左侧多项式为4项\n\n\ndef make(n_samples, max_degree, min_degree, min_root, max_root):\n    samples_per_degree &#x3D; n_samples &#x2F;&#x2F; (max_degree-min_degree+1) #均分数据示例\n    n_samples &#x3D; samples_per_degree * (max_degree-min_degree+1) #得到相同数量示例之和\n    X &#x3D; np.zeros((n_samples, max_degree+1)) #返回来一个给定形状和类型的用0填充的数组\n    # XXX: filling the truth labels with ZERO??? EOS character would be nice\n    y &#x3D; np.zeros((n_samples, max_degree, 2))\n    for i, degree in enumerate(range(min_degree, max_degree+1)):\n        y_tmp &#x3D; np.random.uniform(min_root, max_root, (samples_per_degree, degree))\n        y_tmp.sort(axis&#x3D;1)\n        X_tmp &#x3D; np.array([np.poly(_) for _ in y_tmp])\n        \n        root_slice_y &#x3D; np.s_[\n            i*samples_per_degree:(i+1)*samples_per_degree,\n            :degree,\n            0]\n        pad_slice_y &#x3D; np.s_[\n            i*samples_per_degree:(i+1)*samples_per_degree,\n            degree:,\n            1]\n        this_slice_X &#x3D; np.s_[\n            i*samples_per_degree:(i+1)*samples_per_degree,\n            -degree-1:]\n        \n        y[root_slice_y] &#x3D; y_tmp \n        y[pad_slice_y] &#x3D; 1\n        X[this_slice_X] &#x3D; X_tmp\n    return X, y\n\ndef make_this():\n    global MAX_DEGREE, MIN_DEGREE, MAX_ROOT, MIN_ROOT, N_SAMPLES\n    return make(N_SAMPLES, MAX_DEGREE, MIN_DEGREE, MIN_ROOT, MAX_ROOT)\n\n\nfrom sklearn.model_selection import train_test_split\nX, y &#x3D; make_this()\nX_train, X_test, y_train, y_test &#x3D; train_test_split(X, y, test_size&#x3D;0.25)\n\n&#39;&#39;&#39;\ntest_size：可以为浮点、整数或None，默认为None\n\n①若为浮点时，表示测试集占总样本的百分比\n\n②若为整数时，表示测试样本样本数\n\n③若为None时，test size自动设置成0.25\n&#39;&#39;&#39;\n\n\nprint(&#39;X shapes&#39;, X.shape, X_train.shape, X_test.shape)\nprint(&#39;y shapes&#39;, y.shape, y_train.shape, y_test.shape)\nprint(&#39;-&#39;*80)\nprint(&#39;This is an example root sequence&#39;)\nprint(y[0])\n</code></pre>\n<h4 id=\"改变模型\"><a href=\"#改变模型\" class=\"headerlink\" title=\"改变模型\"></a>改变模型</h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">hidden_size &#x3D; 128\nmodel &#x3D; Sequential()\n\nmodel.add(LSTM(hidden_size, input_shape&#x3D;(MAX_DEGREE+1, 1)))\nmodel.add(RepeatVector(MAX_DEGREE))\nmodel.add((LSTM(hidden_size, return_sequences&#x3D;True)))\nmodel.add(TimeDistributed(Dense(2)))\n\nmodel.compile(loss&#x3D;&#39;mean_absolute_error&#39;,\n              optimizer&#x3D;&#39;adam&#39;,\n              metrics&#x3D;[&#39;mae&#39;])\n\nprint(model.summary())\n</code></pre>\n<h3 id=\"训练模型\"><a href=\"#训练模型\" class=\"headerlink\" title=\"训练模型\"></a>训练模型</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">BATCH_SIZE &#x3D; 12\nmodel.fit(reshape(X_train), y_train,\n          batch_size&#x3D;BATCH_SIZE,\n          epochs&#x3D;10,\n          verbose&#x3D;1,\n          validation_data&#x3D;(reshape(X_test), y_test))\n</code></pre>\n<h3 id=\"预测数据-1\"><a href=\"#预测数据-1\" class=\"headerlink\" title=\"预测数据\"></a>预测数据</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">y_pred &#x3D; model.predict(reshape(X_test))\npad_or_not &#x3D; y_pred[:, :, 1].ravel()\nfig, ax &#x3D; plt.subplots()\nax.set(title&#x3D;&#39;histogram for predicting PAD&#39;,\n       xlabel&#x3D;&#39;predicted value&#39;,\n       ylabel&#x3D;&#39;count&#39;)\nax.hist(pad_or_not, bins&#x3D;5);\n#bins 指定条带bar 的总个数，个数越多，条形带越紧密\n&#39;&#39;&#39;\nbins ：数字或者序列（数组&#x2F;列表等）。如果是数字，代表的是要分成多少组。如果是序\n列，那么就会按照序列中指定的值进行分组。比如 [1,2,3,4] ，那么分组的时候会按照三个\n区间分成3组，分别是 [1,2)&#x2F;[2,3)&#x2F;[3,4] \n&#39;&#39;&#39;</code></pre>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">thr &#x3D; 0.5\n\n\ndef how_many_roots(predicted):\n    global thr\n    return np.sum(predicted[:, 1] &lt; thr)\n\n\ntrue_root_count &#x3D; np.array(list(map(how_many_roots, y_test)))\npred_root_count &#x3D; np.array(list(map(how_many_roots, y_pred)))\nfrom collections import Counter\nfor key, val in Counter(true_root_count - pred_root_count).items():\n    print(&#39;off by &#123;&#125;: &#123;&#125; times&#39;.format(key, val))\n</code></pre>\n<h3 id=\"模型检验\"><a href=\"#模型检验\" class=\"headerlink\" title=\"模型检验\"></a>模型检验</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">index &#x3D; np.where(true_root_count &#x3D;&#x3D; pred_root_count)[0]\nindex &#x3D; np.random.choice(index, 1000, replace&#x3D;False)\n\npredicted_evals, random_evals &#x3D; [], []\nrandom_roots_list &#x3D; []\npredicted_roots_list &#x3D; []\ntrue_roots_list &#x3D; []\nfor i in index:\n    predicted_roots &#x3D; [row[0] for row in y_pred[i] if row[1] &lt; thr]\n    true_roots &#x3D; [row[0] for row in y_test[i] if row[1] &#x3D;&#x3D; 0]\n    random_roots &#x3D; np.random.uniform(MIN_ROOT, MAX_ROOT, len(predicted_roots))\n    random_roots &#x3D; sorted(random_roots)\n    random_roots_list.extend(random_roots)\n    predicted_roots_list.extend(predicted_roots)\n    true_roots_list.extend(true_roots)\n    for predicted_root, random_root in zip(predicted_roots, random_roots):\n        predicted_evals.append(\n            np.polyval(X_test[i], predicted_root))\n        random_evals.append(\n            np.polyval(X_test[i], random_root))\n        \nassert len(true_roots_list) &#x3D;&#x3D; len(predicted_roots_list)\nassert len(random_roots_list) &#x3D;&#x3D; len(predicted_roots_list)\ntrue_roots_list &#x3D; np.array(true_roots_list)\nrandom_roots_list &#x3D; np.array(random_roots_list)\npredicted_roots_list &#x3D; np.array(predicted_roots_list)\nfig, axes &#x3D; plt.subplots(1, 2, figsize&#x3D;(12, 6))\nax &#x3D; axes[0]\nax.hist(np.abs(random_roots_list - true_roots_list),\n        alpha&#x3D;.4, label&#x3D;&#39;random guessing&#39;) \nax.hist(np.abs(predicted_roots_list - true_roots_list),\n        color&#x3D;&#39;r&#39;, alpha&#x3D;.4, label&#x3D;&#39;model predictions&#39;)\nax.set(title&#x3D;&#39;Histogram of absolute errors&#39;,\n       ylabel&#x3D;&#39;count&#39;, xlabel&#x3D;&#39;absolute error&#39;)\nax.legend(loc&#x3D;&#39;best&#39;)\n\nax &#x3D; axes[1]\npd.Series(random_evals).plot.kde(ax&#x3D;ax, label&#x3D;&#39;random guessing kde&#39;)\npd.Series(predicted_evals).plot.kde(ax&#x3D;ax, color&#x3D;&#39;r&#39;, label&#x3D;&#39;model prediction kde&#39;)\ntitle &#x3D; &#39;Kernel Density Estimate plot\\n&#39; \\\n        &#39;for polynomial evaluation of (predicted) roots&#39;\nax.set(xlim&#x3D;[-.5, .5], title&#x3D;title)\nax.legend(loc&#x3D;&#39;best&#39;)\n\nfig.tight_layout()\n</code></pre>\n<h2 id=\"高斯噪声的添加\"><a href=\"#高斯噪声的添加\" class=\"headerlink\" title=\"高斯噪声的添加\"></a>高斯噪声的添加</h2><p>首先，我们采用较小数据集：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">N_SAMPLES &#x3D; 100000\nDEGREE &#x3D; 5</code></pre>\n<h3 id=\"对数据集加噪声\"><a href=\"#对数据集加噪声\" class=\"headerlink\" title=\"对数据集加噪声\"></a>对数据集加噪声</h3><p>未加噪声（1）：<br><img src=\"https://img-blog.csdnimg.cn/e597822f51074b2e87612b30cdb12e0f.png#pic_center\" alt=\"在这里插入图片描述\"><br>未加噪声（2）：<br><img src=\"https://img-blog.csdnimg.cn/3da37b9cc14049e8925835861e6a776c.png#pic_center\" alt=\"在这里插入图片描述\"><br>(sigma=0)-1<br><img src=\"https://img-blog.csdnimg.cn/68987097d57d403e8f665a084b848cda.png#pic_center\" alt=\"在这里插入图片描述\"><br>(sigma=0)-2:<br><img src=\"https://img-blog.csdnimg.cn/1c853aa93cf44531b35b6679cd997b5b.png#pic_center\" alt=\"在这里插入图片描述\"><br>(sigma=0.05):<br><img src=\"https://img-blog.csdnimg.cn/5633788f40c545aeae125fb3057e2fa2.png#pic_center\" alt=\"在这里插入图片描述\"><br>(sigma=0.5):<br><img src=\"https://img-blog.csdnimg.cn/2a57ed0fed8543d0bc181fb42578cae7.png#pic_center\" alt=\"在这里插入图片描述\"><br>(sigma=1):<br><img src=\"https://img-blog.csdnimg.cn/beb21b934556463994419b788372a7e5.png#pic_center\" alt=\"在这里插入图片描述\"><br>问题不大。</p>\n<h3 id=\"在函数中加噪声\"><a href=\"#在函数中加噪声\" class=\"headerlink\" title=\"在函数中加噪声\"></a>在函数中加噪声</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">def make(n_samples, n_degree):\n    global MIN_ROOT, MAX_ROOT\n    y &#x3D; np.random.uniform(MIN_ROOT, MAX_ROOT, (n_samples, n_degree))\n    y.sort(axis&#x3D;1)\n    X &#x3D; np.array([np.poly(_) for _ in y])\n    gauss_noisy(X, y)\n    return X, y</code></pre>\n<p>(sigma=0)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/4687d9c9fc4847ee8abf49a2f681e930.png#pic_center\" alt=\"在这里插入图片描述\">（sigma=0.01）:<br><img src=\"https://img-blog.csdnimg.cn/733af065c3a6445483722418fe3cb0b9.png#pic_center\" alt=\"在这里插入图片描述\"><br>（sigma=0.05）:<br><img src=\"https://img-blog.csdnimg.cn/7cde121718624f88995bd52c4584aaeb.png#pic_center\" alt=\"在这里插入图片描述\"><br>（sigma=0.1）:<br><img src=\"https://img-blog.csdnimg.cn/e359cf11e01a46d3b1711d55c6d97941.png#pic_center\" alt=\"在这里插入图片描述\"><br>（sigma=0.1）:</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c1cc53f4c302494f86d2511de858089a.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"在训练集中加噪声\"><a href=\"#在训练集中加噪声\" class=\"headerlink\" title=\"在训练集中加噪声\"></a>在训练集中加噪声</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">gauss_noisy(X_train, y_train)</code></pre>\n<p>（sigma=0.05）:<br><img src=\"https://img-blog.csdnimg.cn/b2a0d5de15df41bfa133cda9c7fb881d.png\" alt=\"请添加图片描述\"><br>（sigma=0.05,epoch=10,l=4）:l为神经网络层数<br><img src=\"https://img-blog.csdnimg.cn/28bf557ee5b442d1812b8529a8843c73.png#pic_center\" alt=\"在这里插入图片描述\"><br>（sigma=0.1）:<br><img src=\"https://img-blog.csdnimg.cn/d30ee2de1ec74d2994f8f037fbb12655.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>（sigma=0.1,epoch=5,l=4）:l为神经网络层数<br><img src=\"https://img-blog.csdnimg.cn/51fd95bd43cc443ba4e9b85db3062785.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>（sigma=0.1,epoch=10,l=4）:l为神经网络层数<br><img src=\"https://img-blog.csdnimg.cn/81ca19d169c14d7f90b70689259766fc.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>（sigma=0.5,epoch=5,l=2）:l为神经网络层数<br><img src=\"https://img-blog.csdnimg.cn/5c67d93016ed4265ac347d24a4e1f34d.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n","text":"代码注释随机数 出于我们的目的，我将创建一组具有根的此类多项式。实际上，我将首先创建根，然后创建多项式，如下所示： import numpy as np MIN_ROOT &#x3D; -1 MAX_ROOT &#x3D; 1 def make(n_samples, n_degr...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"机器学习","slug":"机器学习","count":9,"path":"api/categories/机器学习.json"}],"tags":[{"name":"深度学习","slug":"深度学习","count":9,"path":"api/tags/深度学习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">代码注释</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%8F%E6%9C%BA%E6%95%B0\"><span class=\"toc-text\">随机数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%92%E5%88%86%E6%95%B0%E6%8D%AE%E9%9B%86\"><span class=\"toc-text\">划分数据集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#reshape\"><span class=\"toc-text\">reshape</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9E%8B%E5%BB%BA%E7%AB%8B\"><span class=\"toc-text\">模型建立</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">模型定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%84%E6%B5%8B%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">预测数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%98%E5%9B%BE\"><span class=\"toc-text\">绘图</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%82%E8%A7%A3%E4%B8%8D%E5%90%8C%E7%A8%8B%E5%BA%A6%E5%A4%9A%E9%A1%B9%E5%BC%8F\"><span class=\"toc-text\">求解不同程度多项式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%94%B9%E5%8F%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">改变模型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">训练模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%84%E6%B5%8B%E6%95%B0%E6%8D%AE-1\"><span class=\"toc-text\">预测数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9E%8B%E6%A3%80%E9%AA%8C\"><span class=\"toc-text\">模型检验</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0%E7%9A%84%E6%B7%BB%E5%8A%A0\"><span class=\"toc-text\">高斯噪声的添加</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E5%8A%A0%E5%99%AA%E5%A3%B0\"><span class=\"toc-text\">对数据集加噪声</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8A%A0%E5%99%AA%E5%A3%B0\"><span class=\"toc-text\">在函数中加噪声</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E8%AE%AD%E7%BB%83%E9%9B%86%E4%B8%AD%E5%8A%A0%E5%99%AA%E5%A3%B0\"><span class=\"toc-text\">在训练集中加噪声</span></a></li></ol></li></ol>","author":{"name":"Algernon","slug":"blog-author","avatar":"https://user-images.githubusercontent.com/54904760/224857900-b2e8457c-43d2-46b7-901c-6c770f24bbad.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}},"mapped":true,"prev_post":{"title":"《基于深度学习的自然语言处理》笔记","uid":"1be85ad561954f8e295d5b1c686f2a6f","slug":"基于深度学习的自然语言处理","date":"2022-11-03T14:20:49.000Z","updated":"2022-11-08T16:18:09.514Z","comments":true,"path":"api/articles/基于深度学习的自然语言处理.json","keywords":null,"cover":null,"text":"深度学习一般是指建立在含有多层非线性变换的神经网络结构之上，对数据的表示进行抽象和学习的一系列机器学习算法。 深度学习主要为自然语言处理的研究带来了两方面的变化：一方面是使用统一的分布式（低维、稠密、连续）向量表示不同粒度的语言单元，如词、短语、句子和篇章等；另一方面是使用循环、...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"机器学习","slug":"机器学习","count":9,"path":"api/categories/机器学习.json"}],"tags":[{"name":"NLP","slug":"NLP","count":2,"path":"api/tags/NLP.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://user-images.githubusercontent.com/54904760/224857900-b2e8457c-43d2-46b7-901c-6c770f24bbad.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}},"next_post":{"title":"【python机器学习基础教程】（二）","uid":"f0027b7e0577432cae210c02a7d12c2f","slug":"python机器学习2","date":"2022-11-03T14:15:49.000Z","updated":"2022-11-04T02:57:39.413Z","comments":true,"path":"api/articles/python机器学习2.json","keywords":null,"cover":[],"text":"监督学习监督学习算法朴素贝叶斯分类器朴素贝叶斯分类器通过单独查看每个特征来学习参数，并从每个特征中收集简单的类别统计数据。scikit-learn中实现了三种朴素贝叶斯分类器：GaussianNB、BernoulliNB和MultinomialNB。GaussianNB可应用于任...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"机器学习","slug":"机器学习","count":5,"path":"api/tags/机器学习.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://user-images.githubusercontent.com/54904760/224857900-b2e8457c-43d2-46b7-901c-6c770f24bbad.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}}}