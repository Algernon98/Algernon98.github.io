{"title":"【区块链技术与应用】（一）","uid":"9707db72db0abf36328a217eb8d73065","slug":"区块链1","date":"2022-11-03T14:58:49.000Z","updated":"2022-11-08T16:30:06.004Z","comments":true,"path":"api/articles/区块链1.json","keywords":null,"cover":[],"content":"<h2 id=\"技术胖\"><a href=\"#技术胖\" class=\"headerlink\" title=\"技术胖\"></a>技术胖</h2><h3 id=\"开启docker\"><a href=\"#开启docker\" class=\"headerlink\" title=\"开启docker\"></a>开启docker</h3><p>使用<code>systemctl start</code>命令，开启Docker服务端。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">sudo systemctl start docker</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/7e73ec4829e747e99651e43df4a836c5.png\" alt=\"请添加图片描述\">创建容器后，如果查看这个容器的信息和状态那？这时候你可以使用下面的命令。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">docker container ls</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/83ebde19d9f34fdc9d4fa0f6c3949204.png\" alt=\"请添加图片描述\">这时候我们需要学一个新的查看命令，比如只查看现在所有容器的ID,命令如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">docker container ps -aq</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/7f0d025498eb4f30be504b73134f6d2a.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"attached-和detached模式\"><a href=\"#attached-和detached模式\" class=\"headerlink\" title=\"attached 和detached模式\"></a>attached 和detached模式</h3><p>在开启端口映射之前，你首先要之道Docker对应的容器端口是多少。比如Nginx镜像的端口诗<code>80</code>。知道这个端口后，就可以在启动容器的时候，用<code>-p &lt;port:port&gt;</code> 的形式，启用映射了。</p>\n<p>用Nginx举例:</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -p 80:80 nginx</code></pre>\n<p>等待项目启动后，打开浏览器窗口，在地址栏输入<code>127.0.0.1</code>，就可以打开nginx的默认网址。<br><img src=\"https://img-blog.csdnimg.cn/ba3890bf818e4f77a00ce33e5711372f.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/c044e736989442ad8fbd677407775f4e.png\" alt=\"请添加图片描述\"><br>第一个端口是映射到服务器本机的端口;第二个端口是Docker容器使用的端口。 比如你想把Docker的80端口，映射到服务器的90端口。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -p 90:80 nginx</code></pre>\n<p><a href=\"https://jspang.com/article/75#toc327\">attached模式</a></p>\n<p>两种模式最简单的对比理解就是：attached模式在前台运行，detached模式在后台运行。</p>\n<p>当你打开<code>127.0.0.1</code>网址的时候，<code>PowerShell</code>上打印出了相关的日志（log），平且每访问一次，都会增加一条日志。也就是说Docker容器的日志会实时的展现到窗口并且占用此端口。这种模式叫做<code>attached</code>模式。<br><img src=\"https://img-blog.csdnimg.cn/4d4e9903685c48acb238737aa705ce78.png\" alt=\"请添加图片描述\"><br>在windows系统下并不是一个完整的attached模式，只是帮我们打印出了Log。现在到Linux服务器上，这时候你按<code>Ctrl+C</code>,就会停止掉<code>Docker</code>服务。而现实中我们工作的环境恰恰是这种Linux环境。</p>\n<p>也就是在Linux上你的操作命令，会直接传递个<code>Docker容器</code>。这个缺点就是很容易误操作，比如在公司的生产环境中，你直接一个<code>Ctrl+C</code>，整个服务就崩掉了，你这个月的绩效也就没有了。</p>\n<p>所以我们需要一个更好的，更稳定的模式。也就是detached模式。attached模式更适用于容器和程序的调试阶段。</p>\n<p><a href=\"https://jspang.com/article/75#toc328\">detached模式</a></p>\n<p><code>detached模式</code>的开启方法，就是加一个参数<code>-d</code>或者<code>--detach</code>。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker run -d -p 80:80 nginx</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/a95e96d4e9ac442db8e58941af69a1c9.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"docker交互模式\"><a href=\"#docker交互模式\" class=\"headerlink\" title=\"docker交互模式\"></a>docker交互模式</h3><p>有时候容器的镜像不是简单的一个服务，而是需要交互的操作系统。例如创建一个Ubuntu系统，然后需要到系统里输入各种Shell命令和系统进行交互。这时候<code>attached模式</code>和<code>detached模式</code>就不能满足要求了。需要使用交互模式。</p>\n<p><a href=\"https://jspang.com/article/75#toc333\">使用Ubuntu镜像并开启交互模式</a></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -it ubuntu sh</code></pre>\n<p><code>-it</code>代表启用交互模式，<code>sh</code>代表可以使用Shell脚本。当你输入玩这个脚本后，Docker就会进入到交互模式。可以使用<code>ls</code>来得到目录下的文件，也可以使用<code>hostname</code>来查看计算机名称。</p>\n<p>这时候你想退出容器和交互模式可以输入<code>exit</code>命令。需要重点说明的是，随着命令退出后，容器也会跟着退出，变成<code>Exited</code>模式。</p>\n<p><a href=\"https://jspang.com/article/75#toc334\">detached模式下的交互</a></p>\n<p>如果我们想退出交互，但是并不想停止容器。可以先开启<code>detached模式</code>，然后通过命令进入交互模式。我们来操作一下,先删除所有的容器。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container rm -f $(docker container ls -aq)</code></pre>\n<p>然后再用<code>detached模式</code>创建一个<code>nginx镜像</code>的容器。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -d -p 80:80 nginx</code></pre>\n<p>直接通过下面的命令就可以进入到交互模式下了。(这是我们以后要经常使用的一个命令)</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker exec -it &lt;ID or Image name&gt; sh </code></pre>\n<p><code>exec</code>是执行的意思，<code>-it</code>交互模式 ， <code>sh</code>交互的方式，用shell脚本进行交互</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>整个命令的意思是：用shell脚本的方式执行交互模式。</p></blockquote>\n<p>进入后可以使用<code>ls</code>来查看容器的文件系统。</p>\n<p>这种模式的优点是，再使用<code>exit</code>退出后，服务并不会停止，而只是退出了交互模式。可以自己尝试一下退出，然后使用<code>docker container ls -a</code>来查看一下容器的状态，你会发现依然是 <code>up状态</code>。<br><img src=\"https://img-blog.csdnimg.cn/5418e4b446134c38abfd19fff8057a2d.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/2fcbbecb7f1740c09308fdd00eb06bfb.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"Image镜像的拉取和删除\"><a href=\"#Image镜像的拉取和删除\" class=\"headerlink\" title=\"Image镜像的拉取和删除\"></a>Image镜像的拉取和删除</h3><p>从dockerhub上拉取镜像](<a href=\"https://jspang.com/article/75#toc339\">https://jspang.com/article/75#toc339</a>)</p>\n<p>当在<code>PowerShell</code>里输入<code>docker image</code> 命令后，会出现对于Image操作的所有命令和提示（算帮助信息吧）。<br><img src=\"https://img-blog.csdnimg.cn/0b27dd9b208e461ebae6503966af8d75.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/8e6d011f211c4d6eb5828d98cb4395fe.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/8b92ac6f41434aa3a0b0867b6e3add16.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/98a4fa8d24ae4789a34656e631096fcb.png\" alt=\"请添加图片描述\"></p>\n<p><strong>查看镜像列表的方法</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image ls</code></pre>\n<p>通过这条命令就可以查看Docker中有的镜像和相关信息。<br><img src=\"https://img-blog.csdnimg.cn/ebddf1ff003944a880e23b53636635a3.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"初识Dockerfile\"><a href=\"#初识Dockerfile\" class=\"headerlink\" title=\"初识Dockerfile\"></a>初识Dockerfile</h3><p>什么是Dockerfile](<a href=\"https://jspang.com/article/75#toc347\">https://jspang.com/article/75#toc347</a>)</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。</p></blockquote>\n<p>可以简单总结为下面三点：</p>\n<ul>\n<li>Dockerfile是用于构建docker镜像的文件</li>\n<li>Dockerfile里包含了构建镜像所需的”指令“</li>\n<li>Dockerfile有其特定的语法规则（重要学习）<br>Demo-执行Python程序](<a href=\"https://jspang.com/article/75#toc348\">https://jspang.com/article/75#toc348</a>)</li>\n</ul>\n<p>有这样一个需求，制作一个镜像。镜像的操作系统是<code>Ubuntu</code>最新版，然后在系统上运行<code>jspang.py</code>程序。Python程序的内容非常简单，只要打印出<code>Hello JSPang</code>，就可以了。</p>\n<p>第一步，安装一个Ubuntu系统。</p>\n<p>第二步，下载安装Python环境</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">apt-get update &amp;&amp; \\\nDEBIAN_FRONTEND&#x3D;noninteractive apt-get install --no-install-recommends -y python3.9 python3-pip python3.9-dev</code></pre>\n<p>第三步，准备<code>jspang.py</code>文件。这个可以在<code>D盘</code>新建一个<code>DockerTest文件夹</code>，然后在文件夹中新建一个<code>jspang.py</code>文件，然后编写下面的文件。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">print(&quot;Hello JSPang&quot;)</code></pre>\n<p>第四步，运行jspang.py</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">$ python3 hello.py\nhello docker</code></pre>\n<p>这是我们拆解的步骤，有步骤之后，我们看看如何写一个Dockerfile文件（建议把Dockerfile文件和jspang.py文件放在一起个文件夹下）</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">FROM ubuntu:latest\nRUN  apt-get update &amp;&amp; \\\n         DEBIAN_FRONTEND&#x3D;noninteractive apt-get install --no-install-recommends -y python3.9 python3-pip python3.9-dev\nADD jspang.py &#x2F;\nCMD [&quot;python3&quot;,&quot;jspang.py&quot;]</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/c0c736ff48f04efba1e594e2ea346e68.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/7cd3a1ce1e6b47048c6d5e43c30978c5.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/7d2e795f2ea74d67bbec1fb4b104c8fc.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/b190d1f2eef94baab220ef3c99a40048.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"把镜像分享到Dockerhub\"><a href=\"#把镜像分享到Dockerhub\" class=\"headerlink\" title=\"把镜像分享到Dockerhub\"></a>把镜像分享到Dockerhub</h3><p>如果你想上传属于自己的镜像，需要遵守社区规则，就是<code>用户ID/镜像名称</code>。可以最简单的方法，就是重新<code>build</code>一个镜像，镜像名称符合社区规则就可以了。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image build -t jspangcom&#x2F;jspang .</code></pre>\n<p>这时候就会生成一下新的镜像，但是Image ID 是一摸一样的。</p>\n<p>也可以通过<code>docker image tag</code>命令，具体语法如下：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image tag &lt;old image name &gt; &lt;new iamge name&gt;</code></pre>\n<p>例如把<code>jspang</code>这个镜像，改为<code>jspangcom/jspang</code>镜像,命令可以如下：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image tag jspang jspangcom&#x2F;jspang</code></pre>\n<p><a href=\"https://jspang.com/article/75#toc353\">推送到Dockerhub上</a></p>\n<p>在推送前，需要先登录Dockerhub账号,登录命令如下：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker login</code></pre>\n<p>执行命令好，会要求输入<code>Username</code>，也就你<code>Dockerhub ID</code>，还需要输入密码。如果输入正确，并出现<code>Login Succeeded</code>就证明登录成功了。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image push Name[:TAG]</code></pre>\n<p>比如就是把刚才的<code>jspangcom/jspang</code>镜像push到社区，就可以使用下面的命令。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image push jspangcom&#x2F;jspang</code></pre>\n<p>输入完命令，就会给我们进行push到Dockerhub上了。这时候你可以到Dockerhub的profile页面，刷新一下，就可以看到刚刚push上去的镜像。</p>\n<p>（具体代码有修改，比如jspang我换成了biosheep）<br><img src=\"https://img-blog.csdnimg.cn/cdf3305426c94f62af0bd66be87029bb.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/4a314f263cca425893a74bc4e1b81ef0.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/3bdb93272c5a483faab25d8f2631489b.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/f4dfef2ac7024b6ba90679c41930911b.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/4399d60a166a484eae355e1902235602.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/a5d4d27c9d5b4874a901f4d208f16932.png\" alt=\"请添加图片描述\"><br>输入完命令，就会给我们进行push到Dockerhub上了。这时候你可以到Dockerhub的profile页面，刷新一下，就可以看到刚刚push上去的镜像。<br><img src=\"https://img-blog.csdnimg.cn/ab31973fc3d847ce8315e494784d1146.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/6cd24e21d0624d68aec0bff0f3691d94.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/734ee86438064b578b75a0d7361a1950.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"Dockerfile命令操作\"><a href=\"#Dockerfile命令操作\" class=\"headerlink\" title=\"Dockerfile命令操作\"></a>Dockerfile命令操作</h3><p>纯净的Ubuntu系统是没有ipinfo命令的，在安装完系统后，都会安装ipinfo命令。步骤如下：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">$ apt-get update\n$ apt-get install wget\n$ wget https:&#x2F;&#x2F;github.com&#x2F;ipinfo&#x2F;cli&#x2F;releases&#x2F;download&#x2F;ipinfo-2.0.1&#x2F;ipinfo_2.0.1_linux_amd64.tar.gz\n$ tar zxf ipinfo_2.0.1_linux_amd64.tar.gz\n$ mv ipinfo_2.0.1_linux_amd64 &#x2F;usr&#x2F;bin&#x2F;ipinfo\n$ rm -rf ipinfo_2.0.1_linux_amd64.tar.gz</code></pre>\n<p>上面这段代码需要你会一些Linux 的基本操作，其实就是安装，解压和删除下载文件 的一个过程。<br>把所有执行命令放到一个RUN里，并用<code>&amp;&amp; \\</code>进行连接。就可以把很多命令写到一个RUN里边了。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">FROM ubuntu:latest\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y wget &amp;&amp; \\\n    wget https:&#x2F;&#x2F;github.com&#x2F;ipinfo&#x2F;cli&#x2F;releases&#x2F;download&#x2F;ipinfo-2.0.1&#x2F;ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \\\n    tar zxf ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \\\n    mv ipinfo_2.0.1_linux_amd64 &#x2F;usr&#x2F;bin&#x2F;ipinfo &amp;&amp; \\\n    rm -rf ipinfo_2.0.1_linux_amd64.tar.gz</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/4cdf47e9f4c8494083750c91b3f8645f.png\" alt=\"请添加图片描述\"></p>\n<p>这样所有的RUN命令只生成一层<code>image layer</code>。打包出来的镜像也没有那么大了。我们把这个文件写到<code>Dockerfile.good</code>文件里，然后用命令进行打包。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image build -f dockerfile.good -t ipinfo-good .</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/9f07a980ae254458bbcb0f837fc3d92e.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/8065cb68089746668f28bc4280dcdf42.png\" alt=\"请添加图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/4fa49c0806334715a4925d7e57743179.png\" alt=\"请添加图片描述\"></p>\n<p>这时候再用<code>docker image histroy &lt;Image ID&gt;</code> 查看分层，就会看到分层少了很多。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">PS D:\\TestDocker&gt; docker image history e89\nIMAGE          CREATED         CREATED BY                                      SIZE      COMMENT\ne893cd98aa4e   2 minutes ago   RUN &#x2F;bin&#x2F;sh -c apt-get update &amp;&amp;     apt-get…   46.7MB    buildkit.dockerfile.v0\n&lt;missing&gt;      3 weeks ago     &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;bash&quot;]                 0B\n&lt;missing&gt;      3 weeks ago     &#x2F;bin&#x2F;sh -c #(nop) ADD file:5c3d9d2597e01d1ce…   72.8MB</code></pre>\n<p>两个包的体积也会有所变化,good镜像是<code>119MB</code>,bad镜像是<code>134MB</code>。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">PS D:\\TestDocker&gt; docker image ls\nREPOSITORY            TAG       IMAGE ID       CREATED          SIZE\nipinfo-good           latest    e893cd98aa4e   3 minutes ago    119MB\nipinfo-bad            latest    e9c79d165e5c   14 minutes ago   134MB</code></pre>\n<p>COPY<code>和</code>ADD`命令，在复制普通文件的时候，并没有什么太大的不同，两个命令都可以把本地文件，复制到镜像里。（如果复制的路径不存在，则会自动创建）</p>\n<p>现在我们写一个Dockerfile，里边的内容是用基础Node镜像，然后拷贝一个<code>index.js</code>文件进去。</p>\n<p>Dockerfile.copy内容如下.</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">FROM node:alpine3.14\nCOPY index.js  &#x2F;app&#x2F;index.js</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/0be01f0fba474b66b29fc1c23f3992dd.png\" alt=\"请添加图片描述\"></p>\n<p>引用node3.13版本，然后把<code>index.js</code>文件，拷贝到<code>app</code>目录下面。</p>\n<p>index.js文件如下。代码是我们在3000端口上，开启了一个最简单web服务，然后返回了<code>Hello Nodejs</code>两个单词。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F;1. 导入 http 模块\n  const http &#x3D; require(&#39;http&#39;);\n  &#x2F;&#x2F;2. 创建服务器对象\n  const server &#x3D; http.createServer();\n  &#x2F;&#x2F;3. 开启服务器\n  server.listen(3000, () &#x3D;&gt; &#123;\n      console.log(&#39;Server is running...&#39;);\n  &#125;);\n  &#x2F;&#x2F;4. 监听浏览器请求并进行处理\n  server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; end方法能够将数据返回给浏览器，浏览器会显示该字符串\n      res.end(&#39;Hello Nodejs&#39;);\n  &#125;);</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/992b79843d844890a498d6e72b626cf1.png\" alt=\"请添加图片描述\"></p>\n<p>两个文件准备好以后，用<code>build</code>命令进行构建。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image build -f Dockerfile.copy -t hello-copy .</code></pre>\n<p>构建完成后，可以使用<code>doc\nker image ls</code>命令进行查询。生成成功后，可以启用交互模式，再加上映射端口的形式，运行容器。<br><img src=\"https://img-blog.csdnimg.cn/b1f2bfa05e8a4ec5891df655a10f6851.png\" alt=\"请添加图片描述\"></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -it -p 3000:3000 hello-copy sh</code></pre>\n<p>这里映射了3000端口，这样我们就可以用<code>127.0.0.1:3000</code>进行访问了。</p>\n<p><a href=\"https://jspang.com/article/75#toc363\">用ADD构建镜像</a></p>\n<p><code>ADD</code> 构建镜像和<code>COPY</code>最直观的一点不同，是ADD命令可以直接解压<code>gzip</code>压缩文件，这当我们有很多文件要上传操作的时候，就会变的简单很多。</p>\n<p>Dockerfile.add文件内容</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">FROM node:alpine3.14\nADD index.tar  &#x2F;app&#x2F;</code></pre>\n<p>用<code>ADD</code>命令进行打包镜像</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image build -f Dockerfile.add -t hello-gzip .</code></pre>\n<p>打包好以后使用交互模式，开启容器。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -it -p 3000:3000 hello-gzip sh</code></pre>\n<p>再进入<code>app</code>路径下面，可以看到下面自动给我们解压了<code>index.tar</code>文件。</p>\n<p><a href=\"https://jspang.com/article/75#toc364\">切换工作目录 WORKDIR</a></p>\n<p>在写Dockerfile文件时，默认的操作目录，是镜像的根目录。但有时候需要拷贝很多内容到镜像里是二级目录，就可以使用WORKDIR命令。把工作目录切换到二级，<code>WORKDIR</code>命令像我们操作linux下的<code>cd</code>命令。</p>\n<p>比如还是刚才的<code>Dockerfile.add</code>文件，我们可以使用<code>WORKDIR</code>命令，改成下面的形式。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">FROM node:alpine3.14\nWORKDIR &#x2F;app\nADD index.tar  index.js</code></pre>\n<p>这时候进入系统后的工作目录，就是在<code>/app</code>下面了。</p>\n<h3 id=\"数据持久化\"><a href=\"#数据持久化\" class=\"headerlink\" title=\"数据持久化\"></a>数据持久化</h3><h4 id=\"volume\"><a href=\"#volume\" class=\"headerlink\" title=\"volume\"></a>volume</h4><p>当知道了容器中的数据不能持久化后，可以在编写<code>Dockerfile</code>时用<code>VOLUME</code>命令设置持久化的目录。</p>\n<p><strong>新建一个<code>Dockerfile</code>文件</strong></p>\n<p>在<code>CentOS</code>下，新建一个<code>test</code>目录，然后在<code>test</code>目录下，新建一个<code>Dockerfile</code>文件，使用<code>vim</code>编辑文件，写入下面的命令。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">FROM NGINX\nVOLUME [&quot;&#x2F;app&quot;]</code></pre>\n<p>有了<code>Dockerfile</code>文件后，开始构建镜像，</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker image build -t my-image .</code></pre>\n<p>构建好镜像，启动镜像容器。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -d my-image</code></pre>\n<p>启动后查看容器ID。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container ls</code></pre>\n<p>进入交互模式</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container exec -it &lt;ContainerID&gt; sh</code></pre>\n<p>再安装vim.</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">apt-get update\napt-get install vim</code></pre>\n<p>这时候再新建一个<code>app</code>目录，然后编写<code>test.txt</code>文件。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">Hello JSPang.com</code></pre>\n<p>这时候，再删除镜像，就可以找到我们持久化的数据了。那这些持久化的数据被保存到了那里哪？这就需要我们再学习一下<code>docker volume</code>的相关命令了。</p>\n<p><a href=\"https://jspang.com/article/75#toc381\">docker volume 相关命令</a></p>\n<p>现在退出容器，来到<code>CentOS</code>当中，可以输入下面的命令,就可以看到<code>docker volume</code>相关的命令了。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\"># docker volume\n\nUsage:  docker volume COMMAND\n\nManage volumes\n\nCommands:\n  create      Create a volume\n  inspect     Display detailed information on one or more volumes\n  ls          List volumes\n  prune       Remove all unused local volumes\n  rm          Remove one or more volumes\n\nRun &#39;docker volume COMMAND --help&#39; for more information on a command.</code></pre>\n<p>可以用<code>docker volume ls</code> 查看所有的持久化空间，最主要的是可以看到<code>存储空间的ID</code>。</p>\n<p>有了 ID之后，使用下面的命令，可以查看到持久化的具体地址。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\"># docker volume ls\nDRIVER    VOLUME NAME\nlocal     c9fe0c3841af7d052034df6c1bc0b6092c75d9fb9a83d6d7a849ce465981a4d8\n# docker volume inspect c9fe0c3841af7d052034df6c1bc0b6092c75d9fb9a83d6d7a849ce465981a4d8\n[\n    &#123;\n        &quot;CreatedAt&quot;: &quot;2021-08-16T10:07:52+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: null,\n        &quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;c9fe0c3841af7d052034df6c1bc0b6092c75d9fb9a83d6d7a849ce465981a4d8&#x2F;_data&quot;,\n        &quot;Name&quot;: &quot;c9fe0c3841af7d052034df6c1bc0b6092c75d9fb9a83d6d7a849ce465981a4d8&quot;,\n        &quot;Options&quot;: null,\n        &quot;Scope&quot;: &quot;local&quot;\n    &#125;\n]</code></pre>\n<p>其中的<code>Mountpoint</code>就是持久化的地址，复制这个地址，然后用<code>cd</code>命令进入。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;c9fe0c3841af7d052034df6c1bc0b6092c75d9fb9a83d6d7a849ce465981a4d8&#x2F;_data</code></pre>\n<p>然后输入<code>ls</code>，就可以看到在进行中我们编辑的<code>test,.txt</code>文件了。这时候再删除容器，这个文件也是存在的。<br>想要复用持久化数据很简单，就是给volume起个名字。</p>\n<p>在启动一个容器的时候，可以使用<code>-v</code>，给容器中的volume起一个名字。比如还使用我们之前自己创建的镜像<code>my-image</code>。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -d -v &lt;Volume name:Dockerfile VOLUME path&gt;   my-image</code></pre>\n<p>例如启动容器的时候给volume起个名字叫<code>my-data</code>,然后指定Dockerfile中的VOLUME命令路径。因为一个Dockerfile中可能有多个<code>VOLUME</code>命令，所以这里一定要准确指定路径。（注意是Dockerfile中VOLUME命令下的路径）。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -d -v my-data:&#x2F;app my-image</code></pre>\n<p>这时候再查看<code>volume</code>，这时候的<code>VOLUME NAME</code>就不是一大串类似ID的东西了，而是我们起的名字。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\"># docker volume ls\nDRIVER    VOLUME NAME\nlocal     my-data</code></pre>\n<p>再通过下面的命令，查看一下持久化的详细地址。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\"># docker volume inspect my-data\n[\n    &#123;\n        &quot;CreatedAt&quot;: &quot;2021-08-18T15:12:51+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: null,\n        &quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;my-data&#x2F;_data&quot;,\n        &quot;Name&quot;: &quot;my-data&quot;,\n        &quot;Options&quot;: null,\n        &quot;Scope&quot;: &quot;local&quot;\n    &#125;\n]</code></pre>\n<p><a href=\"https://jspang.com/article/75#toc384\">进入容器，修改数据</a></p>\n<p>为了证明数据可以复用，现在我们进入容器，然后新建一个test.txt文件，写点内容。</p>\n<p>进入容器的交互模式</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container exec -it &lt;Docker ID&gt; sh</code></pre>\n<p>再进入到<code>/app</code>目录下面，然后用<code>echo</code>向<code>test.txt</code>文件里写入内容。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">echo &quot;Hello mybaby!&quot; &gt; test.txt</code></pre>\n<p><a href=\"https://jspang.com/article/75#toc385\">删除容器后，重新开启容器</a></p>\n<p>现在强制删除刚才的容器。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container rm -f &lt;Container ID&gt;</code></pre>\n<p>删除以后看一下volume是否还在，答案是肯定的，一定是在的。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\"># docker volume ls\nDRIVER    VOLUME NAME\nlocal     my-data</code></pre>\n<p>现在我们用这个镜像，再启动一个容器。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container exec -it &lt;Container ID&gt;  sh</code></pre>\n<p>然后再查看<code>test.txt</code>内容，可以看到内容已经回到了容器中，可以继续修改并使用了。</p>\n<h4 id=\"Bind-Mount\"><a href=\"#Bind-Mount\" class=\"headerlink\" title=\"Bind Mount\"></a>Bind Mount</h4><p>数据持久化除了<code>Data Volume</code>外，还有一种叫做<code>Bind Mount</code>，从中文翻译来讲，就是<code>挂载绑定</code>。简单讲就是把容器中持久化的数据，绑定到本机的一个自定义位置。<br>使用<code>Bind Mount</code>进行数据持久化的方法，和<code>Data Volume</code>类似，也需要在启动容器的时候用到<code>-v</code>参数，只是参数的编写结构不同。</p>\n<p>比如在windos11下进入<code>PowerShell</code>，运行一个Node的容器，然后把<code>/app</code>目录作为，把本机的当前目录作为绑定目录，意思是容器中的app目录和本机的当前目录绑定到了一起。命令如下：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -it -v $&#123;pwd&#125;:&#x2F;app node</code></pre>\n<p>上面命令具体的意思是，用<code>Bind Mount</code>的形式，开启一个node容器。然后进入交互模式。</p>\n<p>其实这时候就实现了<code>Bind Mount</code>的数据持久化。而且你可以在本机新建和操作内容，然后在容器中运行。</p>\n<p><a href=\"https://jspang.com/article/75#toc389\">本机编写index.js插件</a></p>\n<p>比如在本机的绑定目录新建一个<code>index.js</code>文件，然后每秒钟显示一下时间。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">console.log(&#39;show Time&#39;)\nsetInterval(()&#x3D;&gt;&#123;\n    console.log(Date())\n&#125;,1000)</code></pre>\n<p>写完这个文件后，到<code>PowerShell</code>里也是可以看到这个文件的。这样就算本机没有<code>Node</code>环境，可以在容器中进行使用。</p>\n<p>进入容器的<code>/app</code> 目录，运行<code>node index.js</code>命令，就可以显示时间了。</p>\n<h3 id=\"docker-compose\"><a href=\"#docker-compose\" class=\"headerlink\" title=\"docker-compose\"></a>docker-compose</h3><h4 id=\"docker-compose-介绍和安装\"><a href=\"#docker-compose-介绍和安装\" class=\"headerlink\" title=\"[docker-compose ]介绍和安装\"></a>[docker-compose ]介绍和安装</h4><p>什么是Docker-compose？</p>\n<p>熟悉Linux都知道，我们可以把很多相关的命令写成一个<code>xxx.sh</code>文件，而且这些步骤也是相对固定的。</p>\n<p>这样直接运行sh文件，就可以逐一执行很多相关的Docker命令。这种形式可以减少出错和解决复用问题。Docker很贴心的为我们准备了一个专门的工具<code>docker-compose</code>，实现类似<code>sh</code>文件的功能。让我们更加轻松的实现多Docker命令的操作。</p>\n<p>你也可以把<code>docker-compose</code>就是把很多Docker命令写入一个专属的文件<code>docker-compose.yml</code>，然后执行这个文件，就可以直接启动我们想要的容器。<code>docker-compose</code>也为我们提供了对应的操作命令。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>docker-compose up</li>\n</ul></blockquote>\n<ul>\n<li>docker-compose stop</li>\n</ul>\n<p>也就是说，操作docker-compose 会有两个大的部分需要操作:</p>\n<ul>\n<li>第一部分是<code>docker-compose.yam</code>文件</li>\n<li>输入命令执行构建容器<br><strong>Linux官方推荐方法安装</strong></li>\n</ul>\n<p>Linux系统默认是没有安装<code>docker-compose</code>工具的，可以进入下面的网址。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://docs.docker.com/desktop/\">https://docs.docker.com/desktop/</a></p></blockquote>\n<p>进入亡之后，选择<code>Product Manuals</code> —&gt;<code>Docker compose</code>—&gt;<code>Liunx</code>后，可以看到三条命令，依次执行就可以安装<code>docker-compose</code>工具了。</p>\n<p>第一条命令：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.29.2&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</code></pre>\n<p>如果一次安装不成功，可以多安装几次。一般是网络问题。</p>\n<p>第二条命令：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</code></pre>\n<p>第三条命令：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose</code></pre>\n<p>安装好以后，用<code>docker-compose —version</code> 进行检查，如果能出现版本，说明安装成功了。<br><img src=\"https://img-blog.csdnimg.cn/ab055530e9c94c9ea2784db2936e8f0b.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/479fd00d9edd4acab8cf16c3f57f31f4.png\" alt=\"请添加图片描述\"></p>\n<h4 id=\"docker-compose-文件的结构和版本\"><a href=\"#docker-compose-文件的结构和版本\" class=\"headerlink\" title=\"[docker-compose]文件的结构和版本\"></a>[docker-compose]文件的结构和版本</h4><p>yaml`文件里是对启动镜像相关设置的所有描述，下面就逐一讲解一下。</p>\n<p>基本的yaml格式<code>docker-compose.yml</code></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">version: &quot;3.8&quot;\n\nservices: # 容器\n  servicename: # 服务名字，这个名字也是内部 bridge网络可以使用的 DNS name\n    image: # 镜像的名字\n    command: # 可选，如果设置，则会覆盖默认镜像里的 CMD命令\n    environment: # 可选，相当于 docker run里的 --env\n    volumes: # 可选，相当于docker run里的 -v\n    networks: # 可选，相当于 docker run里的 --network\n    ports: # 可选，相当于 docker run里的 -p\n  servicename2:\n\nvolumes: # 可选，相当于 docker volume create\n\nnetworks: # 可选，相当于 docker network create</code></pre>\n<p>只是简单的看这些解释，你不可能学会yml文件的写法的，下面我们就以一个wordpress的镜像为例，制作yaml文件。</p>\n<p><a href=\"https://jspang.com/article/75#toc398\">wordpress的yaml文件写法</a></p>\n<p>用命令的写法：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -d -p 80:80 wordpress</code></pre>\n<p>yaml文件的写法：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">version: &quot;3.8&quot;\n\nservices:\n  my-wordpress:\n    image: wordpress:latest\n    ports:\n      - 80:80</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/7c18202a640844b7bd74b213c4ee6a60.png\" alt=\"请添加图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/a951e9b4018f4b078961e687e4600d84.png\" alt=\"请添加图片描述\"></p>\n<h4 id=\"docker-compose-镜像构建和拉取\"><a href=\"#docker-compose-镜像构建和拉取\" class=\"headerlink\" title=\"[docker-compose]镜像构建和拉取\"></a>[docker-compose]镜像构建和拉取</h4><p>我们用Dockerfile拉去一个<code>node</code>的镜像，构建一个新的镜像。这里是学习，所以就不作其他的Dockerfile的复杂定义了，就用最简单的来进行模拟。</p>\n<p>Dockerfile文件</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">FROM node:latest\nCMD []</code></pre>\n<p>这时候我们的<code>docker-compose.yml</code>文件如下。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">version: &quot;3.8&quot;\n\nservices:\n  my-node:\n    image: my-node:latest</code></pre>\n<p>这里的<code>image: my-node:latest</code>，是我们自己构建的镜像，但是目前还没有。如果用<code>docker compose up</code> 构建会直接报错。我们运行一下，可以看到下面的错误。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker compose up\n[+] Running 0&#x2F;1\n - my-node Error                                                                                              4.6s\nError response from daemon: pull access denied for my-node, repository does not exist or may require &#39;docker login&#39;: denied: requested access to the resource is denied</code></pre>\n<p>意思就是这个<code>my-node</code>镜像在网上找不到，仓库里没有。</p>\n<p>可以修改<code>docker-compose.yml</code>文件，让docker先构建镜像，然后再启动容器。</p>\n<p>修改后的<code>docker-compose.yml</code>文件</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">version: &quot;3.8&quot;\n\nservices:\n  my-node:\n    build: .&#x2F;file</code></pre>\n<p>修改后，这时候再使用<code>docker compose up</code>命令，这时候就会先进行构建镜像，然后再开启容器。</p>\n<p><a href=\"https://jspang.com/article/75#toc3107\">给自定义镜像命名</a></p>\n<p>这时候就不会报错了，也可以正常启动容器了。但是还是有问题的，用下面的命令查看镜像的名字。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\"># docker image ls\nREPOSITORY     TAG       IMAGE ID       CREATED      SIZE\ntest_my-node   latest    edf569856ed9   2 days ago   907MB</code></pre>\n<p>镜像的名字是<code>test_my-node</code>，这并不是我们想的叫做<code>my-node</code>。继续修改<code>docker-compose.yml</code>文件，增加<code>image</code>属性。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">version: &quot;3.8&quot;\n\nservices:\n  my-node:\n    build: .&#x2F;file\n    image: my-node:latest</code></pre>\n<p>在执行<code>docker compose up</code> 命令之前，可以执行下面的命令删除无用信息。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker system prune -f  # 删除没有使用的容器\ndockers image prune  -a  # 删除不使用的镜像 </code></pre>\n<p>然后再次输入下面的命令，启动容器</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker compose up</code></pre>\n<p>容器启动之后，你再使用<code>docker image ls</code> 会看到镜像的名字已经变成了设置的名字。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\"># docker image ls\nREPOSITORY   TAG       IMAGE ID       CREATED      SIZE\nmy-node      latest    edf569856ed9   2 days ago   907MB</code></pre>\n<p>这样就实现了用<code>docker compose</code>自动逸镜像的名字。</p>\n<p><strong>启动镜像前拉去镜像</strong></p>\n<p>上节课在<code>docker compose</code>中使用了<code>wordpress</code>的镜像。这个容器启动的时间是很长的，因为如果本地没有<code>wordpress</code>镜像，就要去官网上进行拉去，这个占用了95%以上的时间。这时候可以先使用下面的命令进行拉去镜像。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker compose pull</code></pre>\n<p>拉去wordpress镜像的时间比较长，这里就演示拉去node 的了。修改<code>docker-compose.yml</code>文件。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">version: &quot;3.8&quot;\n\nservices:\n  my-node:\n    image: node:latest</code></pre>\n<p>再使用<code>docker image ls</code>查看镜像列表，可以看到镜像已经被拉去到本地了。</p>\n<h3 id=\"网络-Docker的网络模式\"><a href=\"#网络-Docker的网络模式\" class=\"headerlink\" title=\"[网络]Docker的网络模式\"></a>[网络]Docker的网络模式</h3><p>一台服务器上可以跑很多容器，容器间是相互配合运行的。有配合就需要有网络通讯，就需要设置网络。</p>\n<p>比如现在我们启动一个<code>nginx</code>的容器，用<code>detached模式</code>启动，并映射端口到<code>80</code>上。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -d -p 80:80 nginx</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/6c3e79d3c04d40ccb1e4697840495d37.png\" alt=\"请添加图片描述\"></p>\n<p>容器启动后，可以用查看容器的具体信息。命令如下。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker inspect &lt;Container ID &gt;</code></pre>\n<p>输入完成后，你可以看到有很多信息。其中有一项是<code>Networks</code>，这个就是容器的网路设置了。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&quot;Networks&quot;: &#123;\n    &quot;bridge&quot;: &#123;\n       &quot;IPAMConfig&quot;: null,\n       &quot;Links&quot;: null,\n       &quot;Aliases&quot;: null,\n       &quot;NetworkID&quot;: &quot;bd2fe52b4c98ec5c5a11131a0bec714035ae25c791a518f7302d7f02c0aa8a75&quot;,\n       &quot;EndpointID&quot;: &quot;2b8e1ff95d9f0f56be7a9f3737a1a695f523c290aefcd8c5f08130b9fb4535df&quot;,\n       &quot;Gateway&quot;: &quot;172.17.0.1&quot;,\n       &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,\n        &quot;IPPrefixLen&quot;: 16,\n       &quot;IPv6Gateway&quot;: &quot;&quot;,\n       &quot;GlobalIPv6Address&quot;: &quot;&quot;,\n       &quot;GlobalIPv6PrefixLen&quot;: 0,\n       &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,\n       &quot;DriverOpts&quot;: null\n         &#125;\n    &#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fd3874cea83f489a9e001784e5601a85.png\" alt=\"请添加图片描述\"></p>\n<p>信息中是可以看出很多东西的，比如这个网络的连接方式是<code>bridge</code>，也就是桥接。然后IP地址<code>IPAddress</code>是<code>172.17.0.2</code>这个就是它的内网IP地址。</p>\n<p>为了看的更清晰，我们可以再启动一个<code>nginx</code>容器.</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container run -d -p 8080:80 nginx</code></pre>\n<p>这时候再使用<code>docker inspect &lt;Container ID &gt;</code>可以看到网络信息是下面这样的。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&quot;Networks&quot;: &#123;\n    &quot;bridge&quot;: &#123;\n        &quot;IPAMConfig&quot;: null,\n        &quot;Links&quot;: null,\n        &quot;Aliases&quot;: null,\n        &quot;NetworkID&quot;: &quot;bd2fe52b4c98ec5c5a11131a0bec714035ae25c791a518f7302d7f02c0aa8a75&quot;,\n        &quot;EndpointID&quot;: &quot;4686cd198f9e6bbc22b25d1ce2b8e58dbadb60c6b20158a5afaf1bf2856bcdb3&quot;,\n        &quot;Gateway&quot;: &quot;172.17.0.1&quot;,\n        &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,\n        &quot;IPPrefixLen&quot;: 16,\n        &quot;IPv6Gateway&quot;: &quot;&quot;,\n        &quot;GlobalIPv6Address&quot;: &quot;&quot;,\n        &quot;GlobalIPv6PrefixLen&quot;: 0,\n        &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,\n        &quot;DriverOpts&quot;: null\n    &#125;\n&#125;</code></pre>\n<p>可以看到这个网络依然是桥接，IP地址变成了<code>172.0.0.3</code>.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>也就是说每一个容器启动后都会有一个IP，并且每个IP是不同，自动变化的。这就是Docker为我们作的默认网络配置。并且虽然容器的启动顺畅，给的IP地址也是递增的。</p></blockquote>\n<p>这种默认的问题就是，如果每次启动的顺序不一样，IP地址就会不同，这样每次都要重新进行配置。这肯定在工作中是行不通的。真实工作中，可能一台服务器就有几十个容器，如果每次修改通讯地址，这个工作将变的混乱不堪，无法继续。</p>\n<p>那一般情况下，我们会通过<code>- -name</code>来置顶固定名称，然后再用名称进行通信。这种解决方案的前提就是需要了解网络模式和自定义网络后，才能实现可控状态。</p>\n<p>可以使用下面的命令进行查看主机上已经有的网络配置列表.</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker network ls</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/4f8a6c03324845189c0145a4d80b7c57.png\" alt=\"请添加图片描述\"></p>\n<p>如果你的主机 刚装好Docker，只有下面三种网络模式 名称：</p>\n<ul>\n<li>bridge ： 这个是网桥，我习惯性的说成桥接模式。为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0</code>虚拟网桥，默认为该模式。</li>\n<li>host ：使用主机模式，容器没有IP和网关这些，都是用实体主机的。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</li>\n<li>none ：就是不创建自己的IP网络。也就是常说的没有网，当然你可以自己进行定义网络模式。容器有独立的Network namespace，但并没有对其继续任何网络设置，如分配veth pair 和网桥连接，IP等。</li>\n<li>container : 就是利用其它容器的网络，别的容器有网络了，使用其它的容器网络。新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口等。此种方式不是默认网络模式，它需要基于另一个容器。</li>\n</ul>\n<p>这些网络模式都会在后面的课程中讲解，所以不要着急。这节课我们主要讲解第一种网络模式<code>Bridge模式</code>.</p>\n<h4 id=\"bridge网络模式\"><a href=\"#bridge网络模式\" class=\"headerlink\" title=\"bridge网络模式\"></a>bridge网络模式</h4><p>在该模式中，Docker守护进程创建了一个虚拟以太网桥 <code>docker 0</code>,新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。</p>\n<p>默认情况下，守护进程会创建一对 对等虚拟设备接口 <code>veth pair</code>, 将其中一个接口设置为容器的<code>eth0</code> 接口（也就是容器的网络/网卡接口），另一个接口放置在主机的命名空间中，以类似<code>vethxxx</code>这样的名字命名，从而将主机上的所有容器都连接到这个内部网络上。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5355b3b47baf742d1f032233c6c9c695.jpeg\" alt=\"docker_bridge.jpeg\"></p>\n<p>通过图可以清楚的看到桥接模式，<code>eth0</code>是主机网卡，<code>docker0</code>就是桥接网络，每个容器都有自己的<code>teh0</code>，然后通过<code>docker0</code>和主机进行通信，也形成了内部局域网。</p>\n<p><a href=\"https://jspang.com/article/75#toc3113\">用busybox查看网络</a></p>\n<p>为了更好的理解Bridge模式，我们启动一个<code>busybox</code>的镜像。 然后查看一下网络。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>busybox 被称为嵌入式Linux的瑞士军刀，整合了很多小的unix下的通用功能，并且只有一个很小的执行文件。</p></blockquote>\n<p>启动<code>busybox</code>的命令，这里使用了交互模式，并且给容器起了一个名字<code>bbox01</code>。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker run -it --name bbox01 busybox </code></pre>\n<p>当这个容器启动后，新启动一个<code>CentOS</code>远程主机的会话，然后使用<code>shell</code>命令看一下现在主机网络会多出一个<code>vethxxxxx</code>的信息</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">ip  addr</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/33c0d64ac7774cf78eae9f993083f16b.png\" alt=\"请添加图片描述\"></p>\n<p>然后再到busybox中查看网络信息，可以看出他们形成了一组网络配置。</p>\n<p>通过这个案例，你再回来看上面那段话，就会有深刻的了解。其实就是通过一对 <code>对等虚拟设备</code>实现网络通信，也就是桥接模式。</p>\n<h4 id=\"host网络模式\"><a href=\"#host网络模式\" class=\"headerlink\" title=\"host网络模式\"></a>host网络模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>host网络模式使用主机网络模式，容器没有IP和网关这些，都是用实体主机的。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p></blockquote>\n<ul>\n<li>采用host网络模式的Docker Container，可以直接使用主机的IP地址与外界进行通信，若主机的<code>eth0</code>是一个共有IP，那么容器有用这个共有IP。同时容器内服务的端口也可以使用端口，无需额外进行NAT转换。</li>\n</ul>\n<p>启动一个Nginx容器，这个容器的特点是不再使用默认的<code>bridge</code>模式，而是使用<code>host</code>模式。使用host模式的关键字是<code>- - network host</code>或者<code>- - net host</code>都可以</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker run -it --name nginx1 --network host nginx</code></pre>\n<p>启动后，可以打开浏览器，然后直接输入主机的IP地址，我的IP地址是<code>110.40.130.171</code>,就可以看到<code>nginx</code>提供的默认页面了。这时候使用的是主机的网络设置，并没有映射<code>80端口</code>。</p>\n<p>再重新打开一个终端，利用<code>ip addr</code>查看网络情况。这时候是没有桥接网络的，进一步证明了我们使用的是host模式。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">[root@VM-0-12-centos ~]# ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1&#x2F;8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1&#x2F;128 scope host \n       valid_lft forever preferred_lft forever\n2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link&#x2F;ether 52:54:00:5d:20:c6 brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.12&#x2F;20 brd 172.17.15.255 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::5054:ff:fe5d:20c6&#x2F;64 scope link \n       valid_lft forever preferred_lft forever\n3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default \n    link&#x2F;ether 02:42:0b:ee:d6:93 brd ff:ff:ff:ff:ff:ff\n    inet 172.18.0.1&#x2F;16 brd 172.18.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::42:bff:feee:d693&#x2F;64 scope link \n       valid_lft forever preferred_lft forever</code></pre>\n<p>看起来使用host模式挺好，但是由于host网络模式可以让容器共享主机网络，虽然可以直接通信，但是容器的网络同样缺少隔离性。</p>\n<h4 id=\"none网络模式\"><a href=\"#none网络模式\" class=\"headerlink\" title=\"none网络模式\"></a>none网络模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>none网络模式是指禁用网络功能，只有lo接口local的简写，代表<code>127.0.0.1</code>,既localhost本地环回接口。在创建容器时通过 <code>- - net none</code>或者<code>--network none</code> 指定。</p></blockquote>\n<p>创建一个<code>busybox</code>的容器，使用<code>none</code>的网络模式</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker run -it --name bbox02 --network none busybox</code></pre>\n<p><code>bbox02</code>容器启动完成后，使用<code>ip addr</code>可以看到只有一个<code>lo</code>的网络。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F; # ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000\n    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1&#x2F;8 scope host lo\n    valid_lft forever preferred_lft forever</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/05e1230635274e5cb9a1155500dccb2f.png\" alt=\"请添加图片描述\"></p>\n<p>这里的<code>lo</code>就是<code>local</code>,代表着只有本地地址，没有其他操作了。也就是没有网络状态，需要自己进行配置。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>none网络模式即不为Docker Container创建任何的网络环境，容器内部只能使用loopback网络设备，不会再有其他的网络资源。可以说none模式为Docker Container做了极少的网络设定，但是俗话说的好“少即是多”。在没有网络配置的情况下，作为Docker 开发者，才能在这基础做其他无限多的可能的网络定制开发。这也体现了Docker设计理念的开发。</p>\n<h4 id=\"container网络模式\"><a href=\"#container网络模式\" class=\"headerlink\" title=\"container网络模式\"></a>container网络模式</h4><p>Container 网络模式是Docker中一种较为特别的网络模式。在创建时通过参数<code>- - net container : 已运行的网络名称 | ID</code> 或者<code>- - network container : 已运行的容器名称 | ID</code> 指定。</p></blockquote>\n<p>处于这个模式下的Docker容器会共享一个网络栈，这样两个容器之间可以使用localhost高效通信。Container网络模式即新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。</p>\n<p>为了更好的理解<code>container网络模式</code>，我们创建2个<code>busybox</code>的容器。第一个使用默认的桥接模式<code>bridge</code>，第二个使用<code>container</code>模式。</p>\n<p>先来开启第一个容器，使用<code>- -name</code>给容器命名为<code>bbox01</code>。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker run  - it --name bbox01  busybox</code></pre>\n<p>第一个容器开启后，就会有一对 <code>对等虚拟网络</code>，也就是我们之前学到的桥接模式网络。可以新开一个窗口输入<code>ip addr</code>命令，查看这个虚拟网络。</p>\n<p>第一个开启后，再用<code>- - network container:bbox01</code>开启第二个容器。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker run -it --name bbox02 --network container:bbox01 busybox</code></pre>\n<p>容器创建好以后，在容器的交互模式下，使用<code>ip addr</code>查看，你会发现和<code>bbox01</code>容器中的网络是一样的。以此证明了<code>bbox02</code>使用了<code>bbox01</code>的网络。</p>\n<p>这时候使用<code>ping</code> 命令，查看一下百度的地址，是完全可以<code>ping</code>通的。</p>\n<p><a href=\"https://jspang.com/article/75#toc3119\">主容器退出后，附容器无法联网</a></p>\n<p>如果主容器退出以后，那么<code>附容器</code>将没办法联网,这里的<code>附</code>的意思是依附于主容器。现在我们回到第一个<code>shell窗口</code>，然后使用<code>exit</code>退出<code>bbox01</code>容器。再回到第二个<code>shell窗口</code>，重新<code>ping www.baidu.com</code>，是没办法ping通的。</p>\n<p>说明主容器退出后，附容器将没办法再继续使用。</p>\n<p>再回到第一个<code>shell窗口</code>，启动<code>bbox01</code>容器。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container start bbox01</code></pre>\n<p>然后再回到第二个<code>shell窗口</code>，网络依然不可以使用，这时候你要重新启动容器后，才能再次进行使用。</p>\n<p>先用<code>exit</code>命令退出容器，然后使用下面的命令重启。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker container start bbox02</code></pre>\n<p>然后使用<code>exec</code>命令进入交互模式。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">docker exec -it bbox02 sh</code></pre>\n<p>这时候在ping我的博客<code>jspang.com</code>就可以ping通了。</p>\n<h2 id=\"Docker-上搭建Hadoop学习环境\"><a href=\"#Docker-上搭建Hadoop学习环境\" class=\"headerlink\" title=\"Docker 上搭建Hadoop学习环境\"></a>Docker 上搭建Hadoop学习环境</h2><p>使用以下命令为Hadoop集群创建单独的网络:<br><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">sudo docker network create --driver&#x3D;bridge hadoop</code></pre><br><img src=\"https://img-blog.csdnimg.cn/bed45fcb06f947edb79540e88b4c39a2.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"3节点Hadoop集群搭建步骤\"><a href=\"#3节点Hadoop集群搭建步骤\" class=\"headerlink\" title=\"3节点Hadoop集群搭建步骤\"></a>3节点Hadoop集群搭建步骤</h3><h4 id=\"下载Docker镜像\"><a href=\"#下载Docker镜像\" class=\"headerlink\" title=\"下载Docker镜像\"></a>下载Docker镜像</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">sudo docker pull kiwenlau&#x2F;hadoop:1.0\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/40cca93b68e74bd086c56e1b5e14b42c.png\" alt=\"请添加图片描述\"></p>\n<h4 id=\"下载GitHub仓库\"><a href=\"#下载GitHub仓库\" class=\"headerlink\" title=\"下载GitHub仓库\"></a>下载GitHub仓库</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">git clone https:&#x2F;&#x2F;github.com&#x2F;kiwenlau&#x2F;hadoop-cluster-docker</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/3ad2d8881a5f4da6b12d084aff705544.png\" alt=\"请添加图片描述\"></p>\n<h4 id=\"创建Hadoop网络\"><a href=\"#创建Hadoop网络\" class=\"headerlink\" title=\"创建Hadoop网络\"></a>创建Hadoop网络</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">sudo docker network create --driver&#x3D;bridge hadoop\n</code></pre>\n<h4 id=\"运行Docker容器\"><a href=\"#运行Docker容器\" class=\"headerlink\" title=\"运行Docker容器\"></a>运行Docker容器</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">cd hadoop-cluster-docker\n.&#x2F;start-container.sh</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/8de657248ec642f3818f91b9d62c7008.png\" alt=\"请添加图片描述\"></p>\n<h4 id=\"启动hadoop\"><a href=\"#启动hadoop\" class=\"headerlink\" title=\"启动hadoop\"></a>启动hadoop</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">.&#x2F;start-hadoop.sh\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/d8431cd337e140f2befe14f8c364574d.png\" alt=\"请添加图片描述\"></p>\n<h4 id=\"运行wordcount\"><a href=\"#运行wordcount\" class=\"headerlink\" title=\"运行wordcount\"></a>运行wordcount</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">.&#x2F;run-wordcount.sh\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/c0ba1ad0b9f043c4993aa14c90d97718.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"N节点Hadoop集群搭建步骤\"><a href=\"#N节点Hadoop集群搭建步骤\" class=\"headerlink\" title=\"N节点Hadoop集群搭建步骤\"></a>N节点Hadoop集群搭建步骤</h3><h4 id=\"重新构建Docker镜像\"><a href=\"#重新构建Docker镜像\" class=\"headerlink\" title=\"重新构建Docker镜像\"></a>重新构建Docker镜像</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">.&#x2F;resize-cluster.sh 4\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/0f507e6d07e941baa42a07798921fb7b.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/7cb85ec16ce64abfa7626494f1be979a.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/1d83e6de893544ccaeb0cdb07f1d5301.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/7f4d38555d1e458eb07f0a53574c024c.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/4b7ba77b8f644acca976566c0b6f6fcf.png\" alt=\"请添加图片描述\"></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">.&#x2F;start-container.sh 4</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/4faef707a27545a29a4e027c2a5918ba.png\" alt=\"请添加图片描述\"></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">.&#x2F;start-hadoop.sh</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/c087463bb027495eae07835275f0cc4c.png\" alt=\"请添加图片描述\"></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">.&#x2F;run-wordcount.sh\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/1d447778ed824870858dd1bb3bdfe8a6.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/4bad385ee55c431eb2ee3a029d68d5c2.png\" alt=\"请添加图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/13eab131cba949769bc02a2d3682c7fc.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/ecbffe5b72884816b0836b27549f7e1a.png\" alt=\"请添加图片描述\"></p>\n","text":"技术胖开启docker使用systemctl start命令，开启Docker服务端。 sudo systemctl start docker 创建容器后，如果查看这个容器的信息和状态那？这时候你可以使用下面的命令。 docker container ls 这时候我们需要学一个新...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"信管","slug":"信管","count":19,"path":"api/categories/信管.json"}],"tags":[{"name":"区块链","slug":"区块链","count":10,"path":"api/tags/区块链.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%80%E6%9C%AF%E8%83%96\"><span class=\"toc-text\">技术胖</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%90%AFdocker\"><span class=\"toc-text\">开启docker</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#attached-%E5%92%8Cdetached%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">attached 和detached模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">docker交互模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Image%E9%95%9C%E5%83%8F%E7%9A%84%E6%8B%89%E5%8F%96%E5%92%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">Image镜像的拉取和删除</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E8%AF%86Dockerfile\"><span class=\"toc-text\">初识Dockerfile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%8A%E9%95%9C%E5%83%8F%E5%88%86%E4%BA%AB%E5%88%B0Dockerhub\"><span class=\"toc-text\">把镜像分享到Dockerhub</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Dockerfile%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Dockerfile命令操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">数据持久化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#volume\"><span class=\"toc-text\">volume</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Bind-Mount\"><span class=\"toc-text\">Bind Mount</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-compose\"><span class=\"toc-text\">docker-compose</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#docker-compose-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">[docker-compose ]介绍和安装</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#docker-compose-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">[docker-compose]文件的结构和版本</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#docker-compose-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%92%8C%E6%8B%89%E5%8F%96\"><span class=\"toc-text\">[docker-compose]镜像构建和拉取</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">[网络]Docker的网络模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#bridge%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">bridge网络模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#host%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">host网络模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#none%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">none网络模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#container%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">container网络模式</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Docker-%E4%B8%8A%E6%90%AD%E5%BB%BAHadoop%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">Docker 上搭建Hadoop学习环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E8%8A%82%E7%82%B9Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">3节点Hadoop集群搭建步骤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E8%BD%BDDocker%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">下载Docker镜像</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E8%BD%BDGitHub%E4%BB%93%E5%BA%93\"><span class=\"toc-text\">下载GitHub仓库</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BAHadoop%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">创建Hadoop网络</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8CDocker%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">运行Docker容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%AF%E5%8A%A8hadoop\"><span class=\"toc-text\">启动hadoop</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8Cwordcount\"><span class=\"toc-text\">运行wordcount</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#N%E8%8A%82%E7%82%B9Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">N节点Hadoop集群搭建步骤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">重新构建Docker镜像</span></a></li></ol></li></ol></li></ol>","author":{"name":"Algernon","slug":"blog-author","avatar":"https://user-images.githubusercontent.com/54904760/224857900-b2e8457c-43d2-46b7-901c-6c770f24bbad.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}},"mapped":true,"prev_post":{"title":"【区块链技术与应用】（二）","uid":"547202daa128845562f8d5d219a57a73","slug":"区块链2","date":"2022-11-03T14:59:49.000Z","updated":"2022-11-03T14:59:24.481Z","comments":true,"path":"api/articles/区块链2.json","keywords":null,"cover":[],"text":"本地编译组件获取代码编译 Fabric 代码依赖一些开发库，可以通过如下命令安装： sudo apt-get update \\ &amp;&amp; sudo apt-get install -y libsnappy-dev zlib1g-dev libbz2-dev libya...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[],"tags":[{"name":"区块链","slug":"区块链","count":10,"path":"api/tags/区块链.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://user-images.githubusercontent.com/54904760/224857900-b2e8457c-43d2-46b7-901c-6c770f24bbad.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}},"next_post":{"title":"【GO语言编程】（四）","uid":"5f49d908c20f45931c28cee8b97efd48","slug":"GO4","date":"2022-11-03T14:57:49.000Z","updated":"2022-11-08T15:50:55.385Z","comments":true,"path":"api/articles/GO4.json","keywords":null,"cover":[],"text":"http编程 package main import ( &quot;fmt&quot; &quot;net&#x2F;http&quot; ) func main() &#123; &#x2F;&#x2F;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F...","link":"","photos":[],"count_time":{"symbolsCount":"57k","symbolsTime":"51 mins."},"categories":[{"name":"编程语言","slug":"编程语言","count":13,"path":"api/categories/编程语言.json"}],"tags":[{"name":"GO","slug":"GO","count":4,"path":"api/tags/GO.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://user-images.githubusercontent.com/54904760/224857900-b2e8457c-43d2-46b7-901c-6c770f24bbad.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}}}