{"title":"【区块链技术与应用】（二）","uid":"547202daa128845562f8d5d219a57a73","slug":"区块链2","date":"2022-11-03T14:59:49.000Z","updated":"2022-11-03T14:59:24.481Z","comments":true,"path":"api/articles/区块链2.json","keywords":null,"cover":[],"content":"<h2 id=\"本地编译组件\"><a href=\"#本地编译组件\" class=\"headerlink\" title=\"本地编译组件\"></a>本地编译组件</h2><h3 id=\"获取代码\"><a href=\"#获取代码\" class=\"headerlink\" title=\"获取代码\"></a>获取代码</h3><p>编译 Fabric 代码依赖一些开发库，可以通过如下命令安装：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">sudo apt-get update \\\n   &amp;&amp; sudo apt-get install -y libsnappy-dev zlib1g-dev libbz2-dev libyaml-dev libltdl-dev libtool</code></pre>\n<p>目前，Fabric 官方仓库托管在 Github 仓库（github.com/hyperledger/fabric）中供下载使用。<br>如果使用 1.13 之前版本的 Go 环境，需要将 Fabric 项目放到 $GOPATH 路径下。如下命令所示，创建 $GOPATH/src/github.com/hyperledger 目录结构并切换到该路径：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">mkdir -p $GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger\ncd $GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger</code></pre>\n<p>获取 Peer 和 Orderer 组件编译所需要的代码，两者目前在同一个 fabric 仓库中：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">git clone https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric.git</code></pre>\n<p>为节约下载时间，读者可以指定 —single-branch -b master —depth 1 命令选项来指定只获取 master 分支最新代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">git clone --single-branch -b master --depth 1 https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric.git</code></pre>\n<p>Fabric CA 组件在独立的 fabric-ca 仓库中，可以通过如下命令获取：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">git clone https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-ca.git</code></pre>\n<p>读者也可以直接访问 <a href=\"https://github.com/hyperledger/fabric/releases\">https://github.com/hyperledger/fabric/releases</a> 和 <a href=\"https://github.com/hyperledger/fabric-ca/releases\">https://github.com/hyperledger/fabric-ca/releases</a> 来下载特定的 fabric 和 fabric-ca 发行版。<br>最后，检查确认 fabric 和 fabric-ca 两个仓库下载成功：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">ls $GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger\nfabric fabric-ca</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/0415ac79f4084d239571d2d9d5ae3adf.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"编译安装peer组件\"><a href=\"#编译安装peer组件\" class=\"headerlink\" title=\"编译安装peer组件\"></a>编译安装peer组件</h3><p>配置版本号和编译参数：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ PROJECT_VERSION&#x3D;2.0.0\n$ LD_FLAGS&#x3D;&quot;-X github.com&#x2F;hyperledger&#x2F;fabric&#x2F;common&#x2F;metadata.Version&#x3D;$&#123;PROJECT_VERSION&#125; \\\n             -X github.com&#x2F;hyperledger&#x2F;fabric&#x2F;common&#x2F;metadata.BaseDockerLabel&#x3D;org.hyperledger.fabric \\\n             -X github.com&#x2F;hyperledger&#x2F;fabric&#x2F;common&#x2F;metadata.DockerNamespace&#x3D;hyperledger \\\n             -X github.com&#x2F;hyperledger&#x2F;fabric&#x2F;common&#x2F;metadata.BaseDockerNamespace&#x3D;hyperledger&quot;</code></pre>\n<p>通过如下命令编译并安装 fabric 的 peer 组件到 $GOPATH/bin 下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">$ CGO_CFLAGS&#x3D;&quot; &quot; go install -tags &quot;&quot; -ldflags &quot;$LD_FLAGS&quot; \\\n    github.com&#x2F;hyperledger&#x2F;fabric&#x2F;cmd&#x2F;peer</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/71913ce95ac247efbd3875c699998015.png\" alt=\"请添加图片描述\"></p>\n<p>当然，用户也可直接使用源码中的 Makefile 来进行编译，相关命令如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ make peer</code></pre>\n<p>这种情况下编译生成的 peer 组件会默认放在 build/bin 路径下。</p>\n<h3 id=\"编译安装-Orderer-组件\"><a href=\"#编译安装-Orderer-组件\" class=\"headerlink\" title=\"编译安装 Orderer 组件\"></a>编译安装 Orderer 组件</h3><p>通过如下命令编译并安装 fabric orderer 组件到 $GOPATH/bin 下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ CGO_CFLAGS&#x3D;&quot; &quot; go install -tags &quot;&quot; -ldflags &quot;$LD_FLAGS&quot; \\\n    github.com&#x2F;hyperledger&#x2F;fabric&#x2F;cmd&#x2F;orderer</code></pre>\n<p>同样的，也可使用 Makefile 来编译安装 orderer 组件到 build/bin 路径下：<br><img src=\"https://img-blog.csdnimg.cn/5ab3a5a82fd64fe7bc8d828ef20df52d.png\" alt=\"请添加图片描述\"></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ make orderer</code></pre>\n<h3 id=\"编译安装-Fabric-CA-组件\"><a href=\"#编译安装-Fabric-CA-组件\" class=\"headerlink\" title=\"编译安装 Fabric CA 组件\"></a>编译安装 Fabric CA 组件</h3><p>采用如下命令编译并安装 fabric-ca 相关组件到 $GOPATH/bin 下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ go install -ldflags &quot;-X github.com&#x2F;hyperledger&#x2F;fabric-ca&#x2F;lib&#x2F;metadata.Version&#x3D;$PROJECT_VERSION -linkmode external -extldflags &#39;-static -lpthread&#39;&quot; \\\n    github.com&#x2F;hyperledger&#x2F;fabric-ca&#x2F;cmd&#x2F;...</code></pre>\n<h3 id=\"编译安装配置辅助工具\"><a href=\"#编译安装配置辅助工具\" class=\"headerlink\" title=\"编译安装配置辅助工具\"></a>编译安装配置辅助工具</h3><p>Fabric 中还提供了一系列配置辅助工具，包括 cryptogen（本地生成组织结构和身份文件）、configtxgen（生成配置区块和配置交易）、configtxlator（解析转换配置信息）、discover（拓扑探测）、idemixgen（Idemix 证书生成）等，可以通过如下命令来快速编译和安装：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"># 编译安装 cryptogen，等价于执行 make cryptogen\n$ CGO_CFLAGS&#x3D;&quot; &quot; \\\n    go install -tags &quot;&quot; -ldflags &quot;$LD_FLAGS&quot; \\\n    github.com&#x2F;hyperledger&#x2F;fabric&#x2F;cmd&#x2F;cryptogen\n\n# 编译安装 configtxgen，等价于执行 make configtxgen\n$ CGO_CFLAGS&#x3D;&quot; &quot; \\\n    go install -tags &quot;&quot; -ldflags &quot;$LD_FLAGS&quot; \\\n    github.com&#x2F;hyperledger&#x2F;fabric&#x2F;cmd&#x2F;configtxgen\n\n# 编译安装 configtxlator，等价于执行 make configtxlator\n$ CGO_CFLAGS&#x3D;&quot; &quot; \\\n    go install -tags &quot;&quot; -ldflags &quot;$LD_FLAGS&quot; \\\n    github.com&#x2F;hyperledger&#x2F;fabric&#x2F;cmd&#x2F;configtxlator\n\n# 编译安装 discover，等价于执行 make discover\n$ CGO_CFLAGS&#x3D;&quot; &quot; \\\n    go install -tags &quot;&quot; -ldflags &quot;$LD_FLAGS&quot; \\\n    github.com&#x2F;hyperledger&#x2F;fabric&#x2F;cmd&#x2F;discover\n\n# 编译安装 idemixgen，等价于执行 make idemixgen\n$ CGO_CFLAGS&#x3D;&quot; &quot; \\\n    go install -tags &quot;&quot; -ldflags &quot;$LD_FLAGS&quot; \\\n    github.com&#x2F;hyperledger&#x2F;fabric&#x2F;cmd&#x2F;idemixgen</code></pre>\n<p>另外，fabric 项目还提供了不少常见的编译命令，可以参考 Makefile 文件，例如编译所有的二进制文件可以使用如下命令：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ make native</code></pre>\n<h3 id=\"安装-Protobuf-支持和-Go-语言相关工具\"><a href=\"#安装-Protobuf-支持和-Go-语言相关工具\" class=\"headerlink\" title=\"安装 Protobuf 支持和 Go 语言相关工具\"></a>安装 Protobuf 支持和 Go 语言相关工具</h3><p>Fabric 代码由 Go 语言构建，开发者可以选择安装如下的 Go 语言相关工具，方便开发和调试：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ go get github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go \\\n    &amp;&amp; go get github.com&#x2F;maxbrunsfeld&#x2F;counterfeiter&#x2F;v6 \\\n    &amp;&amp; go get github.com&#x2F;axw&#x2F;gocov&#x2F;... \\\n    &amp;&amp; go get github.com&#x2F;AlekSi&#x2F;gocov-xml \\\n    &amp;&amp; go get golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;goimports \\\n    &amp;&amp; go get golang.org&#x2F;x&#x2F;lint&#x2F;golint \\\n    &amp;&amp; go get github.com&#x2F;estesp&#x2F;manifest-tool \\\n    &amp;&amp; go get github.com&#x2F;client9&#x2F;misspell&#x2F;cmd&#x2F;misspell \\\n    &amp;&amp; go get github.com&#x2F;onsi&#x2F;ginkgo&#x2F;ginkgo</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/af4d51b553f84509b757ce86209def10.png\" alt=\"请添加图片描述\"></p>\n<h2 id=\"容器方式获取\"><a href=\"#容器方式获取\" class=\"headerlink\" title=\"容器方式获取\"></a>容器方式获取</h2><p>除了从源码编译外，还可以直接从 Dockerhub 来拉取相关的镜像，命令格式为 docker pull <IMAGE_NAME:TAG>。<br>例如，从社区仓库直接获取 fabric-peer、fabric-orderer、fabric-ca、fabric-tools 等镜像的 2.0.0 版本可以使用如下命令：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ ARCH&#x3D;amd64\n$ BASEIMAGE_RELEASE&#x3D;0.4.18\n$ PROJECT_VERSION&#x3D;2.0.0\n\n# 拉取镜像\n$ docker pull hyperledger&#x2F;fabric-peer:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker pull hyperledger&#x2F;fabric-orderer:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker pull hyperledger&#x2F;fabric-ca:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker pull hyperledger&#x2F;fabric-tools:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker pull hyperledger&#x2F;fabric-ccenv:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker pull hyperledger&#x2F;fabric-baseimage:$ARCH-$BASEIMAGE_RELEASE \\\n  &amp;&amp; docker pull hyperledger&#x2F;fabric-baseos:$ARCH-$PROJECT_VERSION</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/a6096b0a4f5b49c8a969edacfd371939.png\" alt=\"请添加图片描述\"></p>\n<p>此外，还可以从第三方仓库获取镜像，拉取后可以添加默认的镜像标签别名。<br>例如，笔者仓库中构建了基于 Golang 基础镜像的相关 fabric 镜像，可以通过如下命令获取：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"># 拉取镜像\n$ docker pull yeasy&#x2F;hyperledger-fabric-base:$PROJECT_VERSION \\\n  &amp;&amp; docker pull yeasy&#x2F;hyperledger-fabric-peer:$PROJECT_VERSION \\\n  &amp;&amp; docker pull yeasy&#x2F;hyperledger-fabric-orderer:$PROJECT_VERSION \\\n  &amp;&amp; docker pull yeasy&#x2F;hyperledger-fabric-ca:$PROJECT_VERSION\n\n\n# 添加标签\n$ docker tag yeasy&#x2F;hyperledger-fabric-peer:$PROJECT_VERSION hyperledger&#x2F;fabric-peer:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker tag yeasy&#x2F;hyperledger-fabric-orderer:$PROJECT_VERSION hyperledger&#x2F;fabric-orderer:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker tag yeasy&#x2F;hyperledger-fabric-ca:$PROJECT_VERSION hyperledger&#x2F;fabric-ca:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker tag yeasy&#x2F;hyperledger-fabric-peer:$PROJECT_VERSION hyperledger&#x2F;fabric-tools:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker tag yeasy&#x2F;hyperledger-fabric-base:$PROJECT_VERSION hyperledger&#x2F;fabric-ccenv:$ARCH-$PROJECT_VERSION \\\n  &amp;&amp; docker tag yeasy&#x2F;hyperledger-fabric-base:$PROJECT_VERSION hyperledger&#x2F;fabric-baseimage:$ARCH-$BASEIMAGE_RELEASE \\\n  &amp;&amp; docker tag yeasy&#x2F;hyperledger-fabric-base:$PROJECT_VERSION hyperledger&#x2F;fabric-baseos:$ARCH-$PROJECT_VERSION</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/750f9d24e6794165a34f06c814917f4a.png\" alt=\"请添加图片描述\"></p>\n<h2 id=\"本地方式启动-Fabric-网络\"><a href=\"#本地方式启动-Fabric-网络\" class=\"headerlink\" title=\"本地方式启动 Fabric 网络\"></a>本地方式启动 Fabric 网络</h2><h3 id=\"生成组织关系和身份证书\"><a href=\"#生成组织关系和身份证书\" class=\"headerlink\" title=\"生成组织关系和身份证书\"></a>生成组织关系和身份证书</h3><p>Fabric 网络作为联盟链，需要多个成员组织共同维护。成员之间通过身份来进行鉴权，网络通过身份来实现资源访问的权限管理。因此各成员组织都需要提前准备对应的身份文件，并部署到其所拥有的节点和客户端上。<br>用户可通过标准 PKI 服务（如使用 Fabric CA 实现）或 OpenSSL 工具来手动生成各个实体的证书和私钥。Fabric 项目还提供了 cryptogen 工具（基于 Golang crypto 标准库）在本地生成，需要提前准备 crypto-config.yaml 配置文件。<br>crypto-config.yaml 配置文件的结构十分简单，支持定义两种类型（OrdererOrgs 和 PeerOrgs）的若干组织。每个组织中又可以定义多个节点（Spec）和用户（User）。<br>一个示例的 crypto-config.yaml 配置文件内容如下，其中定义了一个 OrdererOrgs 类型的组织 example.com，包括 3 个节点；两个 PeerOrgs 类型的组织 org1.example.com 和 org2.example.com，分别包括 2 个节点和 1 个普通用户身份：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">OrdererOrgs:\n  - Name: Orderer\n    Domain: example.com\n    CA:\n        Country: US\n        Province: California\n        Locality: San Francisco\n    Specs:\n      - Hostname: orderer0\n      - Hostname: orderer1\n      - Hostname: orderer2\nPeerOrgs:\n  - Name: Org1\n    Domain: org1.example.com\n    EnableNodeOUs: true\n    CA:\n        Country: US\n        Province: California\n        Locality: San Francisco\n    Template:\n      Count: 2\n    Users:\n      Count: 1\n  - Name: Org2\n    Domain: org2.example.com\n    EnableNodeOUs: true\n    CA:\n        Country: US\n        Province: California\n        Locality: San Francisco\n    Template:\n      Count: 2\n    Users:\n      Count: 1</code></pre>\n<p>使用该配置文件，通过如下命令可生成指定组织结构的身份文件，并存放到 crypto-config 目录下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ cryptogen generate \\\n    --config&#x3D;.&#x2F;crypto-config.yaml \\\n    --output .&#x2F;crypto-config</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/b30c52642ea24f178c7e48d05c7f0ab7.png\" alt=\"请添加图片描述\"></p>\n<p>用户修改配置后，还可以通过 extend 子命令来更新 crypto-config 目录：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ cryptogen extend \\\n    --config&#x3D;.&#x2F;crypto-config.yaml \\\n    --input .&#x2F;crypto-config</code></pre>\n<p>查看刚生成的 crypto-config 目录，结构如下所示：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ tree -L 4 crypto-config\ncrypto-config\n|-- ordererOrganizations\n|   &#96;-- example.com\n|       |-- ca\n|       |   |-- 293def0fc6d07aab625308a3499cd97f8ffccbf9e9769bf4107d6781f5e8072b_sk\n|       |   &#96;-- ca.example.com-cert.pem\n|       |-- msp\n|       |   |-- admincerts&#x2F;\n|       |   |-- cacerts&#x2F;\n|       |   &#96;-- tlscacerts&#x2F;\n|       |-- orderers\n|       |   &#96;-- orderer0.example.com&#x2F;\n|       |   &#96;-- orderer1.example.com&#x2F;\n|       |   &#96;-- orderer2.example.com&#x2F;\n|       |-- tlsca\n|       |   |-- 2be5353baec06ca695f7c3b04ca0932912601a4411939bfcfd44af18274d5a65_sk\n|       |   &#96;-- tlsca.example.com-cert.pem\n|       &#96;-- users\n|           &#96;-- Admin@example.com&#x2F;\n&#96;-- peerOrganizations\n    |-- org1.example.com\n    |   |-- ca\n    |   |   |-- 501c5f828f58dfa3f7ee844ea4cdd26318256c9b66369727afe8437c08370aee_sk\n    |   |   &#96;-- ca.org1.example.com-cert.pem\n    |   |-- msp\n    |   |   |-- admincerts&#x2F;\n    |   |   |-- cacerts&#x2F;\n    |   |   &#96;-- tlscacerts&#x2F;\n    |   |-- peers\n    |   |   |-- peer0.org1.example.com&#x2F;\n    |   |   &#96;-- peer1.org1.example.com&#x2F;\n    |   |-- tlsca\n    |   |   |-- 592a08f84c99d6f083b3c5b9898b2ca4eb5fbb9d1e255f67df1fa14c123e4368_sk\n    |   |   &#96;-- tlsca.org1.example.com-cert.pem\n    |   &#96;-- users\n    |       |-- Admin@org1.example.com&#x2F;\n    |       &#96;-- User1@org1.example.com&#x2F;\n    &#96;-- org2.example.com\n        |-- ca\n        |   |-- 86d97f9eb601868611eab5dc7df88b1f6e91e129160651e683162b958a728162_sk\n        |   &#96;-- ca.org2.example.com-cert.pem\n        |-- msp\n        |   |-- admincerts&#x2F;\n        |   |-- cacerts&#x2F;\n        |   &#96;-- tlscacerts&#x2F;\n        |-- peers\n        |   |-- peer0.org2.example.com&#x2F;\n        |   &#96;-- peer1.org2.example.com&#x2F;\n        |-- tlsca\n        |   |-- 4b87c416978970948dffadd0639a64a2b03bc89f910cb6d087583f210fb2929d_sk\n        |   &#96;-- tlsca.org2.example.com-cert.pem\n        &#96;-- users\n            |-- Admin@org2.example.com&#x2F;\n            &#96;-- User1@org2.example.com&#x2F;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/d410bedb28d041ad91ab875c00626bff.png\" alt=\"请添加图片描述\"></p>\n<p>按照 crypto-config.yaml 中定义，crypto-config 目录下包括多级目录结构。其中 ordererOrganizations 下包括构成 Orderer 组织（包括 3 个 Orderer 节点）的身份信息；peerOrganizations 下为所有的 Peer 节点组织（包括2 个组织，4 个节点）的相关身份信息。各个实体都含有 msp 和 tls 目录，分别包括对应的认证身份文件和 TLS 身份文件（公钥证书、私钥等）。<br>对于 Orderer 节点来说，需要将 ordererOrganizations/example.com/orderers/ordererX.example.com 目录下内容（包括 msp 和 tls 两个子目录）复制到对应 Orderer 节点的配置路径（默认为 /etc/hyperledger/fabric）下。<br>对于 Peer 节点来说，则需要复制 peerOrganizations 下对应的身份证书文件。以 org1 的 peer0 为例，将 peerOrganizations/org1.example.com/peers/peer0.org1.example.com 目录下内容（包括 msp 和 tls）复制到 Peer0 节点的配置路径（默认为 /etc/hyperledger/fabric）下。<br>对于客户端节点来说，需要复制对应身份的用户目录，例如 Org1 的管理员身份为 peerOrganizations/org1.example.com/users/Admin@org1.example.com/。</p>\n<h3 id=\"生成系统通道初始区块\"><a href=\"#生成系统通道初始区块\" class=\"headerlink\" title=\"生成系统通道初始区块\"></a>生成系统通道初始区块</h3><p>系统通道是网络启动后的首个通道，负责管理网络整体配置。排序节点在启动后，可以使用初始区块文件来创建一个新的网络。<br>初始区块中包括了排序服务的相关配置信息（如排序节点信息、块大小、最大通道数、默认策略等）和示例联盟配置。可以使用 configtxgen 工具生成。生成过程依赖 configtx.yaml 文件。<br>configtx.yaml 配置文件定义了整个网络中的相关配置和拓扑结构信息，用户可参考 sampleconfig/configtx.yaml 示例文件进行编写。这里采用如下内容，各个字段含义可参考后续配置说明章节：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">Profiles:\n    TwoOrgsOrdererGenesis:\n        &lt;&lt;: *ChannelDefaults\n        Capabilities:\n            &lt;&lt;: *ChannelCapabilities\n        Orderer:\n            &lt;&lt;: *OrdererDefaults\n            Organizations:\n                - *OrdererOrg\n            Capabilities:\n                &lt;&lt;: *OrdererCapabilities\n        Consortiums:\n            SampleConsortium:\n                Organizations:\n                    - *Org1\n                    - *Org2\n    TwoOrgsChannel:\n        Consortium: SampleConsortium\n        &lt;&lt;: *ChannelDefaults\n        Capabilities:\n            &lt;&lt;: *ChannelCapabilities\n        Application:\n            &lt;&lt;: *ApplicationDefaults\n            Organizations:\n                - *Org1\n                - *Org2\n            Capabilities:\n                &lt;&lt;: *ApplicationCapabilities\nOrganizations:\n    - &amp;OrdererOrg\n        Name: OrdererOrg\n        SkipAsForeign: false\n        ID: OrdererMSP\n        MSPDir: msp\n        Policies:\n            Readers:\n                Type: Signature\n                Rule: &quot;OR(&#39;OrdererMSP.member&#39;)&quot;\n            Writers:\n                Type: Signature\n                Rule: &quot;OR(&#39;OrdererMSP.member&#39;)&quot;\n            Admins:\n                Type: Signature\n                Rule: &quot;OR(&#39;OrdererMSP.admin&#39;)&quot;\n        OrdererEndpoints:\n            - &quot;orderer0.example.com:7050&quot;\n            - &quot;orderer1.example.com:7050&quot;\n            - &quot;orderer2.example.com:7050&quot;\n\n    - &amp;Org1\n        Name: Org1MSP\n        SkipAsForeign: false\n        ID: Org1MSP\n        MSPDir: msp\n        Policies:\n            Readers:\n                Type: Signature\n                Rule: &quot;OR(&#39;Org1MSP.admin&#39;, &#39;Org1MSP.peer&#39;, &#39;Org1MSP.client&#39;)&quot;\n            Writers:\n                Type: Signature\n                Rule: &quot;OR(&#39;Org1MSP.admin&#39;, &#39;Org1MSP.client&#39;)&quot;\n            Admins:\n                Type: Signature\n                Rule: &quot;OR(&#39;Org1MSP.admin&#39;)&quot;\n            Endorsement:\n                Type: Signature\n                Rule: &quot;OR(&#39;Org1MSP.member&#39;)&quot;\n        AnchorPeers:\n            - Host: peer0.org1.example.com\n              Port: 7051\n    - &amp;Org2\n        Name: Org2MSP\n        SkipAsForeign: false\n        ID: Org2MSP\n        MSPDir: msp\n        Policies:\n            Readers:\n                Type: Signature\n                Rule: &quot;OR(&#39;Org2MSP.admin&#39;, &#39;Org2MSP.peer&#39;, &#39;Org2MSP.client&#39;)&quot;\n            Writers:\n                Type: Signature\n                Rule: &quot;OR(&#39;Org2MSP.admin&#39;, &#39;Org2MSP.client&#39;)&quot;\n            Admins:\n                Type: Signature\n                Rule: &quot;OR(&#39;Org2MSP.admin&#39;)&quot;\n            Endorsement:\n                Type: Signature\n                Rule: &quot;OR(&#39;Org2MSP.member&#39;)&quot;\n        AnchorPeers:\n            - Host: peer0.org2.example.com\n              Port: 7051\nCapabilities:\n    Channel: &amp;ChannelCapabilities\n        V2_0: true\n    Orderer: &amp;OrdererCapabilities\n        V2_0: true\n    Application: &amp;ApplicationCapabilities\n        V2_0: true\nApplication: &amp;ApplicationDefaults\n    ACLs: &amp;ACLsDefault\n        _lifecycle&#x2F;CommitChaincodeDefinition: &#x2F;Channel&#x2F;Application&#x2F;Writers\n        _lifecycle&#x2F;QueryChaincodeDefinition: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        _lifecycle&#x2F;QueryNamespaceDefinitions: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        lscc&#x2F;ChaincodeExists: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        lscc&#x2F;GetDeploymentSpec: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        lscc&#x2F;GetChaincodeData: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        lscc&#x2F;GetInstantiatedChaincodes: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        qscc&#x2F;GetChainInfo: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        qscc&#x2F;GetBlockByNumber: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        qscc&#x2F;GetBlockByHash: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        qscc&#x2F;GetTransactionByID: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        qscc&#x2F;GetBlockByTxID: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        cscc&#x2F;GetConfigBlock: &#x2F;Channel&#x2F;Application&#x2F;Readers        \n        peer&#x2F;Propose: &#x2F;Channel&#x2F;Application&#x2F;Writers\n        peer&#x2F;ChaincodeToChaincode: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        event&#x2F;Block: &#x2F;Channel&#x2F;Application&#x2F;Readers\n        event&#x2F;FilteredBlock: &#x2F;Channel&#x2F;Application&#x2F;Readers\n    Organizations:\n    Policies:\n        LifecycleEndorsement:\n            Type: ImplicitMeta\n            Rule: &quot;MAJORITY Endorsement&quot;\n        Endorsement:\n            Type: ImplicitMeta\n            Rule: &quot;MAJORITY Endorsement&quot;\n        Readers:\n            Type: ImplicitMeta\n            Rule: &quot;ANY Readers&quot;\n        Writers:\n            Type: ImplicitMeta\n            Rule: &quot;ANY Writers&quot;\n        Admins:\n            Type: ImplicitMeta\n            Rule: &quot;MAJORITY Admins&quot;\n    Capabilities:\n        &lt;&lt;: *ApplicationCapabilities\nOrderer: &amp;OrdererDefaults\n    OrdererType: etcdraft\n    Addresses:\n        - orderer0.example.com:7050\n        - orderer1.example.com:7050\n        - orderer2.example.com:7050\n    BatchTimeout: 2s\n    BatchSize:\n        MaxMessageCount: 500\n        AbsoluteMaxBytes: 10 MB\n        PreferredMaxBytes: 2 MB\n    MaxChannels: 0\n    EtcdRaft:\n        Consenters:\n            - Host: orderer0.example.com\n              Port: 7050\n              ClientTLSCert: crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer0.example.com&#x2F;tls&#x2F;server.crt\n              ServerTLSCert: crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer0.example.com&#x2F;tls&#x2F;server.crt\n            - Host: orderer1.example.com\n              Port: 7050\n              ClientTLSCert: crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer1.example.com&#x2F;tls&#x2F;server.crt\n              ServerTLSCert: crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer1.example.com&#x2F;tls&#x2F;server.crt\n            - Host: orderer2.example.com\n              Port: 7050\n              ClientTLSCert: crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer2.example.com&#x2F;tls&#x2F;server.crt\n              ServerTLSCert: crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer2.example.com&#x2F;tls&#x2F;server.crt\n        Options:\n            TickInterval: 500ms\n            ElectionTick: 10\n            HeartbeatTick: 1\n            MaxInflightBlocks: 5\n            SnapshotIntervalSize: 16 MB\n    Organizations:\n    Policies:\n        Readers:\n            Type: ImplicitMeta\n            Rule: &quot;ANY Readers&quot;\n        Writers:\n            Type: ImplicitMeta\n            Rule: &quot;ANY Writers&quot;\n        Admins:\n            Type: ImplicitMeta\n            Rule: &quot;MAJORITY Admins&quot;\n        BlockValidation:\n            Type: ImplicitMeta\n            Rule: &quot;ANY Writers&quot;\n    Capabilities:\n        &lt;&lt;: *OrdererCapabilities\nChannel: &amp;ChannelDefaults\n    Policies:\n        Readers:\n            Type: ImplicitMeta\n            Rule: &quot;ANY Readers&quot;\n        Writers:\n            Type: ImplicitMeta\n            Rule: &quot;ANY Writers&quot;\n        Admins:\n            Type: ImplicitMeta\n            Rule: &quot;MAJORITY Admins&quot;\n    Capabilities:\n        &lt;&lt;: *ChannelCapabilities</code></pre>\n<p>该配置文件中定义了两个模板：TwoOrgsOrdererGenesis 和 TwoOrgsChannel，其中前者定义了系统通道配置，可以用来创建系统通道所需初始区块文件；后者定义了应用通道配置，可以用来新建应用通道。排序服务的共识类型采用了 Raft 模式。<br>可通过如下命令指定使用 configtx.yaml 文件中定义的 TwoOrgsOrdererGenesis 模板，来生成系统通道的初始区块文件：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ export SYS_CHANNEL&#x3D;testchainid\n$ export ORDERER_GENESIS_PROFILE&#x3D;TwoOrgsOrdererGenesis\n$ export ORDERER_GENESIS&#x3D;orderer.genesis.block\n$ configtxgen \\\n    -configPath .&#x2F; \\\n    -channelID $&#123;SYS_CHANNEL&#125; \\\n    -profile $&#123;ORDERER_GENESIS_PROFILE&#125; \\\n    -outputBlock $&#123;ORDERER_GENESIS&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/b58f2559d56e4aa098f3fed353efac0a.png\" alt=\"请添加图片描述\"></p>\n<p>将所生成的初始区块文件复制到排序节点上 ORDERER_GENERAL_BOOTSTRAPFILE 指定路径（默认为 /etc/hyperledger/fabric）下，供启动排序节点使用。</p>\n<h3 id=\"生成新建应用通道配置交易\"><a href=\"#生成新建应用通道配置交易\" class=\"headerlink\" title=\"生成新建应用通道配置交易\"></a>生成新建应用通道配置交易</h3><p>新建应用通道需要先生成配置交易文件，其中包括了属于该通道的组织结构信息，这些信息会写入到该应用通道的初始区块中。<br>同样使用 configtx.yaml 配置文件和 configtxgen 工具，注意这里使用 TwoOrgsChannel 模板。<br>采用如下命令来生成配置交易文件，通道中包括两个初始成员：Org1 和 Org2：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ export APP_CHANNEL&#x3D;businesschannel\n$ export APP_CHANNEL_PROFILE&#x3D;TwoOrgsChannel\n$ configtxgen \\\n    -configPath .&#x2F; \\\n    -channelID $&#123;APP_CHANNEL&#125; \\\n    -profile $&#123;APP_CHANNEL_PROFILE&#125; \\\n    -outputCreateChannelTx $&#123;APP_CHANNEL&#125;.tx</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/8b78f98a608f45e8b8844bec3f5c9714.png\" alt=\"请添加图片描述\"></p>\n<p>所生成的配置交易文件在后续步骤被客户端所使用，需要复制到客户端节点上。<br>注：状态数据库如果选择 CouchDB 类型，应用通道名称只能包括小写的 ASCII 字符、点或中划线，并且首字符必须为字母，总长度不超过 249 个字符。该限制详情可参考 FAB-2487。</p>\n<h3 id=\"生成锚节点配置更新文件\"><a href=\"#生成锚节点配置更新文件\" class=\"headerlink\" title=\"生成锚节点配置更新文件\"></a>生成锚节点配置更新文件</h3><p>锚节点用来辅助通道内多个组织之间的节点发现，修改锚节点需要发送更新通道配置交易。<br>同样，基于 configtx.yaml 配置文件，为每个组织都生成配置交易文件，注意需要需要使用对应的组织身份：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ export UPDATE_ANCHOR_ORG1_TX&#x3D;Org1MSPanchors.tx \n$ export UPDATE_ANCHOR_ORG2_TX&#x3D;Org2MSPanchors.tx \n$ configtxgen \\\n    -configPath .&#x2F; \\\n    -channelID $&#123;APP_CHANNEL&#125; \\\n    -profile $&#123;APP_CHANNEL_PROFILE&#125; \\\n    -asOrg Org1MSP \\\n    -outputAnchorPeersUpdate $&#123;UPDATE_ANCHOR_ORG1_TX&#125;\n$ configtxgen \\\n    -configPath .&#x2F; \\\n    -channelID $&#123;APP_CHANNEL&#125; \\\n    -profile $&#123;APP_CHANNEL_PROFILE&#125; \\\n    -asOrg Org2MSP \\\n    -outputAnchorPeersUpdate $&#123;UPDATE_ANCHOR_ORG1_TX&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/4d8be1af677b4832a652ed3a87154965.png\" alt=\"请添加图片描述\"></p>\n<p>所生成的锚节点配置更新文件会在后续步骤被客户端所使用，因此需要复制到客户端节点上。<br>所有配置文件都准备完毕后，即可启动网络。首先要启动 Orderer 节点，然后启动 Peer 节点。<br><img src=\"https://img-blog.csdnimg.cn/3512a6d73e7f453680502f9f61284d86.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"启动-Orderer-节点\"><a href=\"#启动-Orderer-节点\" class=\"headerlink\" title=\"启动 Orderer 节点\"></a>启动 Orderer 节点</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">FABRIC_LOGGING_SPEC&#x3D;&quot;info:orderer.common.blockcutter,orderer.operations&#x3D;warning:orderer.common.cluster&#x3D;debug&quot;\nORDERER_GENERAL_LISTENADDRESS&#x3D;0.0.0.0\nORDERER_GENERAL_LISTENPORT&#x3D;7050\nORDERER_GENERAL_BOOTSTRAPMETHOD&#x3D;file\nORDERER_GENERAL_BOOTSTRAPFILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;orderer.genesis.block\nORDERER_GENERAL_LOCALMSPID&#x3D;OrdererMSP\nORDERER_GENERAL_LOCALMSPDIR&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;msp\nORDERER_GENERAL_LEDGERTYPE&#x3D;file\nORDERER_GENERAL_TLS_ENABLED&#x3D;true\nORDERER_GENERAL_TLS_PRIVATEKEY&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;tls&#x2F;server.key\nORDERER_GENERAL_TLS_CERTIFICATE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;tls&#x2F;server.crt\nORDERER_GENERAL_TLS_ROOTCAS&#x3D;[&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;tls&#x2F;ca.crt]\nORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;orderer&#x2F;tls&#x2F;server.key\nORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;orderer&#x2F;tls&#x2F;server.crt\nORDERER_GENERAL_CLUSTER_ROOTCAS&#x3D;[&#x2F;var&#x2F;hyperledger&#x2F;orderer&#x2F;tls&#x2F;ca.crt]\nCORE_OPERATIONS_LISTENADDRESS&#x3D;0.0.0.0:8443\nCORE_METRICS_PROVIDER&#x3D;prometheus</code></pre>\n<p>之后，用户可以采用如下命令来启动 Orderer 节点。启动成功后可以看到本地输出的开始提供服务的消息，此时 Orderer 采用指定的初始区块文件成功创建了系统通道：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ orderer start\n[orderer&#x2F;common&#x2F;server] prettyPrintStruct -&gt; INFO 002 Orderer config values:\n    General.LedgerType &#x3D; &quot;file&quot;\n    General.ListenAddress &#x3D; &quot;0.0.0.0&quot;\n    General.ListenPort &#x3D; 7050\n    General.TLS.Enabled &#x3D; true\n...\n[orderer&#x2F;common&#x2F;server] Start -&gt; INFO 007 Beginning to serve requests\n...</code></pre>\n<h3 id=\"启动-Peer-节点\"><a href=\"#启动-Peer-节点\" class=\"headerlink\" title=\"启动 Peer 节点\"></a>启动 Peer 节点</h3><p>首先，检查配置路径（ 默认为 /etc/hyperledger/fabric ）下相关文件是否就绪：<br>配置文件 core.yaml（可以参考 sampleconfig/core.yaml），指定了节点相关配置；<br>生成的 msp 文件目录、tls 文件目录，存放身份信息。<br>Peer 节点的配置可通过配置文件或环境变量方式进行指定，场景设置如下表所示。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">FABRIC_LOGGING_SPEC&#x3D;&quot;info:msp,gossip&#x3D;warning:chaincode&#x3D;debug&quot;\nCORE_PEER_ID&#x3D;peer0.org1.example.com\nCORE_PEER_LISTENADDRESS&#x3D;0.0.0.0:7051\nCORE_PEER_GOSSIP_EXTERNALENDPOINT&#x3D;peer0.org1.example.com:7051\nCORE_PEER_GOSSIP_USELEADERELECTION&#x3D;true\nCORE_PEER_GOSSIP_ORGLEADER&#x3D; false\nCORE_PEER_LOCALMSPID&#x3D;Org1MSP\nCORE_PEER_MSPCOCORE_VM_ENDPOINT&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sockNFIGPATH&#x3D;msp\nCORE_VM_ENDPOINT&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock\nCORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE&#x3D;host\nCORE_PEER_TLS_ENABLED&#x3D;true\nCORE_PEER_TLS_CERT_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;tls&#x2F;server.crt\nCORE_PEER_TLS_KEY_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;tls&#x2F;server.key\nCORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;tls&#x2F;ca.crt\nCORE_OPERATIONS_LISTENADDRESS&#x3D;0.0.0.0:9443\nCORE_METRICS_PROVIDER&#x3D;prometheus\n</code></pre>\n<p>配置完成后，用户可以采用如下命令在多个服务器上分别启动 Peer 服务，启动成功后可以看到本地输出的日志消息：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ peer node start\nUTC [ledgermgmt] initialize -&gt; INFO 002 Starting peer:\n Version: 2.0.0\n Commit SHA: development build\n Go version: go1.13.4\n OS&#x2F;Arch: linux&#x2F;amd64\n Chaincode:\n  Base Docker Namespace: hyperledger\n  Base Docker Label: org.hyperledger.fabric\n  Docker Namespace: hyperledger&quot;\n...\nUTC [nodeCmd] serve -&gt; INFO 01e Started peer with ID&#x3D;[name:&quot;peer0.org1.example.com&quot; ], network ID&#x3D;[dev], address&#x3D;[peer0.org1.example.com:7051]\n...</code></pre>\n<p>此时，Peer 节点已经启动起来，会尝试通过 gossip 发现邻居节点。</p>\n<h3 id=\"创建通道\"><a href=\"#创建通道\" class=\"headerlink\" title=\"创建通道\"></a>创建通道</h3><p>Peer 节点启动后，由于尚未跟 Orderer 建立连接，暂时还未加入网络中的应用通道。<br>下面在客户端发送请求给 Orderer 创建应用通道，并让 Peer 节点加入到通道中。<br>默认情况下，只有联盟中成员组织的管理员身份才可以创建应用通道。例如使用 Org1 的管理员身份来创建新的应用通道，需要指定 msp 的 ID、msp 文件所在路径、排序服务地址、应用通道名称和新建通道交易文件，如果启用了 TLS，还需要指定排序服务的 TLSCA 的证书位置：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ APP_CHANNEL&#x3D;businesschannel\n$ TIMEOUT&#x3D;30\n$ CORE_PEER_LOCALMSPID&#x3D;&quot;Org1MSP&quot; \\\n    CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp \\\n    peer channel create \\\n    -o orderer.example.com:7050 \\\n    -c $&#123;APP_CHANNEL&#125; \\\n    -f .&#x2F;$APP_CHANNEL.tx \\\n    --timeout &quot;$&#123;TIMEOUT&#125;s&quot; \\\n    --tls \\\n    --cafile &#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem</code></pre>\n<p>通道创建成功后，会在本地生成其初始区块文件（businesschannel.block），其中带有通道的初始配置信息和排序服务信息等。只有拥有该文件的 Peer 节点才可能加入到对应的通道中。</p>\n<h3 id=\"加入通道\"><a href=\"#加入通道\" class=\"headerlink\" title=\"加入通道\"></a>加入通道</h3><p>应用通道的成员组织的 Peer 都可以加入到通道中。<br>在客户端使用管理员身份依次让组织 Org1 和 Org2 中所有节点都加入新的应用通道。操作需要指定所操作的 Peer 的地址，以及通道的初始区块。<br>以 Org1 中的 peer0 节点为例，可以执行如下操作：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ CORE_PEER_LOCALMSPID&#x3D;&quot;Org1MSP&quot; \\\n    CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp \\\n    CORE_PEER_ADDRESS&#x3D;peer0.org1.example.com:7051 \\\n    peer channel join \\\n    -b $&#123;APP_CHANNEL&#125;.block\n\nPeer joined the channel!</code></pre>\n<p>此时，所操作的 Peer（如果成为组织的 Gossip Leader）会自动连接到应用通道指定的排序服务，开始接收区块。</p>\n<h3 id=\"更新锚节点配置\"><a href=\"#更新锚节点配置\" class=\"headerlink\" title=\"更新锚节点配置\"></a>更新锚节点配置</h3><p>锚节点（作为组织内成员代表）负责跟其它组织节点进行信息交换。通道配置内会记录各组织的锚节点列表信息，Peer 通过访问其他组织的锚节点来获取其他组织内的 Peer 信息。<br>使用锚节点配置更新文件，组织管理员可以更新通道中相关配置。<br>例如，在客户端使用 Org1 的管理员身份来更新锚节点，如下所示：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ CORE_PEER_LOCALMSPID&#x3D;&quot;Org1MSP&quot; \\\n    CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp \\\n    peer channel update \\\n    -o orderer.example.com:7050 \\\n    -c $&#123;APP_CHANNEL&#125; \\\n    -f $&#123;UPDATE_ANCHOR_ORG1_TX&#125; \\\n    --tls \\\n    --cafile &#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem</code></pre>\n<p>锚节点配置更新后，同一通道内不同组织之间的 Peer 也可以进行 Gossip 通信，共同维护通道账本。后续，用户可以在通道内通过智能合约更新账本记录。</p>\n<h2 id=\"容器方式启动-Fabric-网络\"><a href=\"#容器方式启动-Fabric-网络\" class=\"headerlink\" title=\"容器方式启动 Fabric 网络\"></a>容器方式启动 Fabric 网络</h2><p>除了上面讲解的手动部署的方式，读者还可以基于容器方式来快速部署 Fabric 网络并验证功能。<br>首先，按照如下命令下载 Docker-Compose 模板文件，并进入 hyperledger_fabric 目录，可以看到有对应多个 Fabric 版本的项目，用户可以根据需求选用特定版本：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">git clone https:&#x2F;&#x2F;github.com&#x2F;yeasy&#x2F;docker-compose-files\ncd docker-compose-files&#x2F;hyperledger_fabric</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/1da655b721c14b6e93705954e56dbd4b.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/84cbf917f2e5443fb40e54d185661536.png\" alt=\"请添加图片描述\"></p>\n<p>以 Fabric 2.0.0 版本为例，进入到对应目录下，并先下载所需镜像文件：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">cd v2.0.0\nmake download</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/51d1a1b9bdf5472da6bdeff746e61f3d.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/b692092cefc842d585ffc68f748503a7.png\" alt=\"请添加图片描述\"></p>\n<ul>\n<li><p>查看目录下内容，主要包括若干 Docker-Compose 模板文件，主要包括：<br>docker-compose-2orgs-4peer-raft.yaml：包括 4 个 peer 节点（属于两个组织）、3 个<br>Orderer 节点（Raft 模式）、2 个 CA 节点、1 个客户端节点；</p>\n</li>\n<li><p>docker-compose-1orgs-1peers-dev.yaml：包括 1 个 peer 节点、1 个 Orderer 节点、1<br>个 CA 节点、1 个客户端节点。本地 Fabric 源码被挂载到了客户端节点中，方便进行调试；</p>\n</li>\n</ul>\n<ul>\n<li>docker-compose-2orgs-4peer-kafka.yaml：包括 4 个 peer 节点（属于两个组织）、3 个<br>Orderer 节点（Kafka 模式）、2 个 CA 节点、1 个客户端节点；</li>\n<li><p>docker-compose-2orgs-4peer-couchdb.yaml：包括 4 个 peer 节点（属于两个组织，启用<br>couchDB 作为状态数据库）、2 个 Orderer 节点、1 个 CA 节点、1 个客户端节点。</p>\n<p>使用 Make  命令进行操作。例如使用 HLF_MODE 指定排序服务为 Raft 模式，快速启动网络并执行一系列测试：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">HLF_MODE&#x3D;raft make test</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ce4330f2a8684aa188ee4f97e1afded1.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/58d89d28aef54981811e27da7325befe.png\" alt=\"请添加图片描述\"></p>\n<p>运行过程中会自动创建网络并逐个完成通道和链码的相关测试，注意查看输出日志中无错误信息。<br>网络启动后，可以通过 docker ps 命令查看本地系统中运行的容器信息</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ docker ps\nCONTAINER ID        IMAGE                                     COMMAND                  CREATED             STATUS              PORTS                               NAMES\n1ee7db027b3f        yeasy&#x2F;hyperledger-fabric-peer:2.0.0      &quot;peer node start&quot;        27 seconds ago      Up 22 seconds       9443&#x2F;tcp, 0.0.0.0:8051-&gt;7051&#x2F;tcp    peer1.org1.example.com\n8f7bffcd14b3        yeasy&#x2F;hyperledger-fabric-peer:2.0.0      &quot;peer node start&quot;        27 seconds ago      Up 22 seconds       9443&#x2F;tcp, 0.0.0.0:10051-&gt;7051&#x2F;tcp   peer1.org2.example.com\n8a4e9aaec7ba        yeasy&#x2F;hyperledger-fabric-peer:2.0.0      &quot;peer node start&quot;        27 seconds ago      Up 22 seconds       9443&#x2F;tcp, 0.0.0.0:9051-&gt;7051&#x2F;tcp    peer0.org2.example.com\n7b9d394f26c0        yeasy&#x2F;hyperledger-fabric-peer:2.0.0      &quot;peer node start&quot;        27 seconds ago      Up 23 seconds       0.0.0.0:7051-&gt;7051&#x2F;tcp, 9443&#x2F;tcp    peer0.org1.example.com\nce9ca6c7b672        yeasy&#x2F;hyperledger-fabric-orderer:2.0.0   &quot;orderer start&quot;          30 seconds ago      Up 27 seconds       8443&#x2F;tcp, 0.0.0.0:8050-&gt;7050&#x2F;tcp    orderer1.example.com\n2646b7f0e462        yeasy&#x2F;hyperledger-fabric:2.0.0           &quot;bash -c &#39;cd &#x2F;tmp; s…&quot;   30 seconds ago      Up 15 seconds       7050-7054&#x2F;tcp                       fabric-cli\nc35e8694c634        yeasy&#x2F;hyperledger-fabric-orderer:2.0.0   &quot;orderer start&quot;          30 seconds ago      Up 27 seconds       8443&#x2F;tcp, 0.0.0.0:9050-&gt;7050&#x2F;tcp    orderer2.example.com\n1d6dd5009141        yeasy&#x2F;hyperledger-fabric-orderer:2.0.0   &quot;orderer start&quot;          30 seconds ago      Up 27 seconds       0.0.0.0:7050-&gt;7050&#x2F;tcp, 8443&#x2F;tcp    orderer0.example.com</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/7b84a6ac9f5c4a80b2a99989bfb46cbc.png\" alt=\"请添加图片描述\"></p>\n<p>用户如果希望在客户端、Peer 或 Orderer 容器内执行命令，可以通过 make cli|peer|orderer 命令进入到容器中。<br>例如，如下命令可以让用户登录到客户端节点，在其中以指定身份发送网络请求：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">make cli</code></pre>\n<p>用户也可以通过如下命令来查看日志输出：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">make logs</code></pre>\n<h2 id=\"视频\"><a href=\"#视频\" class=\"headerlink\" title=\"视频\"></a>视频</h2><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">一、环境准备\n\n1、apt换源\nhttps:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;help&#x2F;ubuntu&#x2F;\nsudo gedit &#x2F;etc&#x2F;apt&#x2F;sources.list\nsudo apt update\n\n2、安装docker、docker-compose\nsudo apt install docker docker-compose\nsudo systemctl enable docker\nsudo usermod -a -G docker &lt;username&gt;\n\n3、安装golang\nhttps:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;install\nsudo su\nrm -rf &#x2F;usr&#x2F;local&#x2F;go &amp;&amp; tar -C &#x2F;usr&#x2F;local -xzf go1.17.6.linux-amd64.tar.gz\ngedit &#x2F;etc&#x2F;profile\n\texport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin\ngedit ~&#x2F;.bashrc\n\tsource &#x2F;etc&#x2F;profile\n\n4、docker加速器\nhttps:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;cn-hangzhou&#x2F;instances&#x2F;mirrors\n\n二、安装fabric-sample\n\n1、手动创建脚本，安装samples、docker\nhttps:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;blob&#x2F;main&#x2F;scripts&#x2F;bootstrap.sh\n修改binaries&#x3D;false\nsudo chmod u+x bootstrap.sh\n.&#x2F;bootstrap.sh\n\n2、安装binaries\nhttps:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;releases&#x2F;download&#x2F;v2.4.6&#x2F;hyperledger-fabric-linux-amd64-2.4.6.tar.gz\nhttps:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-ca&#x2F;releases&#x2F;download&#x2F;v1.5.5&#x2F;hyperledger-fabric-ca-linux-amd64-1.5.5.tar.gz\ntar -xzvf 压缩包名 -C 目的地\n\n3、配置go代理\ngo env -w GO111MODULE&#x3D;on\ngo env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct\n\n\n\n\n\n\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/4c3a00507d6a4b8bb7823cb566f3fe44.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/cb1ae43fe17d4423b5e64cdfd14b64fc.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/1600a8d6ceca4ba2a76ebb943efa3fca.png\" alt=\"请添加图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/95b5df03876d4d559b5d312016837a0e.png\" alt=\"请添加图片描述\"></p>\n","text":"本地编译组件获取代码编译 Fabric 代码依赖一些开发库，可以通过如下命令安装： sudo apt-get update \\ &amp;&amp; sudo apt-get install -y libsnappy-dev zlib1g-dev libbz2-dev libya...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[],"tags":[{"name":"区块链","slug":"区块链","count":10,"path":"api/tags/区块链.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%AF%91%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">本地编译组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">获取代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85peer%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">编译安装peer组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-Orderer-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">编译安装 Orderer 组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-Fabric-CA-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">编译安装 Fabric CA 组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">编译安装配置辅助工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85-Protobuf-%E6%94%AF%E6%8C%81%E5%92%8C-Go-%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">安装 Protobuf 支持和 Go 语言相关工具</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">容器方式获取</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8-Fabric-%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">本地方式启动 Fabric 网络</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB%E5%92%8C%E8%BA%AB%E4%BB%BD%E8%AF%81%E4%B9%A6\"><span class=\"toc-text\">生成组织关系和身份证书</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%E9%80%9A%E9%81%93%E5%88%9D%E5%A7%8B%E5%8C%BA%E5%9D%97\"><span class=\"toc-text\">生成系统通道初始区块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E6%96%B0%E5%BB%BA%E5%BA%94%E7%94%A8%E9%80%9A%E9%81%93%E9%85%8D%E7%BD%AE%E4%BA%A4%E6%98%93\"><span class=\"toc-text\">生成新建应用通道配置交易</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E9%94%9A%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%96%B0%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">生成锚节点配置更新文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AF%E5%8A%A8-Orderer-%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">启动 Orderer 节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AF%E5%8A%A8-Peer-%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">启动 Peer 节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E9%80%9A%E9%81%93\"><span class=\"toc-text\">创建通道</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E5%85%A5%E9%80%9A%E9%81%93\"><span class=\"toc-text\">加入通道</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E9%94%9A%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">更新锚节点配置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8-Fabric-%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">容器方式启动 Fabric 网络</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%86%E9%A2%91\"><span class=\"toc-text\">视频</span></a></li></ol>","author":{"name":"Algernon","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/68c4c7d8696c482da565ab5c8ebfa2fa.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}},"mapped":true,"prev_post":{"title":"【区块链技术与应用】（三）","uid":"a8f74615832b979b7524788c050fb00a","slug":"区块链3","date":"2022-11-03T15:00:49.000Z","updated":"2022-11-03T15:00:48.042Z","comments":true,"path":"api/articles/区块链3.json","keywords":null,"cover":[],"text":" 引言本次内容复杂、且报错较多，部分图片没有放在最终文档里，而部分报错放在文档中，最终也没有删去。解决报错比单纯对着代码跑一遍难度更大，也更有意义，故予以保留。 内容1.0 内容准备这一部分作为一些常用命令的存储，显然，我在搭建环境的过程中重新配置的一遍之前的内容。（呜呜呜破防了...","link":"","photos":[],"count_time":{"symbolsCount":"37k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"区块链","slug":"区块链","count":10,"path":"api/tags/区块链.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/68c4c7d8696c482da565ab5c8ebfa2fa.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}},"next_post":{"title":"【区块链技术与应用】（一）","uid":"9707db72db0abf36328a217eb8d73065","slug":"区块链1","date":"2022-11-03T14:58:49.000Z","updated":"2022-11-08T16:30:06.004Z","comments":true,"path":"api/articles/区块链1.json","keywords":null,"cover":[],"text":"技术胖开启docker使用systemctl start命令，开启Docker服务端。 sudo systemctl start docker 创建容器后，如果查看这个容器的信息和状态那？这时候你可以使用下面的命令。 docker container ls 这时候我们需要学一个新...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"信管","slug":"信管","count":12,"path":"api/categories/信管.json"}],"tags":[{"name":"区块链","slug":"区块链","count":10,"path":"api/tags/区块链.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/68c4c7d8696c482da565ab5c8ebfa2fa.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}}}