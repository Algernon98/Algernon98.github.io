{"title":"【GO语言编程】（二）","uid":"5c84b4745a97bb70561ce70d97fa094d","slug":"GO2","date":"2022-11-03T14:53:49.000Z","updated":"2022-11-08T15:50:29.945Z","comments":true,"path":"api/articles/GO2.json","keywords":null,"cover":[],"content":"<h2 id=\"第一个go程序\"><a href=\"#第一个go程序\" class=\"headerlink\" title=\"第一个go程序\"></a>第一个go程序</h2><h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main   &#x2F;&#x2F; 声明 main 包\n\nimport &quot;fmt&quot;   &#x2F;&#x2F; 导入 fmt 包，打印字符串时需要用到\n\nfunc main()&#123;   &#x2F;&#x2F; 声明 main 主函数\n    fmt.Println(&quot;Hello, Go!&quot;)  &#x2F;&#x2F; 打印 Hello Go!\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/0f767c5b34d046fca892175d0c9065f9.png\" alt=\"在这里插入图片描述\"><br>与C语言一样，GO的注释分为两种：</p>\n<ul>\n<li>单行注释</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">fmt.Println(&quot;Hello, Go!&quot;)  &#x2F;&#x2F; 这里的部分作为说明，一般不跨行</code></pre>\n<ul>\n<li>多行注释</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n\t&#x2F;*\n\t\t以下两行代码都是将信息打印在屏幕上\n\t *&#x2F;\n\tfmt.Println(&quot;可爱淞淞超爱学习！&quot;)\n\tfmt.Printf(&quot;仿生程序员会梦见代码羊吗&quot;)\n&#125;</code></pre>\n<h3 id=\"package，包的创建\"><a href=\"#package，包的创建\" class=\"headerlink\" title=\"package，包的创建\"></a>package，包的创建</h3><p>对于GO语言，package，也就是包，是其管理单位。<br>每个GO源文件必须先声明它所属的包，所以我们会看到每个GO源文件的开头都是一个package声明。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package name   &#x2F;&#x2F;其中，package是声明 包 名的关键字，name则是包的名字</code></pre>\n<p>Go 语言的包与文件夹是一一对应的，<br>它具有以下几点特性：</p>\n<p>-在 一个目录下的同级文件属于同一个包。</p>\n<ul>\n<li>包的名称可以与其目录名不同。</li>\n<li>main 包是 Go 语言程序的入口包，一个 Go 语言程序必须<strong>有且仅有一个</strong> main 包。如果一个程序没有 main 包，那么编译时将会出错，无法生成可执行文件。<h3 id=\"import，包的导入\"><a href=\"#import，包的导入\" class=\"headerlink\" title=\"import，包的导入\"></a>import，包的导入</h3>import语句用于导入程序中所依赖的包，导入的包名使用双引号包围，格式如下：</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">import &quot;name&quot;   &#x2F;&#x2F;  import 是导入包的关键字，name 为所导入包的名字。</code></pre>\n<p><strong>另外有一点需要注意，导入的包中不能含有代码中没有使用到的包，否则 Go 编译器会报编译错误，例如<code>imported and not used: &quot;xxx&quot;</code>，”xxx” 表示包名。</strong></p>\n<h2 id=\"变量与常量\"><a href=\"#变量与常量\" class=\"headerlink\" title=\"变量与常量\"></a>变量与常量</h2><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>声明变量的一般形式是使用 var 关键字。</p>\n<ul>\n<li><p>方法一：声明一个变量, 默认的值是 0</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n    &#x2F;&#x2F; 方法一：声明一个变量, 默认的值是0\n    var a int\n    fmt.Println(&quot;a &#x3D; &quot;, a)\n    fmt.Printf(&quot;a的类型是: %T\\n&quot;, a)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/7fa2a22715c74e2e9deb6e3c9888beac.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>方法二：声明一个变量, 并初始化一个值</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n    &#x2F;&#x2F; 方法二：声明一个变量, 初始化一个值\n    var b int &#x3D; 100\n    fmt.Printf(&quot;b &#x3D; %d, type of b &#x3D; %T\\n&quot;, b, b)\n\n    var bb string &#x3D; &quot;千朵玫瑰带来的黎明&quot;\n    fmt.Printf(&quot;bb &#x3D; %s, bb的类型是: %T\\n&quot;, bb, bb)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/1070aeb8c79648ff8428e19287da2c0a.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li><p>方法三：在初始化的时候，可以省去数据类型，通过值去自动匹配当前变量的数据类型</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\n    &#x2F;&#x2F; 方法三：在初始化的时候，可以省去数据类型，通过值去自动匹配当前变量的数据类型\n    var c &#x3D; 100\n    fmt.Printf(&quot;c &#x3D; %d, type of c &#x3D; %T\\n&quot;, c, c)\n\n    var cc &#x3D; &quot;赤土之王与三朝圣者&quot;\n    fmt.Printf(&quot;cc &#x3D; %s, cc的类型是: %T\\n&quot;, cc, cc)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/5572298de8c04bf9b3dde7c26e030cae.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li><p>短声明，只能在函数内</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\n    &#x2F;&#x2F; 方法四：(常用的方法) 省去var关键字，使用:&#x3D;，既推导数据类型又赋值\n    &#x2F;&#x2F; 注: 短声明是在函数或方法内部使用, 不支持全局变量声明！！！！\n    e :&#x3D; 100\n    fmt.Printf(&quot;e &#x3D; %d, e的类型是: %T\\n&quot;, e, e)\n\n    f :&#x3D; &quot;为了果实、种子还有树&quot;\n    fmt.Printf(&quot;f &#x3D; %s, f的类型是: %T\\n&quot;, f, f)\n&#125;</code></pre>\n</li>\n<li><p>多变量声明</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\t&#x2F;&#x2F; 声明多个变量\n    var xx, yy int &#x3D; 100, 200\n    var kk, wx &#x3D; 300, &quot;write_code_666(电子羊)&quot;\n\n    var (\n        nn int &#x3D; 100\n        mm bool &#x3D; true\n    )\n&#125;</code></pre>\n</li>\n</ul>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量（constant）表示固定的值。在计算机程序运行时，不会被程序修改的。</p>\n<ul>\n<li><p>定义一个常量，使用 const 关键字。常量定义的时候就要赋值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n    &#x2F;&#x2F; 常量(只读属性)\n    const length int &#x3D; 10\n    &#x2F;&#x2F; length &#x3D; 100  &#x2F;&#x2F; 常量是不允许被修改的\n    fmt.Println(&quot;length &#x3D; &quot;, length)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/add8e73bdb864393aeb575aae979eecb.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li><p>使用 const 来定义枚举类型</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; const来定义枚举类型\nconst (\n    BEIJING &#x3D; 0\n    SHANGHAI &#x3D; 1\n    SHENZHEN &#x3D; 2\n)\n\nfunc main() &#123;\n    fmt.Println(&quot;BEIJING &#x3D; &quot;, BEIJING)      &#x2F;&#x2F; 0\n    fmt.Println(&quot;SHANGHAI &#x3D; &quot;, SHANGHAI)    &#x2F;&#x2F; 1\n    fmt.Println(&quot;SHENZHEN &#x3D; &quot;, SHENZHEN)    &#x2F;&#x2F; 2\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/3530054b80f641438309b76f936f84a4.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p><strong>iota</strong></p>\n<p><strong>iota 是 Go 语言的常量计数器,只能在常量的表达式中使用。</strong><br>iota 在 const 关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。使用 iota 能简化定义，在定义枚举时很有用</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; const来定义枚举类型\nconst (\n    &#x2F;&#x2F; 可以在const()中添加一个关键字iota, 每行的iota都会累加1, 第一行的iota默认是0\n    BEIJING &#x3D; 10 * iota   &#x2F;&#x2F; iota &#x3D; 0\n    SHANGHAI\t\t\t  &#x2F;&#x2F; iota &#x3D; 1\n    SHENZHEN\t\t\t  &#x2F;&#x2F; iota &#x3D; 2\n)\n\nfunc main() &#123;\n    fmt.Println(&quot;BEIJING &#x3D; &quot;, BEIJING)      &#x2F;&#x2F; 0\n    fmt.Println(&quot;SHANGHAI &#x3D; &quot;, SHANGHAI)    &#x2F;&#x2F; 10\n    fmt.Println(&quot;SHENZHEN &#x3D; &quot;, SHENZHEN)    &#x2F;&#x2F; 20\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/43a79750b34248eb9b0fb80292feb98d.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>关键字是 Go 语言中预先保留的单词，在程序中有特殊含义，不能用来定义变量或常量。</p>\n<p>Go 语言中有 25 个关键字：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>break</td>\n<td>default</td>\n<td>func</td>\n<td>interface</td>\n<td>select</td>\n</tr>\n<tr>\n<td>case</td>\n<td>defer</td>\n<td>go</td>\n<td>map</td>\n<td>struct</td>\n</tr>\n<tr>\n<td>chan</td>\n<td>else</td>\n<td>goto</td>\n<td>package</td>\n<td>switch</td>\n</tr>\n<tr>\n<td>const</td>\n<td>fallthrough</td>\n<td>if</td>\n<td>range</td>\n<td>type</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>for</td>\n<td>import</td>\n<td>return</td>\n<td>var</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><p>与C语言基本相同</p>\n<h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;math&quot;\n\n)\n\n&#x2F;&#x2F; 有符号整型\nfunc Integer() &#123;\n\tvar num8 int8 &#x3D; 127\n\tvar num16 int16 &#x3D; 32767\n\tvar num32 int32 &#x3D; math.MaxInt32\n\tvar num64 int64 &#x3D; math.MaxInt64\n\tvar num int &#x3D; math.MaxInt\n\tfmt.Printf(&quot;num8的类型是 %T, num8的大小 %d, num8是 %d\\n&quot;,\n\t\tnum8, unsafe.Sizeof(num8), num8)\n\tfmt.Printf(&quot;num16的类型是 %T, num16的大小 %d, num16是 %d\\n&quot;,\n\t\tnum16, unsafe.Sizeof(num16), num16)\n\tfmt.Printf(&quot;num32的类型是 %T, num32的大小 %d, num32是 %d\\n&quot;,\n\t\tnum32, unsafe.Sizeof(num32), num32)\n\tfmt.Printf(&quot;num64的类型是 %T, num64的大小 %d, num64是 %d\\n&quot;,\n\t\tnum64, unsafe.Sizeof(num64), num64)\n\tfmt.Printf(&quot;num的类型是 %T, num的大小 %d, num是 %d\\n&quot;,\n\t\tnum, unsafe.Sizeof(num), num)\n&#125;\n\n&#x2F;&#x2F; 无符号整型\nfunc unsignedInteger() &#123;\n\tvar num8 uint8 &#x3D; 128\n\tvar num16 uint16 &#x3D; 32768\n\tvar num32 uint32 &#x3D; math.MaxUint32\n\tvar num64 uint64 &#x3D; math.MaxUint64\n\tvar num uint &#x3D; math.MaxUint\n\tfmt.Printf(&quot;num8的类型是 %T, num8的大小 %d, num8是 %d\\n&quot;,\n\t\tnum8, unsafe.Sizeof(num8), num8)\n\tfmt.Printf(&quot;num16的类型是 %T, num16的大小 %d, num16是 %d\\n&quot;,\n\t\tnum16, unsafe.Sizeof(num16), num16)\n\tfmt.Printf(&quot;num32的类型是 %T, num32的大小 %d, num32是 %d\\n&quot;,\n\t\tnum32, unsafe.Sizeof(num32), num32)\n\tfmt.Printf(&quot;num64的类型是 %T, num64的大小 %d, num64是 %d\\n&quot;,\n\t\tnum64, unsafe.Sizeof(num64), num64)\n\tfmt.Printf(&quot;num的类型是 %T, num的大小 %d, num是 %d\\n&quot;,\n\t\tnum, unsafe.Sizeof(num), num)\n&#125;\n\nfunc main() &#123;\n\tInteger()\n\tprintln(&quot;---------------------------------------&quot;)\n\tunsignedInteger()\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/5e58d0622c5a4dcba13e5938e7c374d8.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>除非对整型的大小有特定的需求，否则你通常应该使用 <code>int</code> 表示整型宽度，在 <code>32</code> 位系统下是 <code>32</code> 位，而在 <code>64</code> 位系统下是 <code>64</code> 位。表示范围：在 <code>32</code> 位系统下是 <code>-2147483648</code> ~ <code>2147483647</code> ，而在 <code>64</code> 位系统是 <code>-9223372036854775808</code> ~ <code>9223372036854775807</code> 。</li>\n<li>对于 <code>int8</code> ， <code>int16</code> 等这些类型后面有跟一个数值的类型来说，它们能表示的数值个数是固定的。所以，在有的时候：例如在二进制传输、读写文件的结构描述(为了保持文件的结构不会受到不同编译目标平台字节长度的影响)等情况下，使用更加精确的 <code>int32</code> 和 <code>int64</code> 是更好的。</li>\n</ul>\n<h3 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h3><p>浮点型表示存储的数据是实数，如 3.145。关于浮点型的说明，如表所示。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>字节数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float32</td>\n<td>4</td>\n<td>32 位的浮点型</td>\n</tr>\n<tr>\n<td>float64</td>\n<td>8</td>\n<td>64 位的浮点型</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>示例程序：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;math&quot;\n\n)\nfunc showFloat() &#123;\n\tvar num1 float32 &#x3D; math.MaxFloat32\n\tvar num2 float64 &#x3D; math.MaxFloat64\n\tfmt.Printf(&quot;num1的类型是%T,num1是%g\\n&quot;, num1, num1)\n\tfmt.Printf(&quot;num2的类型是%T,num1是%g\\n&quot;, num2, num2)\n&#125;\n\nfunc main() &#123;\n     showFloat()\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/8bc7eb80576241d29045c245f4ff34ed.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>通过上面的程序，我们知道浮点数能表示的数值很大，但是浮点数的精度却没有那么大：<ul>\n<li><code>float32</code> 的精度只能提供大约 <code>6</code> 个十进制数(表示小数点后 <code>6</code> 位)的精度。</li>\n<li><code>float64</code> 的精度能提供大约 <code>15</code> 个十进制数(表示小数点后 <code>15</code> 位)的精度。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"字符类型\"><a href=\"#字符类型\" class=\"headerlink\" title=\"字符类型\"></a>字符类型</h3><p>字符串中的每一个元素叫作“字符”，定义字符时使用单引号。Go 语言的字符有两种，如表所示。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类 型</th>\n<th>字 节 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>1</td>\n<td>表示 UTF-8 字符串的单个字节的值，表示的是 ASCII 码表中的一个字符，uint8 的别名类型</td>\n</tr>\n<tr>\n<td>rune</td>\n<td>4</td>\n<td>表示单个 unicode 字符，int32 的别名类型</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>声明示例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\nimport &quot;unsafe&quot;\n\nfunc showChar() &#123;\n     var x byte &#x3D; 65\n     var y uint8 &#x3D; 65\n     fmt.Printf(&quot;x &#x3D; %c\\n&quot;, x)   &#x2F;&#x2F; x &#x3D; A\n     fmt.Printf(&quot;y &#x3D; %c\\n&quot;, y)   &#x2F;&#x2F; y &#x3D; A\n&#125;\n\nfunc sizeOfChar() &#123;\n    var x byte &#x3D; 65\n    fmt.Printf(&quot;x &#x3D; %c\\n&quot;, x)\n    fmt.Printf(&quot;x 占用 %d 个字节\\n&quot;, unsafe.Sizeof(x))\n\n    var y rune &#x3D; &#39;A&#39;\n    fmt.Printf(&quot;y &#x3D; %c\\n&quot;, y)\n    fmt.Printf(&quot;y 占用 %d 个字节\\n&quot;, unsafe.Sizeof(y))\n&#125;\n\nfunc main() &#123;\n    showChar();\n    sizeOfChar();\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/923aa1a12a2a4df7b4784c30d65c105e.png\" alt=\"在这里插入图片描述\"></p>\n<p>byte 类型只能表示 28个值，所以你想表示其他一些值，例如中文的话，就得使用 rune 类型</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">var y rune &#x3D; &#39;原&#39;</code></pre>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串在 Go 语言中是以基本数据类型出现的，使用字符串就像使用其他原生基本数据类型 int、float32、float64、bool 一样。</p>\n<p>示例程序：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var study string  \t \t\t&#x2F;&#x2F; 定义名为str的字符串类型变量\nstudy &#x3D; &quot;《阿赫玛尔的故事 》&quot;\t\t&#x2F;&#x2F; 将变量赋值\n\nstudy2 :&#x3D; &quot;《森林书》&quot;\t\t&#x2F;&#x2F; 以自动推断方式初始化</code></pre>\n<p>有些字符串没有现成的文字代号，所以只能用转义字符来表示。常用的转义字符如表所示。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>转 义 字 符</th>\n<th>含 义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\r</code></td>\n<td>回车符 return，返回行首</td>\n</tr>\n<tr>\n<td><code>\\n</code></td>\n<td>换行符 new line, 直接跳到下一行的同列位置</td>\n</tr>\n<tr>\n<td><code>\\t</code></td>\n<td>制表符 TAB</td>\n</tr>\n<tr>\n<td><code>\\&#39;</code></td>\n<td>单引号</td>\n</tr>\n<tr>\n<td><code>\\&quot;</code></td>\n<td>双引号</td>\n</tr>\n<tr>\n<td><code>\\\\</code></td>\n<td>反斜杠</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>定义多行字符串的方法如下。</p>\n<ul>\n<li>双引号书写字符串被称为字符串字面量（string literal），这种字面量不能跨行。</li>\n<li>多行字符串需要使用反引号“`”，多用于内嵌源码和内嵌数据。</li>\n<li>在反引号中的所有代码不会被编译器识别，而只是作为字符串的一部分。</li>\n</ul>\n<p>多行字符串定义方式如例所示：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n  var s1 string\n\ts1 &#x3D; &#96;\n    \t\tstudy :&#x3D; &#39;你好，谢谢，最后是再见&#39;\n    \t\tfmt.Println(study)\n\t\t\t&#96;\n\tfmt.Println(s1)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/be9a4a4a3a114b42b27e5a697d9c89a2.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h3><p>关于 <strong>布尔(bool)</strong> 类型，即两个值：<strong>true</strong> 或者 <strong>false</strong> 。</p>\n<p>示例程序：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func showBool()&#123;\n\ta :&#x3D; true\n\tb :&#x3D; false\n\tfmt.Println(&quot;a&#x3D;&quot;, a)\n\tfmt.Println(&quot;b&#x3D;&quot;, b)\n\tfmt.Println(&quot;true &amp;&amp; false &#x3D; &quot;, a &amp;&amp; b)\n\tfmt.Println(&quot;true || false &#x3D; &quot;, a || b)\n&#125;\n\nfunc main() &#123;\n    showBool()\n&#125;</code></pre>\n<p><strong>Tip：</strong></p>\n<ul>\n<li>如果你学过其他编程语言或许会发现，布尔型可以参与数值运算，也可以与其他类型进行转换。但是在 Go 中，真值是用 <code>true</code> 表示，并且 <strong>不与</strong> <code>1</code> 相等；同样的，假值是用 <code>false</code> 表示，并且 <strong>不与</strong> <code>0</code> 相等。</li>\n</ul>\n<h3 id=\"复数型\"><a href=\"#复数型\" class=\"headerlink\" title=\"复数型\"></a>复数型</h3><p>复数型用于表示数学中的复数，如 1+2j、1-2j、-1-2j 等。在 Go 语言中提供了两种精度的复数类型：<strong>complex64</strong> 和 <strong>complex128</strong> ，分别对应 float32 和 float64 两种浮点数精度，如表所示。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类 型</th>\n<th>字 节 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>complex64</td>\n<td>8</td>\n<td>64 位的复数型，由 float32 类型的实部和虚部联合表示</td>\n</tr>\n<tr>\n<td>complex128</td>\n<td>16</td>\n<td>128 位的复数型，由 float64 类型的实部和虚部联合表示</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>示例程序：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func showComplex() &#123;\n\t&#x2F;&#x2F; 内置的 complex 函数用于构建复数\n\tvar x complex64 &#x3D; complex(1, 2)\n\tvar y complex128 &#x3D; complex(3, 4)\n\tvar z complex128 &#x3D; complex(5, 6)\n\tfmt.Println(&quot;x &#x3D; &quot;, x)\n\tfmt.Println(&quot;y &#x3D; &quot;, y)\n\tfmt.Println(&quot;z &#x3D; &quot;, z)\n\n\t&#x2F;&#x2F; 内建的 real 和 imag 函数分别返回复数的实部和虚部\n\tfmt.Println(&quot;real(x) &#x3D; &quot;, real(x))\n\tfmt.Println(&quot;imag(x) &#x3D; &quot;, imag(x))\n\tfmt.Println(&quot;y * z &#x3D; &quot;, y*z)\n&#125;\n\nfunc main() &#123;\n   showComplex()\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/d3f3befa83b94894be0cb08f3b4de988.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>当然，我们可以对声明进行简化，使用自然的方式书写复数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">x :&#x3D; 1 + 2i\ny :&#x3D; 3 + 4i\nz :&#x3D; 5 + 6i</code></pre>\n</li>\n</ul>\n<h3 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>%%</th>\n<th>一个%字面量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%b</td>\n<td>一个二进制整数值(基数为 2)，或者是一个(高级的)用科学计数法表示的指数为 2 的浮点数</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>字符型。可以把输入的数字按照 ASCII 码相应转换为对应的字符</td>\n</tr>\n<tr>\n<td><strong>格式</strong></td>\n<td><strong>含义</strong></td>\n</tr>\n<tr>\n<td>%d</td>\n<td>一个十进制数值(基数为 10)</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>以标准记数法表示的浮点数或者复数值</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>一个以八进制表示的数字(基数为 8)</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>以十六进制(基数为 16)表示的一个值的地址，前缀为 0x,字母使用小写的 a-f 表示</td>\n</tr>\n<tr>\n<td>%q</td>\n<td>使用 Go 语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\\0‘结尾，这个’\\0’即空字符）</td>\n</tr>\n<tr>\n<td>%t</td>\n<td>以 true 或者 false 输出的布尔值</td>\n</tr>\n<tr>\n<td>%T</td>\n<td>使用 Go 语法输出的值的类型</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>以十六进制表示的整型值(基数为十六)，数字 a-f 使用小写表示</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>以十六进制表示的整型值(基数为十六)，数字 A-F 使用小写表示</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"容器类型\"><a href=\"#容器类型\" class=\"headerlink\" title=\"容器类型\"></a>容器类型</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p><strong>数组</strong> 是一个由 <strong>固定长度</strong> 的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在 Go 语言中很少直接使用数组。和数组对应的类型是 <strong>slice(切片)</strong> ，它是可以动态的增长和收缩的序列， <code>slice</code> 功能也更灵活，下面我们再讨论 <code>slice</code> 。</p>\n<h4 id=\"数组声明\"><a href=\"#数组声明\" class=\"headerlink\" title=\"数组声明\"></a>数组声明</h4><p>可以使用 <code>[n]Type</code> 来声明一个数组。其中 <code>n</code> 表示数组中元素的数量， <code>Type</code> 表示每个元素的类型。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\nfunc test01() &#123;\n\t&#x2F;&#x2F; 声明时没有指定数组元素的值, 默认为零值\n\tvar arr [5]int\n\tfmt.Println(arr)\n\n\tarr[0] &#x3D; 1\n\tarr[1] &#x3D; 2\n\tarr[2] &#x3D; 3\n\tfmt.Println(arr)\n&#125;\n\nfunc test02() &#123;\n\t&#x2F;&#x2F; 直接在声明时对数组进行初始化\n\tvar arr1 &#x3D; [5]int&#123;15, 20, 25, 30, 35&#125;\n\tfmt.Println(arr1)\n\n\t&#x2F;&#x2F; 使用短声明\n\tarr2 :&#x3D; [5]int&#123;15, 20, 25, 30, 35&#125;\n\tfmt.Println(arr2)\n\n\t&#x2F;&#x2F; 部分初始化, 未初始化的为零值\n\tarr3 :&#x3D; [5]int&#123;15, 20&#125; &#x2F;&#x2F; [15 20 0 0 0]\n\tfmt.Println(arr3)\n\n\t&#x2F;&#x2F; 可以通过指定索引，方便地对数组某几个元素赋值\n\tarr4 :&#x3D; [5]int&#123;1: 100, 4: 200&#125;\n\tfmt.Println(arr4) &#x2F;&#x2F; [0 100 0 0 200]\n\n\t&#x2F;&#x2F; 直接使用 ... 让编译器为我们计算该数组的长度\n\tarr5 :&#x3D; [...]int&#123;15, 20, 25, 30, 35, 40&#125;\n\tfmt.Println(arr5)\n&#125;\n\nfunc test03() &#123;\n\t&#x2F;&#x2F; 特别注意数组的长度是类型的一部分，所以 [3]int 和 [5]int 是不同的类型\n\tarr1 :&#x3D; [3]int&#123;15, 20, 25&#125;\n\tarr2 :&#x3D; [5]int&#123;15, 20, 25, 30, 35&#125;\n\tfmt.Printf(&quot;type of arr1 is %T\\n&quot;, arr1)\n\tfmt.Printf(&quot;type of arr2 is %T\\n&quot;, arr2)\n&#125;\n\nfunc test04() &#123;\n\t&#x2F;&#x2F; 定义多维数组\n\tarr :&#x3D; [3][2]string&#123;\n\t\t&#123;&quot;1&quot;, &quot;你好&quot;&#125;,\n\t\t&#123;&quot;2&quot;, &quot;谢谢&quot;&#125;,\n\t\t&#123;&quot;3&quot;, &quot;最后是 再见&quot;&#125;&#125;\n\tfmt.Println(arr) &#x2F;&#x2F; [[15 20] [25 22] [25 22]]\n&#125;\n\nfunc main() &#123;\n\ttest01()\n\ttest02()\n\ttest03()\n\ttest04()\n&#125;</code></pre>\n<h4 id=\"数组长度\"><a href=\"#数组长度\" class=\"headerlink\" title=\"数组长度\"></a>数组长度</h4><p>使用内置的 <code>len</code> 函数将返回数组中元素的个数，即数组的长度。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func arrLength() &#123;\n\tarr :&#x3D; [...]string&#123;&quot;为了果实&quot;, &quot;种子&quot;, &quot;还有树&quot;&#125;\n\tfmt.Println(&quot;数组的长度是:&quot;, len(arr)) &#x2F;&#x2F;数组的长度是: 3\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/d9fd254a7e3042aca6cb2bdd4eb0fb9a.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h4><p>使用 <code>for range</code> 循环可以获取数组每个索引以及索引上对应的元素。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func showArr() &#123;\n\tarr :&#x3D; [...]string&#123;&quot;你好&quot;, &quot;谢谢&quot;, &quot;最后是再见&quot;&#125;\n\tfor index, value :&#x3D; range arr &#123;\n\t\tfmt.Printf(&quot;arr[%d]&#x3D;%s\\n&quot;, index, value)\n\t&#125;\n\n\tfor _, value :&#x3D; range arr &#123;\n\t\tfmt.Printf(&quot;value&#x3D;%s\\n&quot;, value)\n\t&#125;\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/8c140b588f754b0d88a1381fbfd29e57.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"数组是值类型\"><a href=\"#数组是值类型\" class=\"headerlink\" title=\"数组是值类型\"></a><strong>数组是值类型</strong></h4><p>Go 中的数组是值类型而不是引用类型。当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。如果对新变量进行更改，不会影响原始数组。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func arrByValue() &#123;\n\tarr :&#x3D; [...]string&#123;&quot;兰拉娜&quot;, &quot;兰罗摩&quot;, &quot;兰百梨迦&quot;&#125;\n\tcopy :&#x3D; arr\n\tcopy[0] &#x3D; &quot;Golang&quot;\n\tfmt.Println(arr)\n\tfmt.Println(copy)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/c96917b542b24c1a905d38d22922603b.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"切片-Slice\"><a href=\"#切片-Slice\" class=\"headerlink\" title=\"切片(Slice)\"></a>切片(Slice)</h3><p>切片是对数组的一个连续片段的引用，所以切片是一个引用类型。切片 本身不拥有任何数据，它们只是对现有数组的引用，每个切片值都会将数组作为其底层的数据结构。slice 的语法和数组很像，只是没有固定长度而已。</p>\n<h4 id=\"创建切片\"><a href=\"#创建切片\" class=\"headerlink\" title=\"创建切片\"></a>创建切片</h4><p>使用 <code>[]Type</code> 可以创建一个带有 <code>Type</code> 类型元素的切片。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 声明整型切片\nvar numList []int\n\n&#x2F;&#x2F; 声明一个空切片\nvar numListEmpty &#x3D; []int&#123;&#125;</code></pre>\n<p>你也可以使用 <code>make</code> 函数构造一个切片，格式为 <code>make([]Type, size, cap)</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">numList :&#x3D; make([]int, 3, 5)</code></pre>\n<p>当然，我们可以通过对数组进行片段截取创建一个切片。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">arr :&#x3D; [5]string&#123;&quot;兰罗摩&quot;, &quot;兰穆护昆达&quot;, &quot;兰利遮&quot;, &quot;兰娜库拉&quot;, &quot;兰宁巴&quot;&#125;\nvar s1 &#x3D; arr[1:4]\nfmt.Println(arr) &#x2F;&#x2F;\nfmt.Println(s1)  &#x2F;&#x2F;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/93eacf06640c458c813566557c106a42.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"切片的长度和容量\"><a href=\"#切片的长度和容量\" class=\"headerlink\" title=\"切片的长度和容量\"></a>切片的长度和容量</h4><p>一个 slice 由三个部分构成：<strong>指针</strong> 、 <strong>长度</strong> 和 <strong>容量</strong> 。指针指向第一个 slice 元素对应的底层数组元素的地址，要注意的是 slice 的第一个元素并不一定就是数组的第一个元素。长度对应 slice 中元素的数目；长度不能超过容量，容量一般是从 slice 的开始位置到底层数据的结尾位置。简单的讲，容量就是从创建切片索引开始的底层数组中的元素个数，而长度是切片中的元素个数。</p>\n<p>内置的 <code>len</code> 和 <code>cap</code> 函数分别返回 slice 的长度和容量。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">s :&#x3D; make([]string, 3, 5)\nfmt.Println(len(s)) &#x2F;&#x2F; 3\nfmt.Println(cap(s)) &#x2F;&#x2F; 5</code></pre>\n<p>如果切片操作超出上限将导致一个 <code>panic</code> 异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">s :&#x3D; make([]int, 3, 5)\nfmt.Println(s[10]) &#x2F;&#x2F;panic: runtime error: index out of range [10] with length 3</code></pre>\n<p>Tips:</p>\n<ul>\n<li><p>由于 slice 是引用类型，所以你不对它进行赋值的话，它的默认值是 <code>nil</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var numList []int\nfmt.Println(numList &#x3D;&#x3D; nil) &#x2F;&#x2F; true</code></pre>\n</li>\n<li><p>切片之间不能比较，因此我们不能使用 <code>==</code> 操作符来判断两个 slice 是否含有全部相等元素。特别注意，如果你需要测试一个 slice 是否是空的，使用 <code>len(s) == 0</code> 来判断，而不应该用 <code>s == nil</code> 来判断。</p>\n</li>\n</ul>\n<h4 id=\"切片元素的修改\"><a href=\"#切片元素的修改\" class=\"headerlink\" title=\"切片元素的修改\"></a>切片元素的修改</h4><p>切片自己不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func modifySlice() &#123;\n\tvar arr &#x3D; [...]string&#123;&quot;正法炬书&quot;, &quot;水天供书&quot;, &quot;吉祥具书&quot;&#125;\n\ts :&#x3D; arr[:] &#x2F;&#x2F;[0:len(arr)]\n\tfmt.Println(arr) &#x2F;&#x2F;\n\tfmt.Println(s) &#x2F;&#x2F;\n\n\ts[0] &#x3D; &quot;森林书&quot;\n\tfmt.Println(arr) &#x2F;&#x2F;[\n\tfmt.Println(s) &#x2F;&#x2F;\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/95a7773153894a1bb1d241c3b518a334.png\" alt=\"在这里插入图片描述\"></p>\n<p>这里的 <code>arr[:]</code> 没有填入起始值和结束值，默认就是 <code>0</code> 和 <code>len(arr)</code> 。</p>\n<h4 id=\"追加切片元素\"><a href=\"#追加切片元素\" class=\"headerlink\" title=\"追加切片元素\"></a>追加切片元素</h4><p>使用 <code>append</code> 可以将新元素追加到切片上。<code>append</code> 函数的定义是 <code>func append(slice []Type, elems ...Type) []Type</code> 。其中 <code>elems ...Type</code> 在函数定义中表示该函数接受参数 <code>elems</code> 的个数是可变的。这些类型的函数被称为可变函数。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">  func appendSliceData() &#123;\n\ts :&#x3D; []string&#123;&quot;终天的闭幕曲&quot;&#125;\n\tfmt.Println(s)\n\tfmt.Println(cap(s))\n\n\ts &#x3D; append(s, &quot;岩壑之崩&quot;)\n\tfmt.Println(s)\n\tfmt.Println(cap(s))\n\n\ts &#x3D; append(s, &quot;冰风回荡&quot;, &quot;冰封交响曲 &quot;)\n\tfmt.Println(s)\n\tfmt.Println(cap(s))\n\n\ts &#x3D; append(s, []string&#123;&quot;哀息之茧&quot;, &quot;燃尽之舞&quot;&#125;...)\n\tfmt.Println(s)\n\tfmt.Println(cap(s))\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/735adcc11c384882a4acfaf70cdaac8f.png\" alt=\"在这里插入图片描述\"></p>\n<p>当新的元素被添加到切片时，如果容量不足，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回新的引用。现在新切片的容量是旧切片的两倍。</p>\n<h4 id=\"多维切片\"><a href=\"#多维切片\" class=\"headerlink\" title=\"多维切片\"></a>多维切片</h4><p>类似于数组，切片也可以有多个维度。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func mSlice() &#123;\n\tnumList :&#x3D; [][]string&#123;\n\t\t&#123;&quot;1&quot;, &quot;捕风的异乡人&quot;&#125;,\n\t\t&#123;&quot;2&quot;, &quot;辞别久远之躯&quot;&#125;,\n\t\t&#123;&quot;3&quot;, &quot;千手百眼天下人间&quot;&#125;,\n\t&#125;\n\tfmt.Println(numList)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/43c396c91edb4447b450d5f6b3a52a39.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>在 Go 语言中，map 是散列表(哈希表)的引用。它是一个拥有键值对元素的<strong>无序集合</strong>，在这个集合中，键是唯一的，可以通过键来获取、更新或移除操作。无论这个散列表有多大，这些操作基本上是通过常量时间完成的。所有可比较的类型，如 <code>整型</code> ，<code>字符串</code> 等，都可以作为 <code>key</code> 。</p>\n<h4 id=\"创建-Map\"><a href=\"#创建-Map\" class=\"headerlink\" title=\"创建 Map\"></a>创建 Map</h4><p>使用 <code>make</code> 函数传入键和值的类型，可以创建 map 。具体语法为 <code>make(map[KeyType]ValueType)</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 创建一个键类型为 string 值类型为 int 名为 scores 的 map\nscores :&#x3D; make(map[string]int)\nsteps :&#x3D; make(map[string]string)</code></pre>\n<p>我们也可以用 map 字面值的语法创建 map ，同时还可以指定一些最初的 key/value ：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var steps2 map[string]string &#x3D; map[string]string&#123;\n\t\t&quot;第一步&quot;: &quot;穿越雾霭与森林&quot;,\n\t\t&quot;第二步&quot;: &quot;千朵玫瑰带来的黎明&quot;,\n\t\t&quot;第三步&quot;: &quot;赤土之王与三朝圣者&quot;,\n&#125;\nfmt.Println(steps2)</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/10c6dfa4762d474db8576a1bd5e390b5.png\" alt=\"在这里插入图片描述\"></p>\n<p>或者</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">steps3 :&#x3D; map[string]string&#123;\n\t\t&quot;第一步&quot;: &quot;穿越雾霭与森林&quot;,\n\t\t&quot;第二步&quot;: &quot;千朵玫瑰带来的黎明&quot;,\n\t\t&quot;第三步&quot;: &quot;赤土之王与三朝圣者&quot;,\n&#125;\nfmt.Println(steps3)</code></pre>\n<h4 id=\"Map-操作\"><a href=\"#Map-操作\" class=\"headerlink\" title=\"Map 操作\"></a>Map 操作</h4><ul>\n<li><p>添加元素</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 可以使用 &#96;map[key] &#x3D; value&#96; 向 map 添加元素。\nsteps3[&quot;第四步&quot;] &#x3D; &quot;总监&quot;</code></pre>\n</li>\n<li><p>更新元素</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 若 key 已存在，使用 map[key] &#x3D; value 可以直接更新对应 key 的 value 值。\nsteps3[&quot;第四步&quot;] &#x3D; &quot;CTO&quot;</code></pre>\n</li>\n<li><p>获取元素</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 直接使用 map[key] 即可获取对应 key 的 value 值,如果 key不存在,会返回其 value 类型的零值。\nfmt.Println(steps3[&quot;第四步&quot;] )</code></pre>\n</li>\n<li><p>删除元素</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;使用 delete(map, key)可以删除 map 中的对应 key 键值对,如果 key 不存在,delete 函数会静默处理，不会报错。\ndelete(steps3, &quot;第四步&quot;)</code></pre>\n</li>\n<li><p>判断 key 是否存在</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 如果我们想知道 map 中的某个 key 是否存在，可以使用下面的语法：value, ok :&#x3D; map[key]\nv3, ok :&#x3D; steps3[&quot;第三步&quot;]\nfmt.Println(ok)\nfmt.Println(v3)\n\nv4, ok :&#x3D; steps3[&quot;第四步&quot;]\nfmt.Println(ok)\nfmt.Println(v4)</code></pre>\n</li>\n</ul>\n<p>这个语句说明 <code>map</code> 的下标读取可以返回两个值，第一个值为当前 <code>key</code> 的 <code>value</code> 值，第二个值表示对应的 <code>key</code> 是否存在，若存在 <code>ok</code> 为 <code>true</code> ，若不存在，则 <code>ok</code> 为 <code>false</code> 。</p>\n<ul>\n<li><p>遍历 map</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 遍历 map 中所有的元素需要用 for range 循环。\nfor key, value :&#x3D; range steps3 &#123;\n    fmt.Printf(&quot;key: %s, value: %d\\n&quot;, key, value)\n&#125;</code></pre>\n</li>\n<li><p>获取 map 长度</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 使用 len 函数可以获取 map 长度\nfunc createMap() &#123;\n  \t&#x2F;&#x2F;...\n     fmt.Println(len(steps3))    &#x2F;&#x2F; 4\n&#125;</code></pre>\n</li>\n</ul>\n<h4 id=\"map-是引用类型\"><a href=\"#map-是引用类型\" class=\"headerlink\" title=\"map 是引用类型\"></a>map 是引用类型</h4><p>当 <code>map</code> 被赋值为一个新变量的时候，它们指向同一个内部数据结构。因此，改变其中一个变量，就会影响到另一变量。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func mapByReference() &#123;\n\t\tsteps4 :&#x3D; map[string]string&#123;\n\t\t&quot;第一步&quot;: &quot;穿越雾霭与森林&quot;,\n\t\t&quot;第二步&quot;: &quot;千朵玫瑰带来的黎明&quot;,\n\t\t&quot;第三步&quot;: &quot;赤土之王与三朝圣者&quot;,\n\t&#125;\n\tfmt.Println(&quot;steps4: &quot;, steps4)\n\t\n\tnewSteps4 :&#x3D; steps4\n\tnewSteps4[&quot;第一步&quot;] &#x3D; &quot;穿越雾霭与烟林&quot;\n\tnewSteps4[&quot;第二步&quot;] &#x3D; &quot;花神之舞&quot;\n\tnewSteps4[&quot;第三步&quot;] &#x3D; &quot;千柱沙原&quot;\n\tfmt.Println(&quot;steps4: &quot;, steps4)\n  \n\tfmt.Println(&quot;newSteps4: &quot;, newSteps4)\n \n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/e21f1a6dd0a6447c9b07e60ab4961d01.png\" alt=\"在这里插入图片描述\"></p>\n<p>当 <code>map</code> 作为函数参数传递时也会发生同样的情况。</p>\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><p>指针也是一种类型，也可以创建变量，称之为指针变量。指针变量的类型为 <code>*Type</code>，该指针指向一个 <code>Type</code> 类型的变量。指针变量最大的特点就是存储的某个实际变量的内存地址，通过记录某个变量的地址，从而间接的操作该变量。</p>\n<p><a href=\"https://tva1.sinaimg.cn/large/e6c9d24egy1h1wg12o4byj20m80as0t5.jpg\"><img src=\"https://img-blog.csdnimg.cn/img_convert/b15b08318c3b31c05fc896d8aaf01a6d.jpeg\" alt=\"Pointers-in-Golang\"></a></p>\n<h3 id=\"创建指针\"><a href=\"#创建指针\" class=\"headerlink\" title=\"创建指针\"></a>创建指针</h3><p>创建指针有三种方法。</p>\n<ul>\n<li><p>首先定义普通变量，再通过获取该普通变量的地址创建指针：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; 定义普通变量 x\nx :&#x3D; &quot;可爱电子羊！&quot;\n&#x2F;&#x2F; 取普通变量 x 的地址创建指针 p\nptr :&#x3D; &amp;x\n fmt.Println(ptr)\n fmt.Println(*ptr)</code></pre>\n</li>\n<li><p>先创建指针并分配好内存，再给指针指向的内存地址写入对应的值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; 创建指针\nptr2 :&#x3D; new(string)\n&#x2F;&#x2F; 给指针指向的内存地址写入对应的值\n*ptr2 &#x3D; &quot;更可爱的电子羊！！&quot;\nfmt.Println(ptr2)\nfmt.Println(*ptr2)</code></pre>\n</li>\n<li><p>首先声明一个指针变量，再从其他变量获取内存地址给指针变量：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; 定义变量 x2\nx2 :&#x3D; &quot;超可爱的仿生电子羊！！！&quot;\n&#x2F;&#x2F; 声明指针变量\nvar p *string\n&#x2F;&#x2F; 指针初始化\np &#x3D; &amp;x2\nfmt.Println(p)</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/86e0393c269f4598b7caec1389698394.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p><strong>Tip：</strong></p>\n<p>上面举的创建指针的三种方法对学过 C 语言的人来说可能很简单（比如在下），但没学过指针相关知识的人可能不太明白，特别是上面代码中出现的指针操作符 <code>&amp;</code> 和 <code>*</code> 。</p>\n<ul>\n<li><code>&amp;</code> 操作符可以从一个变量中取到其内存地址。</li>\n<li><code>*</code> 操作符如果在赋值操作值的左边，指该指针指向的变量；<code>*</code> 操作符如果在赋值操作符的右边，指从一个指针变量中取得变量值，又称指针的解引用。</li>\n</ul>\n<p>通过下面的例子，你应该就会比较清楚的理解上面两个指针操作符了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tx :&#x3D; &quot;山巅雪国的记忆&quot;\n\tptr :&#x3D; &amp;x\n\tfmt.Println(&quot;x &#x3D; &quot;, x)   \n\tfmt.Println(&quot;*ptr &#x3D; &quot;, *ptr) \n\tfmt.Println(&quot;&amp;x &#x3D; &quot;, &amp;x) \n\tfmt.Println(&quot;ptr &#x3D; &quot;, ptr)   \n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/a76ae12cb6314b5cb67ee84633aaad14.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"指针的类型\"><a href=\"#指针的类型\" class=\"headerlink\" title=\"指针的类型\"></a>指针的类型</h3><p><code>*(指向变量值的数据类型)</code> 就是对应的指针类型。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc pointerType() &#123;\n\tmystr :&#x3D; &quot;雪葬的星银&quot;\n\tmyint :&#x3D; 1\n\tmybool :&#x3D; false\n\tmyfloat :&#x3D; 3.2\n\tfmt.Printf(&quot;type of &amp;mystr is :%T\\n&quot;, &amp;mystr)\n\tfmt.Printf(&quot;type of &amp;myint is :%T\\n&quot;, &amp;myint)\n\tfmt.Printf(&quot;type of &amp;mybool is :%T\\n&quot;, &amp;mybool)\n\tfmt.Printf(&quot;type of &amp;myfloat is :%T\\n&quot;, &amp;myfloat)\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F;...\n\tpointerType()\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/b972af55c7d644558233c50b16cce4e1.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"指针的零值\"><a href=\"#指针的零值\" class=\"headerlink\" title=\"指针的零值\"></a>指针的零值</h3><p>如果指针声明后没有进行初始化，其默认零值是 <code>nil</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc zeroPointer() &#123;\n\tx :&#x3D; &quot;这两周小组作业怎么这么多&quot;\n\tvar ptr *string\n\tfmt.Println(&quot;ptr is &quot;, ptr)\n\tptr &#x3D; &amp;x\n\tfmt.Println(&quot;ptr is &quot;, ptr)\n&#125;\nfunc main() &#123;\n\t&#x2F;&#x2F;...\n\tzeroPointer()\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/e3803abde47d4ba6bc8fec7dacde3d25.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"函数传递指针参数\"><a href=\"#函数传递指针参数\" class=\"headerlink\" title=\"函数传递指针参数\"></a>函数传递指针参数</h3><p>在函数中对指针参数所做的修改，在函数返回后会保存相应的修改。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n)\n\nfunc changeByPointer(value *int) &#123;\n\t*value &#x3D; 200\n&#125;\n\nfunc main() &#123;\n\tx3 :&#x3D; 99\n\tp3 :&#x3D; &amp;x3\n\tfmt.Println(&quot;执行changeByPointer函数之前p3是&quot;, *p3)\n\tchangeByPointer(p3)\n\tfmt.Println(&quot;执行changeByPointer函数之后p3是&quot;, *p3)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/b1a76911892c4f2698a36664646e3b03.png\" alt=\"在这里插入图片描述\"></p>\n<p>运行程序输出如上，函数传入的是指针参数，即内存地址，所以在函数内的修改是在内存地址上的修改，在函数执行后还会保留结果。</p>\n<h3 id=\"指针与切片\"><a href=\"#指针与切片\" class=\"headerlink\" title=\"指针与切片\"></a>指针与切片</h3><p>切片与指针一样是引用类型，如果我们想通过一个函数改变一个数组的值，可以将该数组的切片当作参数传给函数，也可以将这个数组的指针当作参数传给函数。但 Go 中建议使用第一种方法，即将该数组的切片当作参数传给函数，因为这么写更加简洁易读。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; 使用切片\nfunc changeSlice(value []int) &#123;\n\tvalue[0] &#x3D; 200\n&#125;\n\n&#x2F;&#x2F; 使用数组指针\nfunc changeArray(value *[3]int) &#123;\n\t(*value)[0] &#x3D; 200\n&#125;\n\nfunc main() &#123;\n\tx :&#x3D; [3]int&#123;10, 20, 30&#125;\n\tchangeSlice(x[:])\n\tfmt.Println(x) &#x2F;&#x2F; [200 20 30]\n\n\ty :&#x3D; [3]int&#123;100, 200, 300&#125;\n\tchangeArray(&amp;y)\n\tfmt.Println(y) &#x2F;&#x2F; [200 200 300]\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/d38d6aa669a84616b05ff15eb5d472b1.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"Go-中不支持指针运算\"><a href=\"#Go-中不支持指针运算\" class=\"headerlink\" title=\"Go 中不支持指针运算\"></a>Go 中不支持指针运算</h3><p>学过 C 语言的人肯定知道在 C 中支持指针的运算，例如：<code>p++</code> ，但这在 Go 中是不支持的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nfunc main() &#123;\n\tx :&#x3D; [...]int&#123;20, 30, 40&#125;\n\tp :&#x3D; &amp;x\n\tp++ &#x2F;&#x2F; error\n&#125;</code></pre>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><p><strong>结构体(struct)</strong> 是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。学过 C 或 C++ 的人都知道结构体，但在 Go 中，没有像 C++ 中的 <code>class</code> 类的概念，只有 <code>struct</code> 结构体的概念，所以也没有继承。</p>\n<h3 id=\"结构体的声明\"><a href=\"#结构体的声明\" class=\"headerlink\" title=\"结构体的声明\"></a>结构体的声明</h3><p>在 Go 语言 中使用下面的语法是对结构体的声明。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ntype struct_name struct &#123;\n    attribute_name1   attribute_type\n    attribute_name2   attribute_type\n    ...\n&#125;</code></pre>\n<p>例如下面是定义一个名为 <code>Lesson(课程)</code> 的结构体。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ntype Lesson struct &#123;\n\tname   string &#x2F;&#x2F;名称\n\ttarget string &#x2F;&#x2F;学习目标\n\tspend  int    &#x2F;&#x2F;学习花费时间\n&#125;</code></pre>\n<p>上面的代码声明了一个结构体类型 <code>Lesson</code> ，它有 <code>name</code> 、 <code>target</code> 和 <code>spend</code> 三个属性。可以把相同类型的属性声明在同一行，这样可以使结构体变得更加紧凑，如下面的代码所示。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ntype Lesson2 struct &#123;\n    name, target    string\n    spend             int\n&#125;</code></pre>\n<p>上面的结构体 <code>Lesson</code> 称为 <strong>命名的结构体(Named Structure)</strong> 。我们创建了名为 <code>Lesson</code> 的新类型，而它可以用于创建 <code>Lesson</code> 类型的结构体变量。</p>\n<p>声明结构体时也可以不用声明一个新类型，这样的结构体类型称为 <strong>匿名结构体(Anonymous Structure)</strong> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nvar Lesson3 struct &#123;\n    name, target    string\n    spend             int\n&#125;</code></pre>\n<p>上面的代码创建了一个匿名结构体 <code>lesson</code> 。</p>\n<h3 id=\"创建命名的结构体\"><a href=\"#创建命名的结构体\" class=\"headerlink\" title=\"创建命名的结构体\"></a>创建命名的结构体</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Lesson struct &#123;\n\tname, target    string\n\tspend             int\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 使用字段名创建结构体\n\tlesson1 :&#x3D; Lesson&#123;\n\t\tname: &quot;《森林树》&quot;,\n\t\ttarget: &quot;森林会记住一切&quot;,\n\t\tspend:  5,\n\t&#125;\n\t&#x2F;&#x2F; 不使用字段名创建结构体\n\tlesson2 :&#x3D; Lesson&#123;&quot;《森林书》&quot;, &quot;有点饿了&quot;, 5&#125;\n\n\tfmt.Println(&quot;lesson1 &quot;, lesson1)\n\tfmt.Println(&quot;lesson2 &quot;, lesson2)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/9036142aca8c4c9badcf3aa5d5fb168c.png\" alt=\"在这里插入图片描述\"></p>\n<p>上面的例子使用了两种方法创建了结构体，第一种是在创建结构体时使用字段名对每个字段进行初始化，而第二种方法是在创建结构体时不使用字段名，直接按字段声明的顺序对字段进行初始化。</p>\n<h3 id=\"创建匿名结构体\"><a href=\"#创建匿名结构体\" class=\"headerlink\" title=\"创建匿名结构体\"></a>创建匿名结构体</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 创建匿名结构体变量\n\tlesson3 :&#x3D; struct &#123;\n\t\tname, target string\n\t\tspend          int\n\t&#125;&#123;\n\t\tname:   &quot;水天供书&quot;,\n\t\ttarget: &quot;大大铁块不懂道理，兰百梨迦就让它懂道理&quot;,\n\t\tspend:   3,\n\t&#125;\n\n\tfmt.Println(&quot;lesson3 &quot;, lesson3)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/c416bd13f6fc4f8eabef65545eed199f.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"结构体的零值-Zero-Value\"><a href=\"#结构体的零值-Zero-Value\" class=\"headerlink\" title=\"结构体的零值(Zero Value)\"></a>结构体的零值(Zero Value)</h3><p>当定义好的结构体没有被显式初始化时，结构体的字段将会默认赋为相应类型的零值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\ntype Lesson struct &#123;\n\tname, target    string\n\tspend             int\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 不初始化结构体\n\tvar lesson4 &#x3D; Lesson&#123;&#125;\n\n\tfmt.Println(&quot;lesson4 &quot;, lesson4)\n&#125;</code></pre>\n<h3 id=\"初始化结构体\"><a href=\"#初始化结构体\" class=\"headerlink\" title=\"初始化结构体\"></a>初始化结构体</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\ntype Lesson struct &#123;\n\tname, target    string\n\tspend             int\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 为结构体指定字段赋初值\n\tvar lesson5 &#x3D; Lesson&#123;\n\t\tname: &quot;正法炬书&quot;,\n\t\ttarget: &quot;森林会记住一切&quot;,\n\t&#125;\n\n    &#x2F;&#x2F; 上面的结构体变量 lesson5 只初始化了 name 和 target 字段, spend字段没有初始化,所以会被初始化为零值\n\tfmt.Println(&quot;lesson5 &quot;, lesson5)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/643c1bb7daeb4646933fb7ce1cada2dc.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"访问结构体的字段\"><a href=\"#访问结构体的字段\" class=\"headerlink\" title=\"访问结构体的字段\"></a>访问结构体的字段</h3><p>点操作符 <code>.</code> 用于访问结构体的字段。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Person struct &#123;\n\tname, gender    string\n\tage             int\n&#125;\n\nfunc main() &#123;\n\tvar lesson6 &#x3D; Lesson&#123;\n\t\tname: &quot;森林书&quot;,\n\t\ttarget: &quot;森林与树的孩子们&quot;,\n\t\tspend: 50,\n\t&#125;\n\n\tfmt.Println(&quot;lesson6 name: &quot;, lesson6.name)\n\tfmt.Println(&quot;lesson6 target: &quot;, lesson6.target)\n\tfmt.Println(&quot;lesson6 spend: &quot;, lesson6.spend)\n&#125;</code></pre>\n<p>当然，使用点操作符 <code>.</code> 可以用于对结构体的字段的赋值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Lesson struct &#123;\n\tname, target    string\n\tspend             int\n&#125;\n\nfunc main() &#123;\n\tvar lesson7 &#x3D; Lesson&#123;&#125;\n\tlesson7.name &#x3D; &quot;从0到Go语言微服务架构师&quot;\n\tlesson7.target &#x3D; &quot;全面掌握Go语言微服务如何落地，代码级彻底一次性解决微服务和分布式系统。&quot;\n\tlesson7.spend &#x3D; 50\n\tfmt.Println(&quot;lesson7 &quot;, lesson7)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/af9e631b10704958a4688c65f484a153.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"指向结构体的指针\"><a href=\"#指向结构体的指针\" class=\"headerlink\" title=\"指向结构体的指针\"></a>指向结构体的指针</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Lesson struct &#123;\n\tname, target    string\n\tspend             int\n&#125;\n\nfunc main() &#123;\n\tlesson8 :&#x3D; &amp;Lesson&#123;&quot;无留陀&quot;, &quot;失落的苗圃&quot;, 50&#125;\n\tfmt.Println(&quot;lesson8 name: &quot;, (*lesson8).name)\n\tfmt.Println(&quot;lesson8 name: &quot;, lesson8.name)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/60956e65fa224d2e85da17c1883e0b8a.png\" alt=\"在这里插入图片描述\"></p>\n<p>在上面的程序中， <code>lesson8</code> 是一个指向结构体 <code>Lesson</code> 的指针，上面用 <code>(*lesson8).name</code> 访问 <code>lesson8</code> 的 <code>name</code> 字段，上面的 <code>lesson8.name</code> 代替 <code>(*lesson8).name</code> 的解引用访问。</p>\n<ul>\n<li>注意：学过 C 语言的同学会认为<code>lesson8-&gt;name</code>才是正确的访问形式，但是在 Go 语言中，没有-&gt;访问的形式，访问结构体中的字段统一都是用<code>.</code>操作符</li>\n</ul>\n<h3 id=\"匿名字段\"><a href=\"#匿名字段\" class=\"headerlink\" title=\"匿名字段\"></a>匿名字段</h3><p>在创建结构体时，字段可以只有类型没有字段名，这种字段称为 <strong>匿名字段(Anonymous Field)</strong> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Lesson4 struct &#123;\n\tstring\n\tint\n&#125;\n\nfunc main() &#123;\n\tlesson9 :&#x3D; Lesson4&#123;&quot;祖拜尔剧场&quot;, 50&#125;\n\tfmt.Println(&quot;lesson9 &quot;, lesson9)\n\tfmt.Println(&quot;lesson9 string: &quot;, lesson9.string)\n\tfmt.Println(&quot;lesson9 int: &quot;, lesson9.int)\n&#125;</code></pre>\n<p>上面的程序结构体定义了两个匿名字段，虽然这两个字段没有字段名，但匿名字段的名称默认就是它的类型。所以上面的结构体 <code>Lesoon4</code> 有两个名为 <code>string</code> 和 <code>int</code> 的字段。</p>\n<h3 id=\"嵌套结构体\"><a href=\"#嵌套结构体\" class=\"headerlink\" title=\"嵌套结构体\"></a>嵌套结构体</h3><p>结构体的字段也可能是另外一个结构体，这样的结构体称为 <strong>嵌套结构体(Nested Structs)</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Author struct &#123;\n\tname string\n  \twx string\n&#125;\n\ntype Lesson5 struct &#123;\n\tname,target string\n\tspend int\n\tauthor Author\n&#125;\n\nfunc main() &#123;\n\tlesson10 :&#x3D; Lesson5&#123;\n\t\tname: &quot;赛诺&quot;,\n\t\tspend: 50,\n\t&#125;\n\tlesson10.author &#x3D; Author&#123;\n\t\tname: &quot;妮露&quot;,\n\t\twx: &quot;write_code_666&quot;,\n\t&#125;\n\tfmt.Println(&quot;lesson10 name:&quot;, lesson10.name)\n\tfmt.Println(&quot;lesson10 spend:&quot;, lesson10.spend)\n\tfmt.Println(&quot;lesson10 author name:&quot;, lesson10.author.name)\n\tfmt.Println(&quot;lesson10 author wx:&quot;, lesson10.author.wx)\n&#125;</code></pre>\n<p>上面的程序 <code>Lesson5</code> 结构体有一个字段 <code>author</code> ，而且它的类型也是一个结构体 <code>Author</code> 。</p>\n<h3 id=\"提升字段\"><a href=\"#提升字段\" class=\"headerlink\" title=\"提升字段\"></a>提升字段</h3><p>结构体中如果有匿名的结构体类型字段，则该匿名结构体里的字段就称为 <strong>提升字段(Promoted Fields)</strong> 。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。就像刚刚上面的程序，如果我们把 <code>Lesson</code> 结构体中的字段 <code>author</code> 直接用匿名字段 <code>Author</code> 代替， <code>Author</code> 结构体的字段例如 <code>name</code> 就不用像上面那样使用 <code>lesson10.author.wx</code> 访问，而是使用 <code>lesson10.wx</code> 就能访问 <code>Author</code> 结构体中的 <code>wx</code> 字段。现在结构体 <code>Author</code> 有 <code>name</code> 、 <code>wx</code> 两个字段，访问字段就像在 <code>Lesson</code> 里直接声明的一样，因此我们称之为提升字段。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Author struct &#123;\n\tname string\n  \twx string\n&#125;\n\ntype Lesson6 struct &#123;\n\tname,target string\n\tspend int\n\tAuthor\n&#125;\n\nfunc main() &#123;\n\tlesson10 :&#x3D; Lesson6&#123;\n\t\tname:   &quot;赛诺&quot;,\n\t\ttarget: &quot;大风纪官&quot;,\n\t&#125;\n\tlesson10.author &#x3D; Author&#123;\n\t\tname: &quot;艾尔海森&quot;,\n\t\twx:   &quot;write_code_666&quot;,\n\t&#125;\n\tfmt.Println(&quot;lesson10 name:&quot;, lesson10.name)\n\tfmt.Println(&quot;lesson10 target:&quot;, lesson10.target)\n\tfmt.Println(&quot;lesson10 author wx:&quot;, lesson10.wx)\n&#125;</code></pre>\n<h3 id=\"结构体比较\"><a href=\"#结构体比较\" class=\"headerlink\" title=\"结构体比较\"></a>结构体比较</h3><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 <code>==</code> 或 <code>!=</code> 运算符进行比较。可以通过==运算符或 DeeplyEqual()函数比较两个结构相同的类型并包含相同的字段值。因此下面两个比较的表达式是等价的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype  Lesson  struct&#123;\n\tname,target string\n\tspend int\n&#125;\n\nfunc main() &#123;\n\tlesson11 :&#x3D; Lesson&#123;\n\t\tname:   &quot;赛诺&quot;,\n\t\ttarget: &quot;大风纪官&quot;,\n\t&#125;\n\tlesson12 :&#x3D; Lesson&#123;\n\t\tname:   &quot;赛诺&quot;,\n\t\ttarget: &quot;大风纪官&quot;,\n\t&#125;\n\tfmt.Println(lesson11.name &#x3D;&#x3D; lesson12.name &amp;&amp; lesson11.target &#x3D;&#x3D; lesson12.target) &#x2F;&#x2F; true\n\tfmt.Println(lesson11 &#x3D;&#x3D; lesson12) &#x2F;&#x2F; true\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/53c695b5bef3449fb162d46ccda54c31.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"给结构体定义方法\"><a href=\"#给结构体定义方法\" class=\"headerlink\" title=\"给结构体定义方法\"></a>给结构体定义方法</h3><p>在 Go 中无法在结构体内部定义方法，这一点与 C 语言类似。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; Lesson 定义一个名为 Lesson 的结构体\ntype Lesson struct &#123;\n\tname,target string\n\tspend int\n&#125;\n\n&#x2F;&#x2F; PrintPersonInfo 定义一个与 Person 的绑定的方法\nfunc (l Lesson) ShowLessonInfo() &#123;\n\tfmt.Println(&quot;name:&quot;, l.name)\n\tfmt.Println(&quot;target:&quot;, l.target)\n&#125;\n\nfunc main() &#123;\n\tlesson13 :&#x3D; Lesson&#123;\n\t\tname:   &quot;艾尔海森&quot;,\n\t\ttarget: &quot;教令院书记官&quot;,\n\t&#125;\n\tlesson13.ShowPersonInfo()\n&#125;</code></pre>\n<p>上面的程序中定义了一个与结构体 <code>Lesson</code> 绑定的方法 <code>ShowLessonInfo()</code> ，其中 <code>ShowLessonInfo</code> 是方法名， <code>(l Lesson)</code> 表示将此方法与 <code>Lesson</code> 的实例绑定，这在 Go 语言中称为接收者，而 <code>l</code> 表示实例本身，相当于 Python 中的 <code>self</code> ，在方法内可以使用 <code>实例本身.属性名称</code> 来访问实例属性。</p>\n<h3 id=\"方法的参数传递方式\"><a href=\"#方法的参数传递方式\" class=\"headerlink\" title=\"方法的参数传递方式\"></a>方法的参数传递方式</h3><p>如果绑定结构体的方法中要改变实例的属性时，必须使用指针作为方法的接收者。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; Lesson 定义一个名为 Lesson 的结构体\ntype Lesson struct &#123;\n\tname,target string\n\tspend int\n&#125;\n\n&#x2F;&#x2F; ShowLessonInfo 定义一个与 Lesson 的绑定的方法\nfunc (l Lesson) ShowLessonInfo() &#123;\n\tfmt.Println(&quot;name:&quot;, l.name)\n\tfmt.Println(&quot;target:&quot;, l.target)\n&#125;\n\n&#x2F;&#x2F; AddTime 定义一个与 Lesson 的绑定的方法，使 spend 值加 n\nfunc (l *Lesson) AddTime(n int) &#123;\n\tl.spend &#x3D; l.spend + n\n&#125;\n\nfunc main() &#123;\n\tlesson13 :&#x3D; Lesson&#123;\n\t\tname:   &quot;艾尔海森&quot;,\n\t\ttarget: &quot;教令院书记官&quot;,\n    spend:50,\n\t&#125;\n\tfmt.Println(&quot;添加add方法前&quot;)\n\tlesson13.ShowLessonInfo()\n\tlesson13.AddTime(5)\n\tfmt.Println(&quot;添加add方法后&quot;)\n\tlesson13.ShowLessonInfo()\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/3d05a065f73f49d3af52e0be5ec30747.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p><strong>函数</strong> 是基于功能或逻辑进行封装的可复用的代码结构。将一段功能复杂、很长的一段代码封装成多个代码片段(即函数)，有助于提高代码可读性和可维护性。由于 Go 语言是编译型语言，所以函数编写的顺序是无关紧要的。</p>\n<h3 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h3><p>在 Go 语言中，函数声明语法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc function_name(parameter_list) (result_list) &#123;\n    &#x2F;&#x2F;函数体\n&#125;</code></pre>\n<p>函数的声明使用 <code>func</code> 关键词，后面依次接 <code>function_name(函数名)</code> ， <code>parameter_list(参数列表)</code> ， <code>result_list(返回值列表)</code> 以及 <code>函数体</code> 。</p>\n<ul>\n<li>形式参数列表:函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，函数中的参数列表和返回值并非是必须的。</li>\n<li>返回值列表:函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。</li>\n<li>如果有连续若干个参数的类型一致，那么只需在最后一个参数后添加该类型。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; 函数返回一个无名变量，返回值列表的括号省略\nfunc sum(x int, y int) int &#123;\n\treturn x + y\n&#125;\n\n&#x2F;&#x2F; 无参数列表和返回值\nfunc printBookName() &#123;\n\tfmt.Println(&quot;《森林书》&quot;)\n&#125;\n\n&#x2F;&#x2F; 参数的类型一致，只在最后一个参数后添加该类型\nfunc sub(x , y int) int &#123;\n\treturn x - y\n&#125;\n\nfunc main() &#123;\n\tfmt.Println(&quot;56 + 1 &#x3D; &quot;, sum(56, 1))\n\tprintBookName()\n\tfmt.Println(&quot;58 - 2 &#x3D;&quot;, sub(58, 2))\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/5ea9b44e54a545219e8befb3fdd89c15.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h3><p>上面的程序参数个数都是固定的，在 Go 语言 中也可以使用可变参数的函数。</p>\n<h4 id=\"多个类型一致的参数\"><a href=\"#多个类型一致的参数\" class=\"headerlink\" title=\"多个类型一致的参数\"></a>多个类型一致的参数</h4><p>在参数类型前面加 <code>...</code> 表示一个切片，用来接收调用者传入的参数。注意，如果该函数下有其他类型的参数，这些其他参数必须放在参数列表的前面，切片必须放在最后。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc show(args ...string) int &#123;\n\tsum :&#x3D; 0\n\tfor _, item :&#x3D; range args &#123;\n        fmt.Println(item)\n\t\tsum +&#x3D; 1\n\t&#125;\n\treturn sum\n&#125;\n\nfunc main() &#123;\n\tfmt.Println(show(&quot;兰&quot;,&quot;那&quot;,&quot;罗&quot;))\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/7cbdd41f9d114bde839d6aa220a23c93.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"多个类型不一致的参数\"><a href=\"#多个类型不一致的参数\" class=\"headerlink\" title=\"多个类型不一致的参数\"></a>多个类型不一致的参数</h4><p>如果传多个参数的类型都不一样，可以指定类型为 <code>...interface&#123;&#125;</code> ，然后再遍历。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc PrintType(args ...interface&#123;&#125;) &#123;\n\tfor _, arg :&#x3D; range args &#123;\n\t\tswitch arg.(type) &#123;\n\t\tcase int:\n\t\t\tfmt.Println(arg, &quot;type is int.&quot;)\n\t\tcase string:\n\t\t\tfmt.Println(arg, &quot;type is string.&quot;)\n\t\tcase float64:\n\t\t\tfmt.Println(arg, &quot;type is float64.&quot;)\n\t\tdefault:\n\t\t\tfmt.Println(arg, &quot;is an unknown type.&quot;)\n\t\t&#125;\n\t&#125;\n&#125;\n\nfunc main() &#123;\n\tPrintType(57, 3.14, &quot;兰那罗&quot;)\n&#125;</code></pre>\n<h3 id=\"解序列\"><a href=\"#解序列\" class=\"headerlink\" title=\"解序列\"></a>解序列</h3><p>使用 <code>...</code> 可以用来解序列，能将函数的可变参数(即切片)一个一个取出来，传递给另一个可变参数的函数，而不是传递可变参数变量本身。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tvar s []string\n\ts &#x3D; append(s, []string&#123;&quot;兰&quot;, &quot;那&quot;, &quot;罗&quot;&#125;...)\n\tfmt.Println(s)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/dd24e01a63924820b672ef47d172709c.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"函数的返回值\"><a href=\"#函数的返回值\" class=\"headerlink\" title=\"函数的返回值\"></a>函数的返回值</h3><p>当函数没有返回值时，函数体可以使用 <code>return</code> 语句返回。在 Go 中一个函数可以返回多个值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc showBookInfo(bookName, authorName string) (string, error) &#123;\n\tif bookName &#x3D;&#x3D; &quot;&quot; &#123;\n\t\treturn &quot;&quot;, errors.New(&quot;图书名称为空&quot;)\n\t&#125;\n\tif authorName &#x3D;&#x3D; &quot;&quot; &#123;\n\t\treturn &quot;&quot;, errors.New(&quot;作者名称为空&quot;)\n\t&#125;\n\treturn bookName + &quot;,作者:&quot; + authorName, nil\n&#125;\n\nfunc main() &#123;\n\tbookInfo, err :&#x3D; showBookInfo(&quot;《千朵玫瑰带来的黎明》&quot;, &quot;须弥&quot;)\n\tfmt.Printf(&quot;bookInfo &#x3D; %s, err &#x3D; %v&quot;, bookInfo, err)\n&#125;</code></pre>\n<p>当然，在 Go 中支持返回带有变量名的值。可以将上面的函数修改如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc showBookInfo2(bookName, authorName string) (info string, err error) &#123;\n\tinfo &#x3D; &quot;&quot;\n\tif bookName &#x3D;&#x3D; &quot;&quot; &#123;\n\t\terr &#x3D; errors.New(&quot;图书名称为空&quot;)\n\t\treturn\n\t&#125;\n\tif authorName &#x3D;&#x3D; &quot;&quot; &#123;\n\t\terr &#x3D; errors.New(&quot;作者名称为空&quot;)\n\t\treturn\n\t&#125;\n    &#x2F;&#x2F; 不使用 :&#x3D; 因为已经在返回值那里声明了\n\tinfo &#x3D; bookName + &quot;,作者:&quot; + authorName\n  \t&#x2F;&#x2F; 直接返回即可\n\treturn\n&#125;</code></pre>\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><p>没有名字的函数就叫 <strong>匿名函数</strong> ，它只有函数逻辑体，而没有函数名。匿名函数只拥有短暂的生命，一般都是定义后立即使用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc (parameter_list) (result_list) &#123;\n\tbody\n&#125;</code></pre>\n<h3 id=\"内部方法与外部方法\"><a href=\"#内部方法与外部方法\" class=\"headerlink\" title=\"内部方法与外部方法\"></a>内部方法与外部方法</h3><p>在 Go 语言中，函数名通过首字母大小写实现控制对方法的访问权限。</p>\n<ul>\n<li>当方法的首字母为 <strong>大写</strong> 时，这个方法对于 <strong>所有包</strong> 都是 <strong>Public</strong> ，其他包可以随意调用。</li>\n<li>当方法的首字母为 <strong>小写</strong> 时，这个方法是 <strong>Private</strong> ，其他包是无法访问的。</li>\n</ul>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p><strong>包(package)</strong> 用于组织 Go 源代码，提供了更好的可重用性与可读性。Go 语言有超过 100 个的标准包，可以用 <code>go list std | wc -l</code> 命令查看标准包的具体数目，标准库为大多数的程序提供了必要的基础组件。</p>\n<h3 id=\"main-包\"><a href=\"#main-包\" class=\"headerlink\" title=\"main 包\"></a>main 包</h3><p>首先，我们先来看看 <code>main</code> 包，该包中包含一个 <code>main()</code> 函数，该函数是程序运行的入口。</p>\n<p><code>package packagename</code> 代码指定了某一源文件属于某一个包。它应该放在每一个源文件的第一行。例如我们 Go 的第一个程序。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; hello go\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    fmt.Println(&quot;《千朵玫瑰带来的黎明》&quot;)\n&#125;</code></pre>\n<p><code>package main</code> 这一行指定该文件属于 <code>main</code> 包。<code>import &quot;fmt&quot;</code> 语句用于导入一个已存在的名为 <code>fmt</code> 的包。</p>\n<h3 id=\"创建包\"><a href=\"#创建包\" class=\"headerlink\" title=\"创建包\"></a>创建包</h3><p>下面我们创建自定义的 <code>book</code> 包，其中，属于某一个包的源文件都应该放置于一个单独命名的文件夹里，按照 Go 的惯例，应该用包名命名该文件夹。所以应当先创建一个 <code>book</code> 文件夹，位于该目录下创建一个 <code>book.go</code> 源文件，里面实现我们自定义的数学加法函数。请注意函数名的首字母要大写。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; book.go\npackage book\n\nfunc ShowBookInfo(bookName, authorName string) (string, error) &#123;\n\tif bookName &#x3D;&#x3D; &quot;&quot; &#123;\n\t\treturn &quot;&quot;, errors.New(&quot;图书名称为空&quot;)\n\t&#125;\n\tif authorName &#x3D;&#x3D; &quot;&quot; &#123;\n\t\treturn &quot;&quot;, errors.New(&quot;作者名称为空&quot;)\n\t&#125;\n\treturn bookName + &quot;,作者:&quot; + authorName, nil\n&#125;</code></pre>\n<p>Tips：</p>\n<ul>\n<li>导出名字（Exported Names)<ul>\n<li>我们将 <code>book</code> 包中的函数 <code>ShowBookInfo</code> 首字母大写。在 Go 中这具有特殊意义。在 Go 中，任何以大写字母开头的变量或者函数都是被导出的名字。其它包只能访问被导出的函数和变量。在这里，我们需要在 <code>main</code> 包中访问 <code>ShowBookInfo</code> 函数，因此会将它们的首字母大写。</li>\n<li>如果在 <code>book.go</code> 中将函数名从 <code>ShowBookInfo</code> 变为 <code>showBookInfo</code> ，并且在 <code>main.go</code> 中调用 <code>book.showBookInfo</code> 函数，则该程序编译不通过。因为如果想在包外访问一个函数，它应该首字母大写。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"导入包\"><a href=\"#导入包\" class=\"headerlink\" title=\"导入包\"></a>导入包</h3><p>使用包之前我们需要导入包，在 GoLand 中会帮你自动导入所需要的包。导入包的语法为 <code>import path</code> ，其中 <code>path</code> 可以是相对于工作区文件夹的相对路径，也可以是绝对路径。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;book&quot;\n)\n\nfunc main() &#123;\n\tbookName :&#x3D; &quot;《千朵玫瑰带来的黎明》&quot;\n\tauthor :&#x3D; &quot;须弥&quot;\n\tbookInfo, _ :&#x3D; book.ShowBookInfo(bookName, author)\n\tfmt.Println(&quot;bookInfo &#x3D; &quot;, bookInfo)\n&#125;</code></pre>\n<p>导入包可以单行导入也可以多行导入，像上面的程序代码就是多行导入的例子，一般我们也建议使用多行导入，当然你也可以使用单行导入：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nimport &quot;fmt&quot;\nimport &quot;book&quot;</code></pre>\n<h3 id=\"使用别名\"><a href=\"#使用别名\" class=\"headerlink\" title=\"使用别名\"></a>使用别名</h3><p>如果我们导入了两个具有同一包名的包时会产生冲突，这时我们可以为其中一个包定义别名：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nimport (\n    &quot;crypto&#x2F;rand&quot;\n    mrand &quot;math&#x2F;rand&quot; &#x2F;&#x2F; 将名称替换为 mrand 避免冲突\n)</code></pre>\n<p>当然，我们也可以使用别名代替名字很长的包名。</p>\n<h3 id=\"使用点操作\"><a href=\"#使用点操作\" class=\"headerlink\" title=\"使用点操作\"></a>使用点操作</h3><p>导入一个包后，如果要使用该包中的函数，都要使用 <code>包名.方法名</code> 语法进行调用，对于一些使用高频的包，例如 <code>fmt</code> 包，每次调用打印函数时都要使用 <code>fmt.Println()</code> 进行调用，很不方便。我们可以在导入包的时，使用 <code>import . package_path</code> 语法。从此，我们打印再也不用加 <code>fmt</code> 了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nimport . &quot;fmt&quot;\n\nfunc main() &#123;\n    Println(&quot;hello, world&quot;)\n&#125;</code></pre>\n<p>但这种用法，会有一定的隐患，就是导入的包里可能有函数，会和我们自己的函数发生冲突。</p>\n<h3 id=\"包的初始化\"><a href=\"#包的初始化\" class=\"headerlink\" title=\"包的初始化\"></a>包的初始化</h3><p>每个包都允许有一个或多个 <code>init</code> 函数， <code>init</code> 函数不应该有任何返回值类型和参数，在代码中也不能显式调用它，当这个包被导入时，就会执行这个包的 <code>init</code> 函数，做初始化任务， <code>init</code> 函数优先于 <code>main</code> 函数执行。该函数形式如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc init() &#123;\n&#125;</code></pre>\n<p>包的初始化顺序：首先初始化 <strong>包级别(Package Level)</strong> 的变量，紧接着调用 <code>init</code> 函数。包可以有多个 <code>init</code> 函数(在一个文件或分布于多个文件中)，它们按照编译器解析它们的顺序进行调用。如果一个包导入了另一个包，会先初始化被导入的包。尽管一个包可能会被导入多次，但是它只会被初始化一次。</p>\n<h3 id=\"包的匿名导入\"><a href=\"#包的匿名导入\" class=\"headerlink\" title=\"包的匿名导入\"></a>包的匿名导入</h3><p>之前说过，导入一个没有使用的包编译会报错。但有时候我们只是想执行包里的 <code>init</code> 函数来执行一些初始化任务的话应该怎么办呢？</p>\n<p>我们可以使用匿名导入的方法，使用 <strong>空白标识符(Blank Identifier)</strong> ：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nimport _ &quot;fmt&quot;</code></pre>\n<p>由于导入时会执行该包里的 <code>init</code> 函数，所以编译仍会将此包编译到可执行文件中。</p>\n<h2 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h2><p>所谓流程控制就是指“程序怎么执行”或者说“程序执行的顺序”。程序整体上确实是从上往下执行，但又不单纯是从上往下。<br>流程控制可分为三类：</p>\n<ol>\n<li>顺序执行。这个非常简单，就是先执行第一行再执行第二行……这样依次从上往下执行。</li>\n<li>选择执行。有些代码可以跳过不执行，有选择地执行某些代码。</li>\n<li>循环执行。有些代码会反复执行。</li>\n</ol>\n<h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><p>在 Go 中 <strong>条件语句模型</strong> 如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nif 条件1 &#123;\n  逻辑代码1\n&#125; else if  条件2 &#123;\n  逻辑代码2\n&#125; else if 条件 ... &#123;\n  逻辑代码 ...\n&#125; else &#123;\n  逻辑代码 else\n&#125;</code></pre>\n<p>如果分支的 <code>condition</code> 为真，则执行该分支 <code>&#123;</code> 和 <code>&#125;</code> 之间的代码。在 Go 中，对于 <code>&#123;</code> 和 <code>&#125;</code> 的位置有严格的要求，它要求 <code>else if</code> (或 <code>else</code> ) 和两边的花括号，必须在同一行。特别注意，即使在 <code>&#123;</code> 和 <code>&#125;</code> 之间只有一条语句，这两个花括号也是不能省略的。</p>\n<ul>\n<li><p><strong>单分支判断</strong></p>\n<p>只有一个 <code>if</code> 为单分支判断：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nscore :&#x3D; 88\nif score &gt;&#x3D; 60 &#123;\n    fmt.Println(&quot;成绩及格&quot;)\n&#125;</code></pre>\n</li>\n<li><p><strong>双分支判断</strong></p>\n<p>有 <code>if</code> 和一个 <code>else</code> 为两分支判断：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nscore :&#x3D; 88\nif score &gt;&#x3D; 60 &#123;\n    fmt.Println(&quot;成绩及格&quot;)\n&#125; else &#123;\n    fmt.Println(&quot;成绩不及格&quot;)\n&#125;</code></pre>\n</li>\n<li><p><strong>多分支判断</strong></p>\n<p>有 <code>if</code> 、 <code>else if</code> 以及 <code>else</code> 为多分支判断：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nscore :&#x3D; 88\nif score &gt;&#x3D; 90 &#123;\n    fmt.Println(&quot;成绩等级为A&quot;)\n&#125; else if score &gt;&#x3D; 80 &#123;\n    fmt.Println(&quot;成绩等级为B&quot;)\n&#125; else if score &gt;&#x3D; 70 &#123;\n    fmt.Println(&quot;成绩等级为C&quot;)\n&#125; else if score &gt;&#x3D; 60 &#123;\n    fmt.Println(&quot;成绩等级为D&quot;)\n&#125; else &#123;\n    fmt.Println(&quot;成绩等级为E 成绩不及格&quot;)\n&#125;</code></pre>\n</li>\n<li><p><strong>条件语句高级写法</strong></p>\n<p><code>if</code> 还有另外一种写法，它包含一个 <code>statement</code> 可选语句部分，该可选语句在条件判断之前运行。它的语法是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nif statement; condition &#123;\n&#125;</code></pre>\n<p>上面单分支判断的那个例子可以重写如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nif score :&#x3D; 88; score &gt;&#x3D; 60 &#123;\n    fmt.Println(&quot;成绩及格&quot;)\n&#125;</code></pre>\n</li>\n</ul>\n<h3 id=\"选择语句\"><a href=\"#选择语句\" class=\"headerlink\" title=\"选择语句\"></a>选择语句</h3><p>在 Go <strong>选择语句模型</strong> 如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nswitch 表达式 &#123;\n    case 表达式值1:\n        业务逻辑代码1\n    case 表达式值2:\n        业务逻辑代码2\n    case 表达式值3:\n        业务逻辑代码3\n    case 表达式值 ...:\n        业务逻辑代码 ...\n    default:\n        业务逻辑代码\n&#125;</code></pre>\n<p><code>switch</code> 语句是一个选择语句，用于将 <code>switch</code> 后的表达式的值与可能匹配的选项 <code>case</code> 后的表达式进行比较，并根据匹配情况执行相应的代码块，执行完匹配的代码块后，直接退出 <code>switch-case</code> 。如果没有任何一个匹配，就会执行 <code>default</code> 的代码块。它可以被认为是替代多个 <code>if-else</code> 子句的常用方式。注意：<code>case</code> 不允许出现重复项。例如，下面的例子会输出 <code>Your score is between 80 and 90.</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ngrade :&#x3D; &quot;B&quot;\nswitch grade &#123;\ncase &quot;A&quot;:\n    fmt.Println(&quot;Your score is between 90 and 100.&quot;)\ncase &quot;B&quot;:\n    fmt.Println(&quot;Your score is between 80 and 90.&quot;)\ncase &quot;C&quot;:\n    fmt.Println(&quot;Your score is between 70 and 80.&quot;)\ncase &quot;D&quot;:\n    fmt.Println(&quot;Your score is between 60 and 70.&quot;)\ndefault:\n    fmt.Println(&quot;Your score is below 60.&quot;)\n&#125;</code></pre>\n<ul>\n<li><p><strong>一个 case 多个条件</strong></p>\n<p>在 Go 中， <code>case</code> 后可以接多个条件，多个条件之间是 <strong>或</strong> 的关系，用逗号 <code>,</code> 相隔。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nmonth :&#x3D; 5\nswitch month &#123;\ncase 1, 3, 5, 7, 8, 10, 12:\n    fmt.Println(&quot;该月份有 31 天&quot;)\ncase 4, 6, 9, 11:\n    fmt.Println(&quot;该月份有 30 天&quot;)\ncase 2:\n    fmt.Println(&quot;该月份闰年为 29 天，非闰年为 28 天&quot;)\ndefault:\n    fmt.Println(&quot;输入有误！&quot;)\n&#125;</code></pre>\n</li>\n<li><p><strong>选择语句高级写法</strong></p>\n<p><code>switch</code> 还有另外一种写法，它包含一个 <code>statement</code> 可选语句部分，该可选语句在表达式之前运行。它的语法是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nswitch statement; expression &#123;\n&#125;</code></pre>\n<p>可以将上面的例子改写为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nswitch month :&#x3D; 5; month &#123;\ncase 1, 3, 5, 7, 8, 10, 12:\n    fmt.Println(&quot;该月份有 31 天&quot;)\ncase 4, 6, 9, 11:\n    fmt.Println(&quot;该月份有 30 天&quot;)\ncase 2:\n    fmt.Println(&quot;该月份闰年为 29 天，非闰年为 28 天&quot;)\ndefault:\n    fmt.Println(&quot;输入有误！&quot;)\n&#125;</code></pre>\n<p>这里 <code>month</code> 变量的作用域就仅限于这个 <code>switch</code> 内。</p>\n</li>\n<li><p><strong>switch 后可接函数</strong></p>\n<p><code>switch</code> 后面可以接一个函数，只要保证 <code>case</code> 后的值类型与函数的返回值一致即可。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc getResult(args ...int) bool &#123;\n for _, v :&#x3D; range args &#123;\n  if v &lt; 60 &#123;\n   return false\n  &#125;\n &#125;\n return true\n&#125;\n\nfunc main() &#123;\n chinese :&#x3D; 88\n math :&#x3D; 90\n english :&#x3D; 95\n\n switch getResult(chinese, math, english) &#123;\n case true:\n  fmt.Println(&quot;考试通过&quot;)\n case false:\n  fmt.Println(&quot;考试未通过&quot;)\n &#125;\n&#125;</code></pre>\n</li>\n<li><p><strong>无表达式的 switch</strong></p>\n<p><code>switch</code> 后面的表达式是可选的。如果省略该表达式，则表示这个 <code>switch</code> 语句等同于 <code>switch true</code> ，并且每个 <code>case</code> 表达式都被认定为有效，相应的代码块也会被执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nscore :&#x3D; 88\nswitch &#123;\ncase score &gt;&#x3D; 90 &amp;&amp; score &lt;&#x3D; 100:\n    fmt.Println(&quot;grade A&quot;)\ncase score &gt;&#x3D; 80 &amp;&amp; score &lt; 90:\n    fmt.Println(&quot;grade B&quot;)\ncase score &gt;&#x3D; 70 &amp;&amp; score &lt; 80:\n    fmt.Println(&quot;grade C&quot;)\ncase score &gt;&#x3D; 60 &amp;&amp; score &lt; 70:\n    fmt.Println(&quot;grade D&quot;)\ncase score &lt; 60:\n    fmt.Println(&quot;grade E&quot;)\n&#125;</code></pre>\n<p>该 <code>switch-case</code> 语句相当于 <code>if-elseif-else</code> 语句。</p>\n</li>\n<li><p><strong>fallthrough 语句</strong></p>\n<p>正常情况下 <code>switch-case</code> 语句在执行时只要有一个 <code>case</code> 满足条件，就会直接退出 <code>switch-case</code> ，如果一个都没有满足，才会执行 <code>default</code> 的代码块。不同于其他语言需要在每个 <code>case</code> 中添加 <code>break</code> 语句才能退出。使用 <code>fallthrough</code> 语句可以在已经执行完成的 <code>case</code> 之后，把控制权转移到下一个 <code>case</code> 的执行代码中。<code>fallthrough</code> 只能穿透一层，不管你有没有匹配上，都要退出了。<code>fallthrough</code> 语句是 <code>case</code> 子句的最后一个语句。如果它出现在了 <code>case</code> 语句的中间，编译会不通过。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ns :&#x3D; &quot;森林书&quot;\nswitch &#123;\ncase s &#x3D;&#x3D; &quot;森林书&quot;:\n    fmt.Println(&quot;森林书&quot;)\n    fallthrough\ncase s &#x3D;&#x3D; &quot;正法炬书&quot;:\n    fmt.Println(&quot;正法炬书&quot;)\ncase s !&#x3D; &quot;水天供书&quot;:\n    fmt.Println(&quot;水天供书&quot;)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/f383fcba5599477c80dc8e0226c3be33.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h3><p>与C及python中用法相同</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; for 接三个表达式\nfor initialisation; condition; post &#123;\n   code\n&#125;\n\n&#x2F;&#x2F; for 接一个条件表达式\nfor condition &#123;\n   code\n&#125;\n\n&#x2F;&#x2F; for 接一个 range 表达式\nfor range_expression &#123;\n   code\n&#125;\n\n&#x2F;&#x2F; for 不接表达式\nfor &#123;\n   code\n&#125;</code></pre>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">num :&#x3D; 0\nfor num &lt; 4 &#123;\n    fmt.Println(num)\n    num++\n&#125;\n\nfor num :&#x3D; 0; num &lt; 4; num++ &#123;\n    fmt.Println(num)\n&#125;\n\nstr :&#x3D; &quot;千朵玫瑰带来的黎明&quot;\nfor index, value :&#x3D; range str&#123;\n    fmt.Printf(&quot;index %d, value %c\\n&quot;, index, value)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/9fad139251124eee867a3ead0d57f03f.png\" alt=\"在这里插入图片描述\"></p>\n","text":"第一个go程序注释package main &#x2F;&#x2F; 声明 main 包 import &quot;fmt&quot; &#x2F;&#x2F; 导入 fmt 包，打印字符串时需要用到 func main()&#123; &#x2F;&#x2F; 声明 main ...","link":"","photos":[],"count_time":{"symbolsCount":"41k","symbolsTime":"37 mins."},"categories":[{"name":"编程语言","slug":"编程语言","count":13,"path":"api/categories/编程语言.json"}],"tags":[{"name":"GO","slug":"GO","count":4,"path":"api/tags/GO.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">第一个go程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">注释</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#package%EF%BC%8C%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">package，包的创建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#import%EF%BC%8C%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">import，包的导入</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">变量与常量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">常量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">关键字</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">基础数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B4%E5%9E%8B\"><span class=\"toc-text\">整型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%AE%E7%82%B9%E5%9E%8B\"><span class=\"toc-text\">浮点型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">字符类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">布尔类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%95%B0%E5%9E%8B\"><span class=\"toc-text\">复数型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">格式化输出</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">容器类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">数组声明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">数组长度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">数组遍历</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数组是值类型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87-Slice\"><span class=\"toc-text\">切片(Slice)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87\"><span class=\"toc-text\">创建切片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F\"><span class=\"toc-text\">切片的长度和容量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%AE%E6%94%B9\"><span class=\"toc-text\">切片元素的修改</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%BD%E5%8A%A0%E5%88%87%E7%89%87%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">追加切片元素</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BB%B4%E5%88%87%E7%89%87\"><span class=\"toc-text\">多维切片</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA-Map\"><span class=\"toc-text\">创建 Map</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Map-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Map 操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map-%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">map 是引用类型</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88\"><span class=\"toc-text\">指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%8C%87%E9%92%88\"><span class=\"toc-text\">创建指针</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">指针的类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E7%9A%84%E9%9B%B6%E5%80%BC\"><span class=\"toc-text\">指针的零值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">函数传递指针参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E4%B8%8E%E5%88%87%E7%89%87\"><span class=\"toc-text\">指针与切片</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Go-%E4%B8%AD%E4%B8%8D%E6%94%AF%E6%8C%81%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">Go 中不支持指针运算</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">结构体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">结构体的声明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">创建命名的结构体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">创建匿名结构体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E9%9B%B6%E5%80%BC-Zero-Value\"><span class=\"toc-text\">结构体的零值(Zero Value)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">初始化结构体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">访问结构体的字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%8C%87%E9%92%88\"><span class=\"toc-text\">指向结构体的指针</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">匿名字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">嵌套结构体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%90%E5%8D%87%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">提升字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">结构体比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%99%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">给结构体定义方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">方法的参数传递方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">函数的声明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">可变参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9E%8B%E4%B8%80%E8%87%B4%E7%9A%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">多个类型一致的参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">多个类型不一致的参数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">解序列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">函数的返回值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">匿名函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">内部方法与外部方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85\"><span class=\"toc-text\">包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#main-%E5%8C%85\"><span class=\"toc-text\">main 包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%8C%85\"><span class=\"toc-text\">创建包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5%E5%8C%85\"><span class=\"toc-text\">导入包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D\"><span class=\"toc-text\">使用别名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%82%B9%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">使用点操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">包的初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%85%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">包的匿名导入</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">流程控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">条件语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">选择语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">循环语句</span></a></li></ol></li></ol>","author":{"name":"Algernon","slug":"blog-author","avatar":"https://user-images.githubusercontent.com/54904760/224857900-b2e8457c-43d2-46b7-901c-6c770f24bbad.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}},"mapped":true,"prev_post":{"title":"【GO语言编程】（三）","uid":"424355acc1981b780ee62e0097527e8c","slug":"GO3","date":"2022-11-03T14:55:49.000Z","updated":"2022-11-08T15:50:38.599Z","comments":true,"path":"api/articles/GO3.json","keywords":null,"cover":[],"text":"方法方法** 其实就是一个函数，在 func 这个关键字和方法名中间加入了一个特殊的接收器类型。接收器可以是结构体类型或者是非结构体类型。接收器是可以在方法的内部访问的。 GO func (t Type) methodName(parameterList) returnList&...","link":"","photos":[],"count_time":{"symbolsCount":"54k","symbolsTime":"49 mins."},"categories":[{"name":"编程语言","slug":"编程语言","count":13,"path":"api/categories/编程语言.json"}],"tags":[{"name":"GO","slug":"GO","count":4,"path":"api/tags/GO.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://user-images.githubusercontent.com/54904760/224857900-b2e8457c-43d2-46b7-901c-6c770f24bbad.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}},"next_post":{"title":"【python机器学习基础教程】(一)","uid":"a4dfed67ba141d1dc18bc0e6d1e3a85f","slug":"python机器学习1","date":"2022-11-03T14:51:49.000Z","updated":"2022-11-08T15:54:23.151Z","comments":true,"path":"api/articles/python机器学习1.json","keywords":null,"cover":[],"text":"主要使用python和scikit-learn库 必要的库和工具SciPy所有代码默认导入以下库： import numpy as np import matplotlib.pyplot as plt import pandas as pd import mglearn SciP...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"机器学习","slug":"机器学习","count":9,"path":"api/categories/机器学习.json"}],"tags":[{"name":"python","slug":"python","count":9,"path":"api/tags/python.json"},{"name":"机器学习","slug":"机器学习","count":5,"path":"api/tags/机器学习.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://user-images.githubusercontent.com/54904760/224857900-b2e8457c-43d2-46b7-901c-6c770f24bbad.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}}}