{"title":"MCM 算法整理","uid":"98617a616f5da740d44c6fdef4281028","slug":"mcm算法","date":"2022-11-03T13:51:49.000Z","updated":"2022-11-08T15:13:58.013Z","comments":true,"path":"api/articles/mcm算法.json","keywords":null,"cover":null,"content":"<h1 id=\"算法基础\"><a href=\"#算法基础\" class=\"headerlink\" title=\"算法基础\"></a>算法基础</h1><h1 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h1><p>许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。<br>这些算法典型地遵循<strong>分治法</strong>的思想：将原问题<strong>分解</strong>为几个较小但类似于原问题的子问题，递归地<strong>求解</strong>这些子问题，然后再<strong>合并</strong>这些子问题的解来建立原问题的解。</p>\n<h1 id=\"随机算法\"><a href=\"#随机算法\" class=\"headerlink\" title=\"随机算法\"></a>随机算法</h1><p>如果一个算法的行为不仅由输入决定，而且也由<strong>随机数生成器</strong>产生的数值决定，则称这个算法是<strong>随机</strong>的。<br>样例：<br>生日悖论：一个屋子里人数必须要达到多少人，才能使其中两人生日相同的机会达到50%？</p>\n<ul>\n<li>两人生日相同的概率是1/n</li>\n<li>采用指示器随机变量</li>\n<li>若屋子里至少有$\\sqrt{2n}$+1个人，我们就可以期望至少有两人生日相同。<br>对于n=365,k=28.<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1>希尔排序又称缩小增量排序法，是一种基于插入思想的排序方法。</li>\n</ul>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>对树形选择排序的改进。</p>\n<h3 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h3><p>优先队列是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个相关 的值，称为<strong>关键字</strong></p>\n<ul>\n<li>最大优先队列</li>\n<li>最小优先队列</li>\n</ul>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><h3 id=\"交换类排序\"><a href=\"#交换类排序\" class=\"headerlink\" title=\"交换类排序\"></a>交换类排序</h3><p><strong>冒泡排序</strong>（相邻排序法）<br>通过对相邻的数据元素进行交换，逐步将待排序序列变成有序序列的过程。</p>\n<ul>\n<li>最好情况划分</li>\n<li>平衡划分</li>\n<li>最坏情况分析</li>\n</ul>\n<h2 id=\"线性时间排序\"><a href=\"#线性时间排序\" class=\"headerlink\" title=\"线性时间排序\"></a>线性时间排序</h2><p>三种线性时间复杂度的排序算法：</p>\n<ul>\n<li>计数排序</li>\n<li>基数排序</li>\n<li>桶排序</li>\n</ul>\n<p><strong>决策树模型</strong><br>比较排序可以被抽象为一棵决策树。<br><strong>决策树</strong>是一棵完全二叉树，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。</p>\n<p><strong>计数排序</strong>假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。<br>计数排序的基本思想是：对每一个输入元素x，确定小于x的元素个数。</p>\n<p><strong>基数排序</strong>是先按<em>最低有效位</em>进行排序。</p>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><p>桶排序将[0,1)区间划分为n个相同大小的子区间，或称为桶。<br>然后，将n个输入数分别放到各个桶中。<br>因为输入数据是均匀、独立地分布在[0,1)区间上，所以一般不会出现很多数，落在同一个桶中的情况。为得到输出结果，对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。</p>\n<h1 id=\"中位数与顺序统计量\"><a href=\"#中位数与顺序统计量\" class=\"headerlink\" title=\"中位数与顺序统计量\"></a>中位数与顺序统计量</h1><h2 id=\"最大值与最小值\"><a href=\"#最大值与最小值\" class=\"headerlink\" title=\"最大值与最小值\"></a>最大值与最小值</h2><h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><p>线性表是n个类型相同的数据元素的有限序列。</p>\n<h3 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h3><p>在栈中，被删除的是最近插入的元素，<strong>后进后出</strong><br>压入（push）<br>弹出(pop)</p>\n<ul>\n<li>顺序存储的栈为顺序栈 </li>\n<li>链式存储的栈为链栈<br>顺序栈利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时由于栈操作的特殊性，还必须附设一个位置指针top（栈顶指针）来动态地指示栈顶元素在顺序栈中的位置。<br>空栈：top=-1</li>\n</ul>\n<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><p>递归是在定义自身的同时又出现了对自身的引用。<br>如果一个函数在定义体内直接调用自己，则称为<strong>直接递归函数</strong><br>如果一个函数经过一系列的中间调用语句，通过其他函数间接调用自己，则称为<strong>间接递归函数</strong>。</p>\n<p>递归定义函数<br>二阶斐波那契数列定义为：</p>\n<p>$Fib(n)=\\begin{cases} 0,     若n=0 \\\\1，若n=1\\\\Fib(n-1)+Fib(n-2),若n&gt;1 \\end{cases}$</p>\n<p>阿克曼函数定义为：<br>$Ack(m,n)=\\begin{cases} n+1,当m+0时 \\\\Ack(m-1,1),当m\\neq0,n=0时\\\\Ack(m-1,Ack(m,n-1),当m\\neq0,n\\neq0时 \\end{cases}$<br> 用C语言描述：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int ack(int m ,int n)\n\n&#123;\n  if(m&#x3D;&#x3D;0)\n\n        return   n+1;\n\n  else if  (n&#x3D;&#x3D;0) \n\n        return ack(m-1,1);\n\n  else\n\n        return ack(m-1,ack(m,n-1));\n\n&#125;</code></pre>\n<p><strong>n阶汉诺塔问题</strong><br>假设有三个分别命名为X,Y,Z的塔座，在塔座X上插有n个直径大小各不相同、从小到大编号为1,2，···，n的圆盘。现要求将塔座X上的n个圆盘移动到塔座Z上，并仍按同样顺序叠排。圆盘移动时必须遵守以下规则：</p>\n<ol>\n<li>每次只能移动一个圆盘</li>\n<li>圆盘可以插在X,Y和Z中的任何一个塔座上。</li>\n<li>任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。</li>\n</ol>\n<p>汉诺塔递归算法</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void hanoi(int n,char x,char y,char z)\n&#123;\n if(n&#x3D;&#x3D;1)\n         move(x,1,z)\n else\n\n   &#123;\n     hanoi(n-1,x,z,y);\n     move(x,n,z);\n     hanoi(n-1,y,x,z);\n\n   &#125;\n &#125;</code></pre>\n<p>在<strong>队列</strong>中，被删去的总是在集合中存在时间最长的那个元素，<strong>先进先出</strong><br>入队(enqueue)<br>出队(dequeue)<br>队头队尾：<br>在队列中，允许插入的一端称为队尾，允许删除的一端称为队头。<br>链队列<br>循环队列</p>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p>链表中的各对象按线性顺序排列，链表的顺序是由各个对象里的指针决定的。</p>\n<p>十字链表</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。动态规划算法对每个子子问题只求解一次，将其保存在一个表格中。<br>动态规划方法通常用来求解<strong>最优化问题</strong>。<br>最优子结构<br>如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有<strong>最优子结构性质</strong>。<br><strong>无权最短路径</strong>：找到一条从u到$\\upsilon$的边数最少的路径。这条路径必然是简单路径，因为如果路径中包含环，将环去掉显然会减少边的数量。<br><strong>无权最长路径</strong>：找到一条从u到$\\upsilon$的边数最多的简单路径。  </p>\n<p>如果递归算法反复求解相同的子问题，称最优化问题具有<strong>重叠子问题</strong>性质。</p>\n<h1 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h1><p>做出局部最优的选择，寄希望这样的选择能导致全局最优解。<br>0-1背包问题：小偷抢劫商店，背包容纳重量一定，商品重量、价值不同，求带走商品总价值最高。<br>分数背包问题：设定与上题相同，但对每个商品，小偷可以拿走其一部分，而非二元选择。<br>贪心策略：首先尽可能拿走每磅价值最高的商品，然后拿走每磅价值第二高的商品，以此类推，直到达到重量上限。<br>贪心策略可以求解分数背包问题，而不能求解0-1背包问题。<br><strong>拟阵</strong></p>\n<h1 id=\"斐波那契\"><a href=\"#斐波那契\" class=\"headerlink\" title=\"斐波那契\"></a>斐波那契</h1><h1 id=\"图算法\"><a href=\"#图算法\" class=\"headerlink\" title=\"图算法\"></a>图算法</h1><p>对于图G = (V,E),可以用两种标准表示方法表示。<br>一种表示法将图作为邻接链表的组合，另一种表示法则将图作为邻接矩阵看待。</p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><p>把满足一下两个条件的树称为<strong>二叉树</strong></p>\n<ul>\n<li>每个结点的度都不大于2</li>\n<li><p>每个结点的孩子结点次序不能任意颠倒</p>\n<p>二叉树的性质：</p>\n</li>\n<li><p>在二叉树第i层上至多有$2^{i-1}$个结点（i $\\geqq$ 1）</p>\n</li>\n<li>深度为k的二叉树至多有$2^k$-1个结点（i $\\geqq$ 1）</li>\n</ul>\n<p>二叉树的遍历<br>用L、D、R分别表示遍历左子树、访问根节点、遍历右子树，<br>按先左后右的方式，有三种：</p>\n<p><strong>先序遍历（DLR）</strong>：<br>若二叉树为空，则为空操作，否则依次执行以下三个操作：</p>\n<ol>\n<li>访问根结点</li>\n<li>按先序遍历左子树</li>\n<li>按先序遍历右子树</li>\n</ol>\n<p><strong>中序遍历（LDR）</strong>：<br>若二叉树为空，则为空操作，否则依次执行以下三个操作：</p>\n<ol>\n<li>按中序遍历左子树</li>\n<li>访问根结点</li>\n<li>按中序遍历右子树</li>\n</ol>\n<p><strong>后序遍历（LRD）</strong>：<br>若二叉树为空，则为空操作，否则依次执行以下三个操作：</p>\n<ol>\n<li>按后序遍历左子树</li>\n<li>按后序遍历右子树</li>\n<li>访问根结点</li>\n</ol>\n<h2 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h2><p><strong>路径</strong>是指从根结点到该结点的分支序列，<br><strong>路径长度</strong>是指根结点到该结点所经过的分支数目。<br>给树的每个结点赋予一个具有某种意义的实数，称该实数为这个<strong>结点的权</strong><br>在树结构中，把从树根到某一结点的路径长度与该结点的权的乘积，称为该结点的<strong>带权路径长度</strong>。</p>\n<p><strong>哈夫曼树</strong>是由n个带权叶子结点构成的所有二叉树中带权路径长度最短的二叉树。又称最优二叉树。</p>\n<h2 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h2><p>树的按层次遍历的推广。</p>\n<p>prim 的最小生成树算法<br>Dijkstra的单源最短路径算法</p>\n<h2 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索\"></a>深度优先搜索</h2><p>树的先根遍历的推广<br>强连通分量</p>\n<h2 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h2><p>最小生成树问题<br>图G=（V(G),E(G)）树T=（V(T),E’(T)）<br>在一个连通无向图G=(V, E)中，对于其中的每条边(u,v)∈E，赋予其权重w(u, v)，则最小生成树问题就是要在G中找到一个连通图G中所有顶点的无环子集T⊆E，使得这个子集中所有边的权重之和最小。<br>即生成树为一条连接所有点的路径，最小生成树为权重和最小那个生成树（非环）<br>Kruskal算法——短边优先法（避圈法）<br><strong>Prim算法</strong>——加点法</p>\n<h1 id=\"单源最短路径\"><a href=\"#单源最短路径\" class=\"headerlink\" title=\"单源最短路径\"></a>单源最短路径</h1><ul>\n<li>单目的地最短路径问题</li>\n<li>单结点对最短路径问题</li>\n<li>所有结点对最短路径问题</li>\n</ul>\n<p>Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。<br>按最短路径长度递增的顺序产生一点到其余各项点的所有最短路径。</p>\n<h1 id=\"所有结点对的最短路径\"><a href=\"#所有结点对的最短路径\" class=\"headerlink\" title=\"所有结点对的最短路径\"></a>所有结点对的最短路径</h1><p>参考资料：<br>《算法导论》<br>《数据结构》</p>\n","text":"算法基础分治法许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。这些算法典型地遵循分治法的思想：将原问题分解为几个较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。 随机算法...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"数模","slug":"数模","count":2,"path":"api/categories/数模.json"}],"tags":[{"name":"数模","slug":"数模","count":4,"path":"api/tags/数模.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">算法基础</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%B2%BB%E6%B3%95\"><span class=\"toc-text\">分治法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">随机算法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">堆排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97\"><span class=\"toc-text\">优先队列</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">快速排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">交换类排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">线性时间排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">桶排序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%8E%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F\"><span class=\"toc-text\">中位数与顺序统计量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%80%BC\"><span class=\"toc-text\">最大值与最小值</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97\"><span class=\"toc-text\">栈和队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92\"><span class=\"toc-text\">递归</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">链表</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"><span class=\"toc-text\">动态规划</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">贪心算法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91\"><span class=\"toc-text\">斐波那契</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">图算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">二叉树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91\"><span class=\"toc-text\">哈夫曼树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">广度优先搜索</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">深度优先搜索</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span class=\"toc-text\">最小生成树</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">单源最短路径</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">所有结点对的最短路径</span></a></li></ol>","author":{"name":"Algernon","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/68c4c7d8696c482da565ab5c8ebfa2fa.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}},"mapped":true,"prev_post":{"title":"Python实训题目","uid":"6165171c95ee293a7ed71a60e0ed0daa","slug":"python实训题目","date":"2022-11-03T13:52:49.000Z","updated":"2022-11-03T13:53:09.445Z","comments":true,"path":"api/articles/python实训题目.json","keywords":null,"cover":[],"text":"写在前面学校python课实训平台的oj太敏感辣，少一个空格都会报错——面向答案编程。为纪念在python实践课上花费的不多但受苦的经历，特将代码保存于博客上。宁愿刷leetcode也不愿意跑python代码 2.1 表达式和基本输入输出2.1.1 数据输入与输出 任务描述本关任...","link":"","photos":[],"count_time":{"symbolsCount":"43k","symbolsTime":"39 mins."},"categories":[],"tags":[{"name":"python","slug":"python","count":9,"path":"api/tags/python.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/68c4c7d8696c482da565ab5c8ebfa2fa.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}},"next_post":{"title":"利用Markdown写文章 公式小册（Latex）","uid":"a32f84760e004b1cfbde91612f64a1ec","slug":"latex","date":"2022-11-03T13:50:49.000Z","updated":"2022-11-24T03:26:34.767Z","comments":true,"path":"api/articles/latex.json","keywords":null,"cover":null,"text":"公式使用 \\begin{eqnarray} \\nabla\\cdot\\vec{E} &=& \\frac{\\rho}{\\epsilon_0} \\\\ \\nabla\\cdot\\vec{B} &=& 0 \\\\ \\nabla\\times\\vec{E} &=& -\\frac{\\partial ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数模","slug":"数模","count":2,"path":"api/categories/数模.json"}],"tags":[{"name":"latex","slug":"latex","count":1,"path":"api/tags/latex.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/68c4c7d8696c482da565ab5c8ebfa2fa.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}}}