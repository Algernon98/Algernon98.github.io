{"title":"【GO语言编程】（三）","uid":"424355acc1981b780ee62e0097527e8c","slug":"GO3","date":"2022-11-03T14:55:49.000Z","updated":"2022-11-08T15:50:38.599Z","comments":true,"path":"api/articles/GO3.json","keywords":null,"cover":[],"content":"<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法** 其实就是一个函数，在 <code>func</code> 这个关键字和方法名中间加入了一个特殊的接收器类型。接收器可以是结构体类型或者是非结构体类型。接收器是可以在方法的内部访问的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc (t Type) methodName(parameterList) returnList&#123;\n&#125;</code></pre>\n<p>上面的代码片段创建了一个接收器类型为 <code>Type</code> 的方法 <code>methodName</code> 。</p>\n<h3 id=\"实例绑定\"><a href=\"#实例绑定\" class=\"headerlink\" title=\"实例绑定\"></a>实例绑定</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; Lesson 定义一个名为 Lesson 的结构体\ntype Lesson struct &#123;\n\tName   string\n\tTarget string\n&#125;\n\n&#x2F;&#x2F; PrintInfo 定义一个与 Lesson 的绑定的方法\nfunc (lesson Lesson) PrintInfo() &#123;\n\tfmt.Println(&quot;name:&quot;, lesson.Name)\n\tfmt.Println(&quot;target:&quot;, lesson.Target)\n&#125;\n\nfunc main() &#123;\n\tl :&#x3D; Lesson&#123;\n\t\tName:   &quot;可爱电子羊&quot;,\n\t\tTarget: &quot;咖喱饭真好吃&quot;,\n\t&#125;\n\tl.PrintInfo()\n&#125;\n</code></pre>\n<p>上面的程序中定义了一个与结构体 <code>Lesson</code> 绑定的方法 <code>PrintInfo()</code> ，其中 <code>PrintInfo</code> 是方法名， <code>(lesson Lesson)</code> 表示将此方法与 <code>Lesson</code> 的实例绑定，这里我们把 <code>Lesson</code> 称为方法的接收者，而 <code>lesson</code> 表示实例本身，相当于 Python 中的 <code>self</code> ，Java 中的 <code>this</code>。</p>\n<p>当然，你可以把上面程序的方法改成一个函数，如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Lesson struct &#123;\n    Name   string\n    Target string\n&#125;\n\nfunc PrintInfo(lesson Lesson) &#123;\n    fmt.Println(&quot;name:&quot;, lesson.Name)\n    fmt.Println(&quot;target:&quot;, lesson.Target)\n&#125;\n\nfunc main() &#123;\n    lesson :&#x3D; Lesson&#123;\n        Name: &quot;可爱电子羊&quot;,\n        Target: &quot;咖喱饭真好吃&quot;,\n    &#125;\n    PrintInfo(lesson)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/7db5fe6334844ceca2ef288c3a8ea0ca.png\" alt=\"在这里插入图片描述\"></p>\n<p>运行这个程序，也同样会输出上面一样的答案，那么我们为什么还要用方法呢？因为在 Go 中，相同的名字的方法可以定义在不同的类型上，而相同名字的函数是不被允许的。<strong>如果你在上面这个程序添加一个同名函数，就会报错。但是在不同的结构体上面定义同名的方法就是可行的。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Lesson struct &#123;\n    Name   string\n    Target string\n&#125;\n\nfunc (lesson Lesson) PrintInfo() &#123;\n    fmt.Println(&quot;Lesson name:&quot;, lesson.Name)\n    fmt.Println(&quot;Lesson target:&quot;, lesson.Target)\n&#125;\n\ntype Author struct &#123;\n    Name string\n&#125;\n\nfunc (author Author) PrintInfo() &#123;\n    fmt.Println(&quot;author name:&quot;, author.name)\n&#125;\n\nfunc main() &#123;\n    lesson :&#x3D; Lesson&#123;\n        Name: &quot;电子羊想吃咖喱饭&quot;,\n        Target: &quot;咖喱饭呀咖喱饭&quot;,\n    &#125;\n    lesson.PrintInfo()\n    author :&#x3D; Author&#123;&quot;电子羊&quot;&#125;\n    author.PrintInfo()\n&#125;</code></pre>\n<h3 id=\"指针接收器与值接收器\"><a href=\"#指针接收器与值接收器\" class=\"headerlink\" title=\"指针接收器与值接收器\"></a>指针接收器与值接收器</h3><p>值接收器和指针接收器之间的区别在于，在指针接收器的方法内部的改变对于调用者是可见的，然而值接收器的方法内部的改变对于调用者是不可见的，所以若要改变实例的属性时，必须使用指针作为方法的接收者。看看下面的例子就知道了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; Lesson 定义一个名为 Lesson 的结构体\ntype Lesson struct &#123;\n    Name string\n    Target  string\n    SpendTime int\n&#125;\n\n&#x2F;&#x2F; PrintInfo 定义一个与 Lesson 的绑定的方法\nfunc (lesson Lesson) PrintInfo() &#123;\n    fmt.Println(&quot;name:&quot;, lesson.Name)\n    fmt.Println(&quot;target:&quot;, lesson.Target)\n    fmt.Println(&quot;spendTime:&quot;, lesson.SpendTime)\n&#125;\n\nfunc (lesson Lesson) ChangeLessonName(name string) &#123;\n&#x2F;&#x2F;    lesson.name &#x3D; name\n&#125;\n\n&#x2F;&#x2F; AddSpendTime 定义一个与 Person 的绑定的方法，使 age 值加 n\nfunc (lesson *Lesson) AddSpendTime(n int) &#123;\n    lesson.SpendTime &#x3D; lesson.SpendTime + n\n&#125;\n\nfunc main() &#123;\n    lesson :&#x3D; Lesson&#123;\n        Name: &quot;电子羊想吃咖喱饭&quot;,\n        Target: &quot;咖喱饭呀咖喱饭&quot;,\n        PrintTimes:  1,\n    &#125;\n    fmt.Println(&quot;before change&quot;)\n    lesson.PrintInfo()\n\n    fmt.Println(&quot;after change&quot;)\n    lesson.AddSpendTime(2)\n    lesson.ChangeLessonName(&quot;印度长米搭配孜然羊肉的玛莎拉咖喱饭&quot;)\n    lesson.PrintInfo()\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/b12f13a2ce254af6acec3f041bd8131f.png\" alt=\"在这里插入图片描述\"></p>\n<p>在上面的程序中， <code>AddSpendTime</code> 使用指针接收器最终能改变实例的 <code>SpendTime</code> 值，然而使用值接收器的 <code>ChangeLessonName</code> 最终没有改变实例 <code>Name</code> 的值。</p>\n<h3 id=\"在方法中使用值接收器-与-在函数中使用值参数\"><a href=\"#在方法中使用值接收器-与-在函数中使用值参数\" class=\"headerlink\" title=\"在方法中使用值接收器 与 在函数中使用值参数\"></a>在方法中使用值接收器 与 在函数中使用值参数</h3><p>当一个函数有一个值参数，它只能接受一个值参数。当一个方法有一个值接收器，它可以接受值接收器和指针接收器。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Lesson struct &#123;\n    Name string\n    Target  string\n    PrintTimes int\n&#125;\n\nfunc (lesson Lesson) PrintInfo() &#123;\n    fmt.Println(lesson.Name)\n&#125;\n\nfunc PrintInfo(lesson Lesson) &#123;\n    fmt.Println(lesson.name)\n&#125;\n\nfunc main() &#123;\n    lesson :&#x3D; Lesson&#123;&quot;Go语言微服务核心架构22讲&quot;&#125;\n    PrintInfo(lesson)\n    lesson.PrintInfo()\n\n    bPtr :&#x3D; &amp;lesson\n    &#x2F;&#x2F;PrintInfo(bPtr) &#x2F;&#x2F; error\n    bPtr.PrintInfo()\n&#125;</code></pre>\n<p>在上面的程序中，使用值参数 <code>PrintInfo(lesson)</code> 来调用这个函数是合法的，使用值接收器来调用 <code>lesson.PrintInfo()</code> 也是合法的。</p>\n<p>然后在程序中我们创建了一个指向 <code>Lesson</code> 的指针 <code>bPtr</code> ，通过使用指针接收器来调用 <code>bPtr.PrintInfo()</code> 是合法的，但使用值参数调用 <code>PrintInfo(bPtr)</code> 是非法的。</p>\n<h3 id=\"在非结构体上的方法\"><a href=\"#在非结构体上的方法\" class=\"headerlink\" title=\"在非结构体上的方法\"></a>在非结构体上的方法</h3><p>不仅可以在结构体类型上定义方法，也可以在非结构体类型上定义方法，但是有一个问题。为了在一个类型上定义一个方法，方法的接收器类型定义和方法的定义应该在同一个包中。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype myInt int\n\nfunc (a myInt) add(b myInt) myInt &#123;\n    return a + b\n&#125;\n\nfunc main() &#123;\n    var x myInt &#x3D; 50\n    var y myInt &#x3D; 7\n    fmt.Println(x.add(y))   &#x2F;&#x2F; 57\n&#125;</code></pre>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>在 Go 语言中， <strong>接口</strong> 就是方法签名(Method Signature)的集合。在面向对象的领域里，接口定义一个对象的行为，接口只指定了对象应该做什么，至于如何实现这个行为，则由对象本身去确定。当一个类型实现了接口中的所有方法，我们称它实现了该接口。接口指定了一个类型应该具有的方法，并由该类型决定如何实现这些方法。</p>\n<h3 id=\"接口的定义\"><a href=\"#接口的定义\" class=\"headerlink\" title=\"接口的定义\"></a>接口的定义</h3><p>使用 <code>type</code> 关键字可以定义接口：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ntype interface_name interface &#123;\n    method()\n&#125;</code></pre>\n<h3 id=\"接口的实现\"><a href=\"#接口的实现\" class=\"headerlink\" title=\"接口的实现\"></a>接口的实现</h3><p>创建类型或者结构体，并为其绑定接口定义的方法，接收者为该类型或结构体，方法名为接口中定义的方法名，这样就说该类型或者结构体实现了该接口。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Study interface &#123;\n    learn()\n&#125;\n\ntype Student struct &#123;\n    name string\n&#125;\n\nfunc (s Student) learn() &#123;\n    fmt.Printf(&quot;%s 在读 %s&quot;, s.name, s.book)\n&#125;\n\nfunc main() &#123;\n    student1 :&#x3D; Student&#123;\n        name: &quot;张三&quot;,\n        book: &quot;《Go语言极简一本通》&quot;,\n    &#125;\n    student1.learn()\n&#125;</code></pre>\n<p>上面的程序定义了一个名为 <code>Study</code> 的接口，接口中有未实现的方法 <code>learn()</code> ，这里还定义了名为 <code>Student</code> 的结构体，其绑定了方法 <code>learn()</code> ，也就隐式实现了 <code>Study</code> 接口，实现的内容是打印语句。</p>\n<p>上面的例子使用了值接受者实现接口，下面的例子使用了指针接受者实现接口。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\ntype Study interface &#123;\n    learn()\n&#125;\n\n...\n\ntype Worker struct &#123;\n    name string\n    book string\n    by   string\n&#125;\n\nfunc (w *Worker) learn() &#123;\n    fmt.Printf(&quot;%s 在读 %s,通过方式 %s&quot;, w.name, w.book, w.by)\n&#125;\n\nfunc main() &#123;\n    var s1 Study\n    var s2 Study\n\n    student2 :&#x3D; Student&#123;\n        name: &quot;李四&quot;,\n        book: &quot;《Go语言极简一本通》&quot;,\n    &#125;\n    s1 &#x3D; student2\n    s1.learn()\n\n    student3 :&#x3D; Student&#123;\n        name: &quot;王五&quot;,\n        book: &quot;Go语言微服务架构核心22讲&quot;,\n    &#125;\n    s1 &#x3D; &amp;student3\n    s1.learn()\n\n    worker1 :&#x3D; Worker&#123;\n        name: &quot;老王&quot;,\n        book: &quot;从0到Go语言微服务架构师&quot;,\n        by:   &quot;视频&quot;,\n    &#125;\n    &#x2F;&#x2F; s2 &#x3D; worker1 &#x2F;&#x2F; error\n    s2 &#x3D; &amp;worker1\n    s2.learn()\n&#125;</code></pre>\n<p>该程序定义了结构体 <code>Student</code> ，使用其作为值接受者实现 <code>Study</code> 接口。<code>student2</code> 的类型为 <code>Student</code> ， <code>student2</code> 赋值给 <code>s1</code> ，由于 <code>Student</code> 实现了接口变量 <code>s1</code> 所以会有输出。而接下来 <code>s1</code> 又被赋值为 <code>&amp;student3</code> ，同样有输出。接下来的结构体 <code>Worker</code> 使用指针接受者实现 <code>Study</code> 接口。<code>worker1</code> 的类型为 <code>Worker</code> ， <code>s2</code> 被赋值为 <code>&amp;worker1</code> ，所以会有输出。但如果把 <code>s2</code> 赋值为 <code>worker1</code> 会报错，对于使用指针接受者的方法，用一个指针或者一个可取得地址的值来调用都是合法的。但接口中存储的具体值(Concrete Value)并不能取到地址，因此对于编译器无法自动获取 <code>worker1</code> 的地址，于是程序报错。</p>\n<h3 id=\"接口实现多态\"><a href=\"#接口实现多态\" class=\"headerlink\" title=\"接口实现多态\"></a>接口实现多态</h3><p>使用接口可以实现多态，例如下面的程序，定义了名为 <code>Study</code> 的接口，接口中有方法 <code>learn()</code> 。程序中还定义了结构体 <code>Student</code> 和 <code>Worker</code> ，分别实现了 <code>Study</code> 接口，Student 的 learn <code>name: &quot;李四&quot;, book: &quot;《Go语言极简一本通》&quot;</code> 而 Worker 的 learn 为 <code>name: &quot;张三&quot;,book: &quot;从0到Go语言微服务架构师&quot;,by: &quot;视频&quot;</code> ，利用的接口实现了不同的功能，这就是多态。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nfunc main() &#123;\n    ...\n    s2.learn()\n    worker1.learn()\n&#125;</code></pre>\n<h3 id=\"接口的内部表示\"><a href=\"#接口的内部表示\" class=\"headerlink\" title=\"接口的内部表示\"></a>接口的内部表示</h3><p>可以把接口的内部看做 <code>(type, value)</code>。<code>type</code> 是接口底层的具体类型(Concrete Type)，而 <code>value</code> 是具体类型的值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n...\n\nfunc ShowInterface(s Study) &#123;\n    fmt.Printf(&quot;接口类型: %T\\n,接口值: %v\\n&quot;, s, s)\n&#125;\n\nfunc main() &#123;\n    var s Study\n    s &#x3D; student2\n    ShowInterface(s)\n    s.learn()\n&#125;</code></pre>\n<p>在上面的程序中，定义了 <code>Study</code> 接口，其中有 <code>learn()</code> 方法，结构体 <code>Student</code> 实现了该接口。使用 <code>s = student2</code> 语句我们把 <code>student2</code> ( <code>Student</code> 类型)赋值给了 <code>s</code> ( <code>Study</code> 类型)，现在打印出 <code>Study</code> 的具体类型为 <code>Student</code> ，而 <code>student2</code> 的值为 <code>name: &quot;李四&quot;, book: &quot;《Go语言极简一本通》&quot;</code> 。</p>\n<h3 id=\"空接口\"><a href=\"#空接口\" class=\"headerlink\" title=\"空接口\"></a>空接口</h3><p><strong>空接口</strong> 是特殊形式的接口类型，没有定义任何方法的接口就称为空接口，可以说所有类型都至少实现了空接口，空接口表示为 <code>interface&#123;&#125;</code> 。例如，我们之前的写过的空接口参数函数，可以接受任何类型的参数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc ShowType(i interface&#123;&#125;) &#123;\n    fmt.Printf(&quot;类型: %T, 值: %v\\n&quot;, i, i)\n&#125;\n\nfunc main() &#123;\n    str :&#x3D; &quot;从0到Go语言微服务架构师&quot;\n    ShowType(str)\n    num :&#x3D; 3.14\n    ShowType(num)\n&#125;</code></pre>\n<p>上面的程序中我们定义了函数 <code>ShowType</code> 使用空接口作为参数，所以可以给这个函数传递任何类型的参数。</p>\n<p>通过上面的例子不难发现接口都有两个属性，一个是值，而另一个是类型。对于空接口来说，这两个属性都为 <code>nil</code> ：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    var i interface&#123;&#125;\n    fmt.Printf(&quot;Type: %T, Value: %v&quot;, i, i)\n    &#x2F;&#x2F; Type: &lt;nil&gt;, Value: &lt;nil&gt;\n&#125;</code></pre>\n<p>除了上面讲到的使用空接口作为函数参数的用法，空接口还有以下两种用法。</p>\n<p>直接使用 <code>interface&#123;&#125;</code> 作为类型声明一个实例，这个实例就能承载任何类型的值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    var i interface&#123;&#125;\n\n    i &#x3D; &quot;从0到Go语言微服务架构师&quot;\n    fmt.Println(i) &#x2F;&#x2F; Let&#39;s go\n\n    i &#x3D; 3.14\n    fmt.Println(i) &#x2F;&#x2F; 3.14\n&#125;</code></pre>\n<p>我们也可以定义一个接收任何类型的 <code>array</code> 、 <code>slice</code> 、 <code>map</code> 、 <code>strcut</code> 。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    x :&#x3D; make([]interface&#123;&#125;, 3)\n    x[0] &#x3D; &quot;从0到Go语言微服务架构师&quot;\n    x[1] &#x3D; 3.14\n    x[2] &#x3D; []int&#123;1, 2, 3&#125;\n    for _, value :&#x3D; range x &#123;\n        fmt.Println(value)\n    &#125;\n&#125;</code></pre>\n<p>空接口可以承载任何值，但是空接口类型的对象是不能赋值给另一个固定类型对象的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nfunc main() &#123;\n    var num &#x3D; 1\n    var i interface&#123;&#125; &#x3D; num\n    var str string &#x3D; i &#x2F;&#x2F; error\n&#125;</code></pre>\n<p>当空接口承载数组和切片后，该对象无法再进行切片。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    var s &#x3D; []int&#123;1, 2, 3&#125;\n\n    var i interface&#123;&#125; &#x3D; s\n\n    var s2 &#x3D; i[1:2] &#x2F;&#x2F; error\n    fmt.Println(s2)\n&#125;</code></pre>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>类型断言用于提取接口的底层值(Underlying Value)。使用 <code>interface.(Type)</code> 可以获取接口的底层值，其中接口 <code>interface</code> 的具体类型是 <code>Type</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc assert(i interface&#123;&#125;) &#123;\n    value, ok :&#x3D; i.(int)\n    fmt.Println(value, ok)\n&#125;\n\nfunc main() &#123;\n    var x interface&#123;&#125; &#x3D; 3\n    assert(x)\n    var y interface&#123;&#125; &#x3D; &quot;从0到Go语言微服务架构师&quot;\n    assert(y)\n&#125;</code></pre>\n<h3 id=\"类型选择\"><a href=\"#类型选择\" class=\"headerlink\" title=\"类型选择\"></a>类型选择</h3><p>类型选择用于将接口的具体类型与 <code>case</code> 语句所指定的类型进行比较。它其实就是一个 <code>switch</code> 语句，但在 <code>switch</code> 后面跟的是 <code>i.(type)</code> ，并且每个 <code>case</code> 后面跟的是类型。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc getTypeValue(i interface&#123;&#125;) &#123;\n    switch i.(type) &#123;\n    case int:\n        fmt.Printf(&quot;Type: int, Value: %d\\n&quot;, i.(int))\n    case string:\n        fmt.Printf(&quot;Type: string, Value: %s\\n&quot;, i.(string))\n    default:\n        fmt.Printf(&quot;Unknown type\\n&quot;)\n    &#125;\n&#125;\n\nfunc main() &#123;\n    getTypeValue(300)\n    getTypeValue(&quot;从0到Go语言微服务架构师&quot;)\n    getTypeValue(true)\n&#125;</code></pre>\n<h3 id=\"实现多个接口\"><a href=\"#实现多个接口\" class=\"headerlink\" title=\"实现多个接口\"></a>实现多个接口</h3><p>类型或者结构体可以实现多个接口，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n...\n\n\ntype Happy interface &#123;\n\trest()\n&#125;\n\nfunc (s Student) rest() &#123;\n    fmt.Printf(&quot;%s 放学了，出去玩...&quot;, s.name)\n&#125;\n\nfunc (w *Worker) rest() &#123;\n    fmt.Printf(&quot;%s 下班了，吃大餐去...&quot;, w.name)\n&#125;\n\nfunc main() &#123;\n    worker2 :&#x3D; Worker&#123;\n        name: &quot;小明&quot;,\n        book: &quot;从0到Go语言微服务架构师&quot;,\n        by:   &quot;视频&quot;,\n    &#125;\n    worker2.learn()\n    worker2.rest()\n&#125;</code></pre>\n<h3 id=\"接口的嵌套\"><a href=\"#接口的嵌套\" class=\"headerlink\" title=\"接口的嵌套\"></a>接口的嵌套</h3><p>虽然在 Go 中没有继承机制，但可以通过接口的嵌套实现类似功能。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n...\n\ntype Life interface &#123;\n    Study\n    Happy\n&#125;\n\nfunc main() &#123;\n    worker2 :&#x3D; Worker&#123;\n        name: &quot;小明&quot;,\n        book: &quot;从0到Go语言微服务架构师&quot;,\n        by:   &quot;视频&quot;,\n    &#125;\n    worker2.learn()\n    worker2.rest()\n&#125;</code></pre>\n<h2 id=\"go-协程\"><a href=\"#go-协程\" class=\"headerlink\" title=\"go 协程\"></a>go 协程</h2><p><strong>Go 语言的 协程(Groutine)</strong> 是与其他函数或方法一起并发运行的工作方式。协程可以看作是轻量级线程。与线程相比，创建一个协程的成本很小。因此在 Go 应用中，常常会看到会有很多协程并发地运行。</p>\n<h3 id=\"启动一个-go-协程\"><a href=\"#启动一个-go-协程\" class=\"headerlink\" title=\"启动一个 go 协程\"></a>启动一个 go 协程</h3><p>调用函数或者方法时，如果在前面加上关键字 <code>go</code> ，就可以让一个新的 Go 协程并发地运行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; 定义一个函数\nfunc functionName(parameterList) &#123;\n    code\n&#125;\n\n&#x2F;&#x2F; 执行一个函数\nfunctionName(parameterList)\n\n&#x2F;&#x2F; 开启一个协程执行这个函数\ngo functionName(parameterList)</code></pre>\n<p>下面是启动一个协程的例子， <code>go PrintInfo()</code> ， <code>PrintInfo()</code> 函数与 <code>main()</code> 函数会并发执行，主函数运行在一个特殊的协程上，这个协程称之为 <strong>主协程(Main Goroutine)</strong> 。</p>\n<p>启动一个新的协程时，协程的调用会立即返回。与函数不同，程序控制不会去等待 Go 协程执行完毕。在调用 Go 协程之后，程序控制会立即返回到代码的下一行，忽略该协程的任何返回值。如果 Go 主协程终止，则程序终止，于是其他 Go 协程也会终止。为了让新的协程能继续运行，我们在 <code>main()</code> 函数添加了 <code>time.Sleep(1 * time.Second)</code> 使主协程休眠 1 秒，但这种做法并不推荐，这里只是为了演示而添加。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n &quot;fmt&quot;\n &quot;time&quot;\n)\n\nfunc PrintInfo() &#123;\n fmt.Println(&quot;从0到Go语言微服务架构师&quot;)\n&#125;\n\nfunc main() &#123;\n &#x2F;&#x2F; 开启一个协程执行 PrintInfo 函数\n go PrintInfo()\n &#x2F;&#x2F; 使主协程休眠 1 秒\n time.Sleep(1 * time.Second)\n &#x2F;&#x2F; 打印 main\n fmt.Println(&quot;main&quot;)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/f1e51b3e55c04689980a2ebfbd1d6209.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"启动多个-Go-协程\"><a href=\"#启动多个-Go-协程\" class=\"headerlink\" title=\"启动多个 Go 协程\"></a>启动多个 Go 协程</h3><p>通过下面的例子，可以观察到两个协程就如两个线程一样，并发执行：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;time&quot;\n)\n\nfunc PrintNum(num int) &#123;\n\tfor i :&#x3D; 0; i &lt; 3; i++ &#123;\n\t\tfmt.Println(num)\n\t\t&#x2F;&#x2F; 避免观察不到并发效果 加个休眠\n\t\ttime.Sleep(100 * time.Millisecond)\n\t&#125;\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 开启 1 号协程\n\tgo PrintNum(1)\n\t&#x2F;&#x2F; 开启 2 号协程\n\tgo PrintNum(2)\n\t&#x2F;&#x2F; 使主协程休眠 1 秒\n\ttime.Sleep(time.Second)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/847937daf1f948afbba9117e8d8741d0.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"channel-通道\"><a href=\"#channel-通道\" class=\"headerlink\" title=\"channel 通道\"></a>channel 通道</h2><p><strong>通道(channel)</strong> ，就是一个管道，可以想像成 Go 协程之间通信的管道。它是一种队列式的数据结构，遵循先入先出的规则。</p>\n<h3 id=\"通道的声明\"><a href=\"#通道的声明\" class=\"headerlink\" title=\"通道的声明\"></a>通道的声明</h3><p>每个通道都只能传递一种数据类型的数据，在你声明的时候，我们要指定通道的类型。<code>chan Type</code> 表示 <code>Type</code> 类型的通道。通道的零值为 <code>nil</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nvar channel_name chan channel_types</code></pre>\n<p>下面的语句声明了一个类型为 <code>string</code> 的通道 <code>nameChan</code> ，该通道 <code>nameChan</code> 的值为 <code>nil</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nvar ch chan string</code></pre>\n<h3 id=\"通道的初始化\"><a href=\"#通道的初始化\" class=\"headerlink\" title=\"通道的初始化\"></a>通道的初始化</h3><p>声明完通道后，通道的值为 <code>nil</code> ，我们不能直接使用，必须先使用 <code>make</code> 函数对通道进行初始化操作。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nch &#x3D; make(chan channel_type)</code></pre>\n<p>使用下面的语句我们可以对上面声明过的通道 <code>ch</code> 进行初始化：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nch &#x3D; make(chan string)</code></pre>\n<p>这样，我们就已经定义好了一个 <code>string</code> 类型的通道 <code>nameChan</code> 。当然，也可以使用简短声明语句一次性定义一个通道：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nch :&#x3D; make(chan string)</code></pre>\n<h3 id=\"使用通道发送和接收数据\"><a href=\"#使用通道发送和接收数据\" class=\"headerlink\" title=\"使用通道发送和接收数据\"></a>使用通道发送和接收数据</h3><p>往通道发送数据使用的是下面的语法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; 把 data 数据发送到 channel_name 通道中\n&#x2F;&#x2F; 即把 data 数据写入到 channel_name 通道中\nchannel_name &lt;- data</code></pre>\n<p>从通道接收数据使用的是下面的语法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; 从 channel_name 通道中接收数据到 value\n&#x2F;&#x2F; 即从 channel_name 通道中读取数据到 value\nvalue :&#x3D; &lt;- channel_name</code></pre>\n<p>通道旁的箭头方向指定了是发送数据还是接收数据。箭头指向通道，代表数据写入到通道中；箭头往通道指向外，代表从通道读数据出去。</p>\n<p>下面的例子演示了通道的使用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n\t&quot;fmt&quot;\n)\n\nfunc PrintChan(c chan string) &#123;\n\t&#x2F;&#x2F; 往通道传入数据 &quot;从0到Go语言微服务架构师&quot;\n\tc &lt;- &quot;赤土之王与三朝圣者&quot;\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 创建一个通道\n\tch :&#x3D; make(chan string)\n\n\tfmt.Println(&quot;3.1版本更新&quot;)\n\t&#x2F;&#x2F; 开启协程\n\tgo PrintChan(ch)\n\t&#x2F;&#x2F; 从通道接收数据\n\trec :&#x3D; &lt;-ch\n\t&#x2F;&#x2F; 打印从通道接收到的数据\n\tfmt.Println(rec)\n\t&#x2F;&#x2F; 打印 &quot;学习目标:全面掌握Go语言微服务落地，代码级一次性解决微服务和分布式系统。&quot;\n\tfmt.Println(&quot;虚空劫灰往事书&quot;)\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/9ba90c963ed44502960350211628dc24.png\" alt=\"在这里插入图片描述\"></p>\n<p>该程序模拟了两个协程并发调用的场景，在 <code>main</code> 函数中，创建了一个通道，在 <code>main</code> 函数中先打印了 <code>学习课程:</code> ，然后开启协程运行 <code>PrintChan</code> 函数，而 <code>main</code> 函数通过协程接收数据，主协程发生了阻塞，等待通道 <code>ch</code> 发送的数据，在函数中，数据 <code>从0到Go语言微服务架构师</code> 传入通道中，当写入完成时，主协程接收了数据，解除了阻塞状态，打印出从通道接收到的数据 <code>从0到Go语言微服务架构师</code> ，最后打印 `学习目标:全面掌握 Go 语言微服务落地，代码级一次性解决微服务和分布式系统。<br><strong>Tips</strong>: <strong>发送与接收默认是阻塞的</strong></p>\n<ul>\n<li>从上面的例子我们知道，如果从通道接收数据没接收完主协程是不会继续执行下去的。当把数据发送到通道时，会在发送数据的语句处发生阻塞，直到有其它协程从通道读取到数据，才会解除阻塞。与此类似，当读取通道的数据时，如果没有其它的协程把数据写入到这个通道，那么读取过程就会一直阻塞着。</li>\n</ul>\n<h3 id=\"通道的关闭\"><a href=\"#通道的关闭\" class=\"headerlink\" title=\"通道的关闭\"></a>通道的关闭</h3><p>对于一个已经使用完毕的通道，我们要将其进行关闭。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nclose(channel_name)</code></pre>\n<p>这里要注意，对于一个已经关闭的通道如果再次关闭会导致报错，我们可以在接收数据时，判断通道是否已经关闭，从通道读取数据返回的第二个值表示通道是否没被关闭，如果已经关闭，返回值为 <code>false</code> ；如果还未关闭，返回值为 <code>true</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nvalue, ok :&#x3D; &lt;- channel_name</code></pre>\n<h3 id=\"通道的容量与长度\"><a href=\"#通道的容量与长度\" class=\"headerlink\" title=\"通道的容量与长度\"></a>通道的容量与长度</h3><p>我们在前面讲过 <code>make</code> 函数是可以接收两个参数的，同理，创建通道可以传入第二个参数——容量。</p>\n<ul>\n<li>当容量为 <code>0</code> 时，说明通道中不能存放数据，在发送数据时，必须要求立马有人接收，否则会报错。此时的通道称之为无缓冲通道。</li>\n<li>当容量为 <code>1</code> 时，说明通道只能缓存一个数据，若通道中已有一个数据，此时再往里发送数据，会造成程序阻塞。利用这点可以利用通道来做锁。</li>\n<li>当容量大于 <code>1</code> 时，通道中可以存放多个数据，可以用于多个协程之间的通信管道，共享资源。</li>\n</ul>\n<p>既然通道有容量和长度，那么我们可以通过 <code>cap</code> 函数和 <code>len</code> 函数获取通道的容量和长度。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n)\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 创建一个通道\n\tc :&#x3D; make(chan int, 3)\n\tfmt.Println(&quot;初始化后：&quot;)\n\tfmt.Println(&quot;cap &#x3D;&quot;, cap(c))\n\tfmt.Println(&quot;len &#x3D;&quot;, len(c))\n\tc &lt;- 1\n\tc &lt;- 2\n\tfmt.Println(&quot;传入两个数后：&quot;)\n\tfmt.Println(&quot;cap &#x3D;&quot;, cap(c))\n\tfmt.Println(&quot;len &#x3D;&quot;, len(c))\n\t&lt;- c\n\tfmt.Println(&quot;取出一个数后：&quot;)\n\tfmt.Println(&quot;cap &#x3D;&quot;, cap(c))\n\tfmt.Println(&quot;len &#x3D;&quot;, len(c))\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/906b53c216ca4e65a6edf4a0f068b920.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"缓冲通道与无缓冲通道\"><a href=\"#缓冲通道与无缓冲通道\" class=\"headerlink\" title=\"缓冲通道与无缓冲通道\"></a>缓冲通道与无缓冲通道</h3><p>按照是否可缓冲数据可分为：<strong>缓冲通道</strong> 与 <strong>无缓冲通道</strong> 。</p>\n<p>无缓冲通道在通道里无法存储数据，接收端必须先于发送端准备好，以确保你发送完数据后，有人立马接收数据，否则发送端就会造成阻塞，原因很简单，通道中无法存储数据。也就是说发送端和接收端是同步运行的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nc :&#x3D; make(chan int)\n&#x2F;&#x2F; 或者\nc :&#x3D; make(chan int, 0)</code></pre>\n<p>缓冲通道允许通道里存储一个或多个数据，设置缓冲区后，发送端和接收端可以处于异步的状态。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nc :&#x3D; make(chan int, 3)</code></pre>\n<h3 id=\"双向通道\"><a href=\"#双向通道\" class=\"headerlink\" title=\"双向通道\"></a>双向通道</h3><p>到目前为止，上面定义的都是双向通道，既可以发送数据也可以接收数据。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;time&quot;\n)\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 创建一个通道\n\tc :&#x3D; make(chan int)\n\n\t&#x2F;&#x2F; 发送数据\n\tgo func() &#123;\n\t\tfmt.Println(&quot;send: 1&quot;)\n\t\tc &lt;- 1\n\t&#125;()\n\n\t&#x2F;&#x2F; 接收数据\n\tgo func() &#123;\n\t\tn :&#x3D; &lt;- c\n\t\tfmt.Println(&quot;receive:&quot;, n)\n\t&#125;()\n\n\t&#x2F;&#x2F; 主协程休眠\n\ttime.Sleep(time.Millisecond)\n&#125;</code></pre>\n<h3 id=\"单向通道\"><a href=\"#单向通道\" class=\"headerlink\" title=\"单向通道\"></a>单向通道</h3><p>单向通道只能发送或者接收数据。所以可以具体细分为只读通道和只写通道。</p>\n<p><code>&lt;-chan</code> 表示只读通道：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; 定义只读通道\nc :&#x3D; make(chan string)\n&#x2F;&#x2F; 定义类型\ntype Receiver &#x3D; &lt;-chan string\nvar receiver Receiver &#x3D; c\n\n&#x2F;&#x2F; 或者简单写成下面的形式\ntype Receiver &#x3D; &lt;-chan int\nreceiver :&#x3D; make(Receiver)</code></pre>\n<p><code>chan&lt;-</code> 表示只写通道：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; 定义只写通道\nc :&#x3D; make(chan int)\n&#x2F;&#x2F; 定义类型\ntype Sender &#x3D; chan&lt;- int\nvar sender Sender &#x3D; c\n\n&#x2F;&#x2F; 或者简单写成下面的形式\ntype Sender &#x3D; chan&lt;- int\nsender :&#x3D; make(Sender)</code></pre>\n<p>下面是一个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;time&quot;\n)\n\n&#x2F;&#x2F; Sender 只写通道类型\ntype Sender &#x3D; chan&lt;- string\n\n&#x2F;&#x2F; Receiver 只读通道类型\ntype Receiver &#x3D; &lt;-chan string\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 创建一个双向通道\n\tvar ch &#x3D; make(chan string)\n\n\t&#x2F;&#x2F; 开启一个协程\n\tgo func() &#123;\n\t\t&#x2F;&#x2F; 只能写通道\n\t\tvar sender Sender &#x3D; ch\n\t\tfmt.Println(&quot;即将学习:&quot;)\n\t\tsender &lt;- &quot;Go语言微服务架构核心22讲&quot;\n\t&#125;()\n\n\t&#x2F;&#x2F; 开启一个协程\n\tgo func() &#123;\n\t\t&#x2F;&#x2F; 只能读通道\n\t\tvar receiver Receiver &#x3D; ch\n\t\tmessage :&#x3D; &lt;-receiver\n\t\tfmt.Println(&quot;开始学习: &quot;, message)\n\t&#125;()\n\n\ttime.Sleep(time.Millisecond)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/1713946a40414168a0de18b8844fb984.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"遍历通道\"><a href=\"#遍历通道\" class=\"headerlink\" title=\"遍历通道\"></a>遍历通道</h3><p>使用 <code>for range</code> 循环可以遍历通道，但在遍历时要确保通道是处于关闭状态，否则循环会被阻塞。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n   &quot;fmt&quot;\n)\n\nfunc loopPrint(c chan int) &#123;\n   for i :&#x3D; 0; i &lt; 10; i++ &#123;\n      c &lt;- i\n   &#125;\n   &#x2F;&#x2F; 记得要关闭通道\n   &#x2F;&#x2F; 否则主协程遍历完不会结束，而会阻塞\n   close(c)\n&#125;\n\nfunc main() &#123;\n   &#x2F;&#x2F; 创建一个通道\n   var ch2 &#x3D; make(chan int, 5)\n   go loopPrint(ch2)\n   for v :&#x3D; range ch2 &#123;\n      fmt.Println(v)\n   &#125;\n&#125;</code></pre>\n<h3 id=\"用通道做锁\"><a href=\"#用通道做锁\" class=\"headerlink\" title=\"用通道做锁\"></a>用通道做锁</h3><p>上面讲过，当通道容量为 <code>1</code> 时，说明通道只能缓存一个数据，若通道中已有一个数据，此时再往里发送数据，会造成程序阻塞。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;time&quot;\n)\n\n&#x2F;&#x2F; 由于 x &#x3D; x+1 不是原子操作\n&#x2F;&#x2F; 所以应避免多个协程对 x 进行操作\n&#x2F;&#x2F; 使用容量为 1 的通道可以达到锁的效果\nfunc increment(ch chan bool, x *int) &#123;\n\tch &lt;- true\n\t*x &#x3D; *x + 1\n\t&lt;- ch\n&#125;\n\nfunc main() &#123;\n\tch3 :&#x3D; make(chan bool, 1)\n\tvar x int\n\tfor i :&#x3D; 0; i &lt; 10000; i++ &#123;\n\t\tgo increment(ch3, &amp;x)\n\t&#125;\n\ttime.Sleep(time.Millisecond)\n\tfmt.Println(&quot;x &#x3D;&quot;, x)\n&#125;</code></pre>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>讲完了锁，不得不提死锁。当协程给一个通道发送数据时，照理说会有其他 Go 协程来接收数据。如果没有的话，程序就会在运行时触发 <code>panic</code> ，形成死锁。同理，当有协程等着从一个通道接收数据时，我们期望其他的 Go 协程会向该通道写入数据，要不然程序也会触发 <code>panic</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nfunc main() &#123;\n\tch :&#x3D; make(chan bool)\n\tch &lt;- true\n&#125;</code></pre>\n<p>运行上面的程序，会触发 panic ，报下面的错误：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfatal error: all goroutines are asleep - deadlock!</code></pre>\n<p>下面再来看看几个例子。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tch :&#x3D; make(chan bool)\n\tch &lt;- true\n\tfmt.Println(&lt;-ch)\n&#125;</code></pre>\n<p>上面的代码你看起来可能觉得没啥问题，创建一个通道，往里面写入数据，再从里面读出数据，但运行后会报同样的错误：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfatal error: all goroutines are asleep - deadlock!</code></pre>\n<p>那么为什么会出现死锁呢？前面的基础学的好的就不难想到使用 <code>make</code> 函数创建通道时默认不传递第二个参数，通道中不能存放数据，在发送数据时，必须要求立马有人接收，即该通道为无缓冲通道。所以在接收者没有准备好前，发送操作会被阻塞。</p>\n<p>分析完引发异常的原因后，我们可以将代码修改如下，使用协程，将接收者代码放在另一个协程里：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;time&quot;\n)\n\nfunc funcRecieve(c chan bool) &#123;\n\tfmt.Println(&lt;-c)\n&#125;\nfunc main() &#123;\n\tch4 :&#x3D; make(chan bool)\n\tgo funcRecieve(ch4)\n\tch4 &lt;- true\n\ttime.Sleep(time.Millisecond)\n&#125;</code></pre>\n<p>当然，还有一种更加直接的方法，把无缓冲通道改为缓冲通道就行了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tch5 :&#x3D; make(chan bool, 1)\n\tch5 &lt;- true\n\tfmt.Println(&lt;-ch5)\n&#125;</code></pre>\n<p>有时候我们定义了通道的容量，但通道里的容量已经放不下新的数据，而没有接收者接收数据，就会造成阻塞，而对于一个协程来说就会造成死锁：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tch6 :&#x3D; make(chan bool, 1)\n\tch6 &lt;- true\n\tch6 &lt;- false\n\tfmt.Println(&lt;-ch6)\n&#125;</code></pre>\n<p>同理，当程序一直在等待从通道里读取数据，而此时并没有发送者会往通道中写入数据。此时程序就会陷入死循环，造成死锁。</p>\n<h3 id=\"WaitGroup\"><a href=\"#WaitGroup\" class=\"headerlink\" title=\"WaitGroup\"></a>WaitGroup</h3><p>在实际开发中我们并不能保证每个协程执行的时间，如果需要等待多个协程，全部结束任务后，再执行某个业务逻辑。下面我们介绍处理这种情况的方式。</p>\n<p><code>WaitGroup</code> 有几个方法：</p>\n<ul>\n<li><code>Add</code>：初始值为 <code>0</code> ，这里直接传入子协程的数量，你传入的值会往计数器上加。</li>\n<li><code>Done</code>：当某个子协程完成后，可调用此方法，会从计数器上减一，即子协程的数量减一，通常使用 <code>defer</code> 来调用。</li>\n<li><code>Wait</code>：阻塞当前协程，直到实例里的计数器归零。</li>\n</ul>\n<h4 id=\"使用信道\"><a href=\"#使用信道\" class=\"headerlink\" title=\"使用信道\"></a>使用信道</h4><p>信道可以实现多个协程间的通信，于是乎我们可以定义一个信道，在任务执行完成后，往信道中写入 <code>true</code> ，然后在主协程中获取到 <code>true</code> ，就可以认为子协程已经执行完毕。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tisDone :&#x3D; make(chan bool)\n\tgo func() &#123;\n\t\tfor i :&#x3D; 0; i &lt; 5; i++&#123;\n\t\t\tfmt.Println(i)\n\t\t&#125;\n\t\tisDone &lt;- true\n\t&#125;()\n\t&lt;- isDone\n&#125;</code></pre>\n<p>运行上面的程序，主协程就会等待创建的协程执行完毕后退出。</p>\n<h4 id=\"使用-WaitGroup\"><a href=\"#使用-WaitGroup\" class=\"headerlink\" title=\"使用 WaitGroup\"></a>使用 WaitGroup</h4><p>使用上面的信道方法，虽然可行，但在你程序中使用很多协程的话，你的代码就会看起来很复杂，这里就要介绍一种更好的方法，那就是使用 <code>sync</code> 包中提供的 <strong>WaitGroup</strong> 类型。<code>WaitGroup</code> 用于等待一批 Go 协程执行结束。程序控制会一直阻塞，直到这些协程全部执行完毕。当然 <code>WaitGroup</code> 也可以用于实现工作池。</p>\n<p><code>WaitGroup</code> 实例化后就能使用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nvar name sync.WaitGroup</code></pre>\n<p>下面看具体示例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sync&quot;\n)\n\nfunc task(taskNum int, wg *sync.WaitGroup) &#123;\n\t&#x2F;&#x2F; 延迟调用 执行完子协程计数器减一\n\tdefer wg.Done()\n\t&#x2F;&#x2F; 输出任务号\n\tfor i :&#x3D; 0; i &lt; 3; i++ &#123;\n\t\tfmt.Printf(&quot;task %d: %d\\n&quot;, taskNum, i)\n\t&#125;\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 实例化 sync.WaitGroup\n\tvar waitGroup sync.WaitGroup\n\t&#x2F;&#x2F; 传入子协程的数量\n\twaitGroup.Add(3)\n\t&#x2F;&#x2F; 开启一个子协程 协程 1 以及 实例 waitGroup\n\tgo task(1, &amp;waitGroup)\n\t&#x2F;&#x2F; 开启一个子协程 协程 2 以及 实例 waitGroup\n\tgo task(2, &amp;waitGroup)\n\t&#x2F;&#x2F; 开启一个子协程 协程 3 以及 实例 waitGroup\n\tgo task(3, &amp;waitGroup)\n\t&#x2F;&#x2F; 实例 waitGroup 阻塞当前协程 等待所有子协程执行完\n\twaitGroup.Wait()\n&#125;</code></pre>\n<h2 id=\"Select\"><a href=\"#Select\" class=\"headerlink\" title=\"Select\"></a>Select</h2><p><strong>select</strong> 语句用在多个发送/接收通道操作中进行选择。</p>\n<ul>\n<li><code>select</code> 语句会一直阻塞，直到发送/接收操作准备就绪。</li>\n<li>如果有多个通道操作准备完毕， <code>select</code> 会随机地选取其中之一执行。</li>\n</ul>\n<p><code>select</code> 语法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nselect &#123;\n    case expression1:\n        code\n    case expression2:\n        code\n    default:\n        code\n&#125;</code></pre>\n<p>下面是使用 <code>select-case</code> 的一个简单例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 创建3个通道\n\tch1 :&#x3D; make(chan string, 1)\n\tch2 :&#x3D; make(chan string, 1)\n\tch3 :&#x3D; make(chan string, 1)\n\t&#x2F;&#x2F; 往通道 1 千朵玫瑰带来的黎明\n\tch1 &lt;- &quot;千朵玫瑰带来的黎明&quot;\n\t&#x2F;&#x2F; 往通道 2 发送数据 赤土之王3与三朝圣者\n\tch2 &lt;- &quot;赤土之王3与三朝圣者&quot;\n\t&#x2F;&#x2F; 往通道 3 发送数据 虚空劫灰往事书\n\tch3 &lt;- &quot;虚空劫灰往事书&quot;\n\n\tselect &#123;\n\t&#x2F;&#x2F; 如果从通道 1 收到数据\n\tcase message1 :&#x3D; &lt;-ch1:\n\t\tfmt.Println(&quot;ch1 received:&quot;, message1)\n\t&#x2F;&#x2F; 如果从通道 2 收到数据\n\tcase message2 :&#x3D; &lt;-ch2:\n\t\tfmt.Println(&quot;ch2 received:&quot;, message2)\n\t&#x2F;&#x2F; 如果从通道 3 收到数据\n\tcase message3 :&#x3D; &lt;-ch3:\n\t\tfmt.Println(&quot;ch3 received:&quot;, message3)\n\t&#x2F;&#x2F; 默认输出\n\tdefault:\n\t\tfmt.Println(&quot;No data received.&quot;)\n\t&#125;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/624e7c48dc784b6094bf33345d9ffee0.png\" alt=\"在这里插入图片描述\"></p>\n<p>上面的程序创建了 3 个通道，并在执行 <code>select</code> 语句之前往通道 1 、通道 2 和 通道 3 分别发送数据，在执行 <code>select</code> 语句时，如果有机会的话会运行所有表达式，只要其中一个通道接收到数据，那么就会执行对应的 <code>case</code> 代码，然后退出。所以运行该程序可能输出下面的语句：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">SHELL\nch3 received: 虚空劫灰往事书</code></pre>\n<p>也有可能输出下面的这条语句，具体看哪个通道首先接收到数据：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">SHELL\nch2 received: 赤土之王3与三朝圣者\nch1 received: 千朵玫瑰带来的黎明</code></pre>\n<h3 id=\"select-的应用\"><a href=\"#select-的应用\" class=\"headerlink\" title=\"select 的应用\"></a>select 的应用</h3><p>每个任务执行的时间不同，使用 <code>select</code> 语句等待相应的通道发出响应。<code>select</code> 会选择首先响应先完成的 task，而忽略其它的响应。使用这种方法，我们可以做多个 task，并给用户返回最快的 task 结果。</p>\n<p>下面的程序模拟了这种服务：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;time&quot;\n)\n\nfunc task1(ch chan string) &#123;\n\ttime.Sleep(5 * time.Second)\n\tch &lt;- &quot;正法炬书&quot;\n&#125;\n\nfunc task2(ch chan string) &#123;\n\ttime.Sleep(7 * time.Second)\n\tch &lt;- &quot;水天供书&quot;\n&#125;\n\nfunc task3(ch chan string) &#123;\n\ttime.Sleep(2 * time.Second)\n\tch &lt;- &quot;吉祥具书&quot;\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 创建两个通道\n\tch1 :&#x3D; make(chan string)\n\tch2 :&#x3D; make(chan string)\n\tch3 :&#x3D; make(chan string)\n\tgo task1(ch1)\n\tgo task2(ch2)\n\tgo task3(ch3)\n\n\tselect &#123;\n\t&#x2F;&#x2F; 如果从通道 1 收到数据\n\tcase message1 :&#x3D; &lt;-ch1:\n\t\tfmt.Println(&quot;ch1 received:&quot;, message1)\n\t&#x2F;&#x2F; 如果从通道 2 收到数据\n\tcase message2 :&#x3D; &lt;-ch2:\n\t\tfmt.Println(&quot;ch2 received:&quot;, message2)\n\t&#x2F;&#x2F; 如果从通道 3 收到数据\n\tcase message3 :&#x3D; &lt;-ch3:\n\t\tfmt.Println(&quot;ch3 received:&quot;, message3)\n\t&#125;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fbca2312cfb14b509a59a1d74e308144.png\" alt=\"在这里插入图片描述\"></p>\n<p>当然，上面的程序会发现，没有 <code>default</code> 分支，因为如果加了该默认分支，如果还没从通道接收到数据， <code>select</code> 语句就会直接执行 <code>default</code> 分支然后退出，而不是被阻塞。</p>\n<h3 id=\"造成死锁\"><a href=\"#造成死锁\" class=\"headerlink\" title=\"造成死锁\"></a>造成死锁</h3><p>上面的例子引出了一个新的问题，那就是如果没有 <code>default</code> 分支， <code>select</code> 就会阻塞，如果一直没有命中其中的某个 <code>case</code> 最后会造成死锁。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n)\n\nfunc main() &#123;\n    &#x2F;&#x2F; 创建两个通道\n    ch1 :&#x3D; make(chan string, 1)\n    ch2 :&#x3D; make(chan string, 1)\n    ch3 :&#x3D; make(chan string, 1)\n\n    select &#123;\n    &#x2F;&#x2F; 如果从通道 1 收到数据\n    case message1 :&#x3D; &lt;-ch1:\n        fmt.Println(&quot;ch1 received:&quot;, message1)\n    &#x2F;&#x2F; 如果从通道 2 收到数据\n    case message2 :&#x3D; &lt;-ch2:\n        fmt.Println(&quot;ch2 received:&quot;, message2)\n\t&#x2F;&#x2F; 如果从通道 3 收到数据\n    case message3 :&#x3D; &lt;-ch3:\n        fmt.Println(&quot;ch3 received:&quot;, message3)\n    &#125;\n&#125;</code></pre>\n<p>运行上面的程序会造成死锁。解决该问题的方法是写好 <code>default</code> 分支。</p>\n<p>当然还有另一种情况会导致死锁的发生，那就是使用空 <code>select</code> ：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nfunc main() &#123;\n    select &#123;&#125;\n&#125;</code></pre>\n<p>运行上面的程序会抛出 <code>panic</code> 。</p>\n<p><strong>Tips：</strong></p>\n<ul>\n<li>前面学习 <code>switch-case</code> 的时候，里面的 <code>case</code> 是顺序执行的，但在 <code>select</code> 里并不是顺序执行的。在上面的第一个例子就可以看出，当 <code>select</code> 由多个 <code>case</code> 准备就绪时，将会随机地选取其中之一去执行。</li>\n</ul>\n<h3 id=\"select-超时处理\"><a href=\"#select-超时处理\" class=\"headerlink\" title=\"select 超时处理\"></a>select 超时处理</h3><p>当 <code>case</code> 里的通道始终没有接收到数据时，而且也没有 <code>default</code> 语句时， <code>select</code> 整体就会阻塞，但是有时我们并不希望 <code>select</code> 一直阻塞下去，这时候就可以手动设置一个超时时间。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;time&quot;\n)\n\nfunc makeTimeout(ch chan bool, t int) &#123;\n    time.Sleep(time.Second * time.Duration(t))\n    ch &lt;- true\n&#125;\n\nfunc main() &#123;\n    c1 :&#x3D; make(chan string, 1)\n    c2 :&#x3D; make(chan string, 1)\n    c3 :&#x3D; make(chan string, 1)\n    timeout :&#x3D; make(chan bool, 1)\n\n    go makeTimeout(timeout, 2)\n\n    select &#123;\n    case msg1 :&#x3D; &lt;-c1:\n        fmt.Println(&quot;c1 received: &quot;, msg1)\n    case msg2 :&#x3D; &lt;-c2:\n        fmt.Println(&quot;c2 received: &quot;, msg2)\n    case msg3 :&#x3D; &lt;-c3:\n        fmt.Println(&quot;c3 received: &quot;, msg3)\n    case &lt;-timeout:\n        fmt.Println(&quot;Timeout, exit.&quot;)\n    &#125;\n&#125;</code></pre>\n<h3 id=\"读取-写入数据\"><a href=\"#读取-写入数据\" class=\"headerlink\" title=\"读取/写入数据\"></a>读取/写入数据</h3><p><code>select</code> 里的 <code>case</code> 表达式只能对通道进行操作，不管你是往通道写入数据，还是从通道读出数据。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n)\n\nfunc main() &#123;\n    c1 :&#x3D; make(chan string, 2)\n\n    c1 &lt;- &quot;千朵玫瑰带来的黎明&quot;\n    select &#123;\n    case c1 &lt;- &quot;捕风的异乡人&quot;:\n        fmt.Println(&quot;c1 received: &quot;, &lt;-c1)\n        fmt.Println(&quot;c1 received: &quot;, &lt;-c1)\n    default:\n        fmt.Println(&quot;channel blocking&quot;)\n    &#125;\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/77f76c9fae9948259707dc0b23b76061.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h2><p>在 Go 语言中，经常会遇到并发的问题，当然我们会优先考虑使用通道，同时 Go 语言也给出了传统的解决方式 <strong>Mutex(互斥锁)</strong> 和 <strong>RWMutex(读写锁)</strong> 来处理竞争条件。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\npackage main\ntype Bank struct &#123;\n    balance int\n&#125;\n\nfunc (b *Bank) Deposit(amount int) &#123;\n    b.balance +&#x3D; amount\n&#125;\n\nfunc (b *Bank) Balance() int &#123;\n    return b.balance\n&#125;\n\nfunc main() &#123;\n    b :&#x3D; &amp;Bank&#123;&#125;\n\n    b.Deposit(1000)\n    b.Deposit(1000)\n    b.Deposit(1000)\n\n    fmt.Println(b.Balance())  &#x2F;&#x2F;3000\n&#125;</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>3000</p></blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/65281ac472b34faaa90fe44a578164e7.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h3><p>首先我们要理解并发编程中临界区的概念。当程序并发地运行时，多个 Go 协程不应该同时访问那些修改共享资源的代码。这些修改共享资源的代码称为<strong>临界区</strong> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc main() &#123;\n    var wg sync.WaitGroup\n    b :&#x3D; &amp;Bank&#123;&#125;\n\n    n :&#x3D; 1000\n    wg.Add(n)\n    for i :&#x3D; 1; i &lt;&#x3D; n; i++ &#123;\n        go func() &#123;\n            b.Deposit(1000)\n            wg.Done()\n        &#125;()\n    &#125;\n    wg.Wait()\n    fmt.Println(b.Balance())  &#x2F;&#x2F;972000,962000,941000\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/47346b051573419db256c90b89ef2a7f.png\" alt=\"在这里插入图片描述\"></p>\n<p>我们这里举一个简单的例子，当前变量的值增加 <code>b.balance += amount</code></p>\n<p>当然，对于只有一个协程的程序来说，上面的代码没有任何问题。但是，如果有多个协程并发运行时，就会发生错误，这种情况就称之为数据竞争(data race)。使用下面的互斥锁 <code>Mutex</code> 就能避免这种情况的发生。</p>\n<h3 id=\"互斥锁-Mutex\"><a href=\"#互斥锁-Mutex\" class=\"headerlink\" title=\"互斥锁 Mutex\"></a>互斥锁 Mutex</h3><p><strong>互斥锁(Mutex，mutual exclusion)</strong> 用于提供一种 <strong>加锁机制(Locking Mechanism)</strong> ，可确保在某时刻只有一个协程在临界区运行，以防止出现竞争。也是为了来保护一个资源不会因为并发操作而引起冲突导致数据不准确。</p>\n<p><code>Mutex</code> 有两个方法，分别是 <code>Lock()</code> 和 <code>Unlock()</code> ，即对应的加锁和解锁。在 <code>Lock()</code> 和 <code>Unlock()</code> 之间的代码，都只能由一个协程执行，就能避免竞争条件。</p>\n<p>如果有一个协程已经持有了<strong>锁(Lock)</strong>，当其他协程试图获得该锁时，这些协程会被阻塞，直到<code>Mutex</code>解除锁定。</p>\n<p>下面使用一个例子来讲一讲互斥锁的使用 ：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;sync&quot;\n)\n\ntype BankV2 struct &#123;\n    balance int\n    m       sync.Mutex\n&#125;\n\nfunc (b *BankV2) Deposit(amount int) &#123;\n    b.m.Lock()\n    b.balance +&#x3D; amount\n    b.m.Unlock()\n&#125;\n\nfunc (b *BankV2) Balance() int &#123;\n    return b.balance\n&#125;\n\nfunc main() &#123;\n    var wg sync.WaitGroup\n    b :&#x3D; &amp;BankV2&#123;&#125;\n\n    n :&#x3D; 1000\n    wg.Add(n)\n    for i :&#x3D; 1; i &lt;&#x3D; n; i++ &#123;\n        go func() &#123;\n            b.Deposit(1000)\n            wg.Done()\n        &#125;()\n    &#125;\n    wg.Wait()\n    fmt.Println(b.Balance()) &#x2F;&#x2F;1000000\n&#125;</code></pre>\n<p>为了解决竞争问题，我们就要对 <code>Deposit</code> 这个方法中加上互斥锁，使同一时刻，只能有一个协程对 <code>balance</code> 进行操作：</p>\n<p>更改后的代码不管运行多少次，都只会输出一个结果，那就是 <code>1000000</code> 。</p>\n<p>使用互斥锁很简单，但要注意同一协程里不要在尚未解锁时再次加锁，也不要对已经解锁的锁再次解锁。</p>\n<p>当然，使用通道也可以处理竞争条件，把通道作为锁在前面讲通道的时候已经讲过，这里就不再赘述。</p>\n<h3 id=\"读写锁-RWMutex\"><a href=\"#读写锁-RWMutex\" class=\"headerlink\" title=\"读写锁 RWMutex\"></a>读写锁 RWMutex</h3><p><code>sync.RWMutex</code> 类型实现读写互斥锁，适用于读多写少的场景，它规定了当有人还在读取数据（即读锁占用）时，不允许有人更新这个数据（即写锁会阻塞）；为了保证程序的效率，多个人（协程）读取数据（拥有读锁）时，互不影响不会造成阻塞，它不会像 <code>Mutex</code> 那样只允许有一个人（协程）读取同一个数据。读锁与读锁兼容，读锁与写锁互斥，写锁与写锁互斥。</p>\n<ul>\n<li>可以同时申请多个读锁；</li>\n<li>有读锁时申请写锁将阻塞，有写锁时申请读锁将阻塞；</li>\n<li>只要有写锁，后续申请读锁和写锁都将阻塞。</li>\n</ul>\n<p>定义一个 <code>RWMuteux</code> 读写锁：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nvar rwMutex sync.RWMutex</code></pre>\n<p><code>RWMutex</code> 里提供了两种锁，每种锁分别对应两个方法，为了避免死锁，两个方法应成对出现，必要时请使用 <code>defer</code> 。</p>\n<ul>\n<li>读锁：调用 <code>RLock</code> 方法开启锁，调用 <code>RUnlock</code> 释放锁；</li>\n<li>写锁：调用 <code>Lock</code> 方法开启锁，调用 <code>Unlock</code> 释放锁。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;sync&quot;\n    &quot;time&quot;\n)\n\ntype BankV3 struct &#123;\n    balance int\n    rwMutex sync.RWMutex &#x2F;&#x2F; read write lock\n&#125;\n\nfunc (b *BankV3) Deposit(amount int) &#123;\n    b.rwMutex.Lock() &#x2F;&#x2F; write lock\n    b.balance +&#x3D; amount\n    b.rwMutex.Unlock() &#x2F;&#x2F; wirte unlock\n&#125;\n\nfunc (b *BankV3) Balance() (balance int) &#123;\n    b.rwMutex.RLock() &#x2F;&#x2F; read lock\n    balance &#x3D; b.balance\n    b.rwMutex.RUnlock() &#x2F;&#x2F; read unlock\n    return\n&#125;\n\nfunc main() &#123;\n    var wg sync.WaitGroup\n    b :&#x3D; &amp;BankV3&#123;&#125;\n\n    n :&#x3D; 1000\n    wg.Add(n)\n    for i :&#x3D; 1; i &lt;&#x3D; n; i++ &#123;\n        go func() &#123;\n            b.Deposit(1000)\n            wg.Done()\n        &#125;()\n    &#125;\n    wg.Wait()\n    fmt.Println(b.Balance())\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/1ca5f6ff699240a983f36f6401dbaad9.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"条件变量-sync-Cond\"><a href=\"#条件变量-sync-Cond\" class=\"headerlink\" title=\"条件变量 sync.Cond\"></a>条件变量 sync.Cond</h3><p>Cond 实现了一个条件变量，在 Locker 的基础上增加的一个消息通知的功能，保存了一个通知列表，用来唤醒一个或所有因等待条件变量而阻塞的 Go 程，以此来实现多个 Go 程间的同步。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ntype Cond struct &#123;\n    ...\n    L Locker\n    ...\n&#125;\n\n&#x2F;&#x2F; 创建一个带锁的条件变量，Locker 通常是一个 *Mutex 或 *RWMutex\nfunc NewCond(l Locker) *Cond\n\n&#x2F;&#x2F; 唤醒所有因等待条件变量 c 阻塞的 goroutine\nfunc (c *Cond) Broadcast()\n\n&#x2F;&#x2F; 唤醒一个因等待条件变量 c 阻塞的 goroutine\nfunc (c *Cond) Signal()\n\n&#x2F;&#x2F; 等待 c.L 解锁并挂起 goroutine，在稍后恢复执行后，Wait 返回前锁定 c.L，\n&#x2F;&#x2F; 只有当被 Broadcast 和 Signal 唤醒，Wait 才能返回。\nfunc (c *Cond) Wait()</code></pre>\n<p>注意：在调用 Signal，Broadcast 之前，应确保目标 Go 程进入 Wait 阻塞状态。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;os&quot;\n\t&quot;os&#x2F;signal&quot;\n\t&quot;sync&quot;\n\t&quot;time&quot;\n)\n\nfunc listen(name string, s []string, c *sync.Cond) &#123;\n\tc.L.Lock()\n\tc.Wait()\n\tfmt.Println(name, &quot; 大梦的曲调:&quot;, s)\n\tc.L.Unlock()\n&#125;\n\nfunc broadcast(event string, c *sync.Cond) &#123;\n\ttime.Sleep(time.Second)\n\tc.L.Lock()\n\tfmt.Println(event)\n\tc.Broadcast()\n\tc.L.Unlock()\n&#125;\n\nfunc main() &#123;\n\ts1 :&#x3D; []string&#123;&quot;兰拉娜&quot;&#125;\n\ts2 :&#x3D; []string&#123;&quot;兰犍多&quot;&#125;\n\ts3 :&#x3D; []string&#123;&quot;兰荼茶&quot;&#125;\n\tvar m sync.Mutex\n\tcond :&#x3D; sync.NewCond(&amp;m)\n\n\t&#x2F;&#x2F; listener 1\n\tgo listen(&quot;林中奇遇&quot;, s1, cond)\n\n\t&#x2F;&#x2F; listener 2\n\tgo listen(&quot;原为一炊之梦&quot;, s2, cond)\n\n\t&#x2F;&#x2F; listener 3\n\tgo listen(&quot;为了所有的孩子们&quot;, s3, cond)\n\n\t&#x2F;&#x2F; broadcast\n\tgo broadcast(&quot;森林会记住一切:&quot;, cond)\n\n\tch :&#x3D; make(chan os.Signal, 1)\n\tsignal.Notify(ch, os.Interrupt)\n\t&lt;-ch\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/bd0a30959713487caf4adf2b094e3d66.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"错误与异常\"><a href=\"#错误与异常\" class=\"headerlink\" title=\"错误与异常\"></a>错误与异常</h2><h3 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h3><h4 id=\"内建错误\"><a href=\"#内建错误\" class=\"headerlink\" title=\"内建错误\"></a>内建错误</h4><p>在 Go 中， <strong>错误</strong> 使用内建的 <code>error</code> 类型表示。<code>error</code> 类型是一个接口类型，它的定义如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ntype error interface &#123;\n    Error() string\n&#125;</code></pre>\n<p><code>error</code> 有了一个签名为 <code>Error() string</code> 的方法。所有实现该接口的类型都可以当作一个错误类型。<code>Error()</code> 方法给出了错误的描述。<code>fmt.Println</code> 在打印错误时，会在内部调用 <code>Error() string</code> 方法来得到该错误的描述。</p>\n<p>下面的例子演示了程序尝试打开一个不存在的文件导致的报错：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;os&quot;\n)\n\nfunc main() &#123;\n    &#x2F;&#x2F; 尝试打开文件\n    file, err :&#x3D; os.Open(&quot;&#x2F;a.txt&quot;)\n    &#x2F;&#x2F; 如果打开文件时发生错误 返回一个不等于 nil 的错误\n    if err !&#x3D; nil &#123;\n        fmt.Println(err)\n        return\n    &#125;\n    &#x2F;&#x2F; 如果打开文件成功 返回一个文件句柄 和 一个值为 nil 的错误\n    fmt.Println(file.Name(), &quot;opened successfully&quot;)\n&#125;</code></pre>\n<p>我们这里没有存在一个文件 <code>a.txt</code> ，所以尝试打开文件将会返回一个不等于 <code>nil</code> 的错误。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nopen &#x2F;a.txt: The system cannot find the file specified.</code></pre>\n<h4 id=\"自定义错误\"><a href=\"#自定义错误\" class=\"headerlink\" title=\"自定义错误\"></a>自定义错误</h4><p>使用 <code>errors</code> 包中的 <code>New</code> 函数可以创建自定义错误。下面是 <code>errors</code> 包中 <code>New</code> 函数的实现代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage errors\n\nfunc New(text string) error &#123;\n    return &amp;errorString&#123;text&#125;\n&#125;\n\ntype errorString struct &#123;\n    s string\n&#125;\n\nfunc (e *errorString) Error() string &#123;\n    return e.s\n&#125;</code></pre>\n<p><code>errorString</code> 是一个结构体类型，只有一个字符串字段 <code>s</code> 。它使用了 <code>errorString</code> 指针接受者，来实现 <code>error</code> 接口的 <code>Error() string</code> 方法。<code>New</code> 函数有一个字符串参数，通过这个参数创建了 <code>errorString</code> 类型的变量，并返回了它的地址。于是它就创建并返回了一个新的错误。</p>\n<p>下面是一个简单的自定义错误例子，该例子创建了一个计算矩形面积的函数，当矩形的长和宽两者有一个为负数时，就会返回一个错误：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;errors&quot;\n    &quot;fmt&quot;\n)\n\nfunc area(a, b int) (int, error) &#123;\n    if a &lt; 0 || b &lt; 0 &#123;\n        return 0, errors.New(&quot;计算错误, 长度或宽度，不能小于0.&quot;)\n    &#125;\n    return a * b, nil\n&#125;\nfunc main() &#123;\n    a :&#x3D; 100\n    b :&#x3D; -10\n    r, err :&#x3D; area(a, b)\n    if err !&#x3D; nil &#123;\n        fmt.Println(err)\n        return\n    &#125;\n    fmt.Println(&quot;Area &#x3D;&quot;, r)\n&#125;</code></pre>\n<p>运行上面的程序会报出自定义的错误：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n计算错误, 长度或宽度，不能小于0.</code></pre>\n<h4 id=\"给错误添加更多信息\"><a href=\"#给错误添加更多信息\" class=\"headerlink\" title=\"给错误添加更多信息\"></a>给错误添加更多信息</h4><p>上面的程序能报出我们自定义的错误，但是没有具体说明是哪个数据出了问题，所以下面就来改进一下这个程序，我们使用 <code>fmt</code> 包中的 <code>Errorf</code> 函数，规定错误格式，并返回一个符合该错误的字符串。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n)\n\nfunc area(a, b int) (int, error) &#123;\n    if a &lt; 0 || b &lt; 0 &#123;\n        return 0, fmt.Errorf(&quot;计算错误, 长度%d或宽度%d，不能小于0&quot;, a, b)\n    &#125;\n    return a * b, nil\n&#125;\nfunc main() &#123;\n    a :&#x3D; 100\n    b :&#x3D; -10\n    area, err :&#x3D; area(a, b)\n    if err !&#x3D; nil &#123;\n        fmt.Println(err)\n        return\n    &#125;\n    fmt.Println(&quot;Area &#x3D;&quot;, area)\n&#125;</code></pre>\n<p>运行上面的程序，我们可以看到输出的错误中打印了长度和宽度的具体值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n计算错误, 长度100或宽度-10，不能小于0</code></pre>\n<p>当然，给错误添加更多信息还可以 <strong>使用结构体类型和字段</strong> 实现。下面还是通过改进上面的程序来讲解这种方法的实现：</p>\n<p>首先创建一个表示错误的结构体类型，一般错误类型名称都是以 <code>Error</code> 结尾，上面的错误是由于面积计算中长度或宽度错误导致的，所以这里把结构体命名为 <code>areaError</code> ：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n)\n\ntype areaError struct &#123;\n    &#x2F;&#x2F; 错误信息\n    err string\n    &#x2F;&#x2F; 错误有关的长度\n    length int\n    &#x2F;&#x2F; 错误有关的宽度\n    width int\n&#125;\n\n&#x2F;&#x2F; 使用指针接收者 *areaError 实现了 error 接口的 Error() string 方法\nfunc (e *areaError) Error() string &#123;\n    &#x2F;&#x2F; 打印长度和宽度以及错误的描述\n    return fmt.Sprintf(&quot;length %d, width %d : %s&quot;, e.length, e.width, e.err)\n&#125;\n\nfunc rectangleArea(a, b int) (int, error) &#123;\n    if a &lt; 0 || b &lt; 0 &#123;\n        return 0, &amp;areaError&#123;&quot;length or width is negative&quot;, a, b&#125;\n    &#125;\n    return a * b, nil\n&#125;\nfunc main() &#123;\n    a :&#x3D; 100\n    b :&#x3D; -10\n    area, err :&#x3D; rectangleArea(a, b)\n    &#x2F;&#x2F; 检查了错误是否为 nil\n    if err !&#x3D; nil &#123;\n        &#x2F;&#x2F; 断言 *areaError 类型\n        if err, ok :&#x3D; err.(*areaError); ok &#123;\n            &#x2F;&#x2F; 如果错误是 *areaError 类型\n            &#x2F;&#x2F; 用 err.length 和 err.width 来获取错误的长度和宽度 打印出自定义错误的消息\n            fmt.Printf(&quot;length %d or width %d is less than zero&quot;, err.length, err.width)\n            return\n        &#125;\n        fmt.Println(err)\n        return\n    &#125;\n    fmt.Println(&quot;Area &#x3D;&quot;, area)\n&#125;</code></pre>\n<p>运行该程序输出如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nlength 100 or width -10 is less than zero</code></pre>\n<p>当然，我们还可以使用 <strong>结构体类型的方法</strong> 来给错误添加更多信息。下面我们继续完善上面的程序，让程序更加精确的定位是长度引发的错误还是宽度引发的错误。</p>\n<p>首先，我们还是跟上面一样创建一个表示错误的结构体：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n)\n\ntype areaError struct &#123;\n    &#x2F;&#x2F; 错误信息\n    err string\n    &#x2F;&#x2F; 长度\n    length int\n    &#x2F;&#x2F; 宽度\n    width int\n&#125;\n\n&#x2F;&#x2F; 使用指针接收者 *areaError 实现了 error 接口的 Error() string 方法\nfunc (e *areaError) Error() string &#123;\n    return e.err\n&#125;\n\n&#x2F;&#x2F; 长度为负数返回 true\nfunc (e *areaError) lengthNegative() bool &#123;\n    return e.length &lt; 0\n&#125;\n\n&#x2F;&#x2F; 宽度为负数返回 true\nfunc (e *areaError) widthNegative() bool &#123;\n    return e.width &lt; 0\n&#125;\n\nfunc area(length, width int) (int, error) &#123;\n    err :&#x3D; &quot;&quot;\n    if length &lt; 0 &#123;\n        err +&#x3D; &quot;length is less than zero&quot;\n    &#125;\n    if width &lt; 0 &#123;\n        if err &#x3D;&#x3D; &quot;&quot; &#123;\n            err &#x3D; &quot;width is less than zero&quot;\n        &#125; else &#123;\n            err +&#x3D; &quot; and width is less than zero&quot;\n        &#125;\n    &#125;\n    if err !&#x3D; &quot;&quot; &#123;\n        return 0, &amp;areaError&#123;err, length, width&#125;\n    &#125;\n    return length * width, nil\n&#125;\n\nfunc main() &#123;\n    length :&#x3D; 100\n    width :&#x3D; -10\n    area, err :&#x3D; area(length, width)\n    &#x2F;&#x2F; 检查了错误是否为 nil\n    if err !&#x3D; nil &#123;\n        &#x2F;&#x2F; 断言 *areaError 类型\n        if err, ok :&#x3D; err.(*areaError); ok &#123;\n            &#x2F;&#x2F; 如果错误是 *areaError 类型\n            &#x2F;&#x2F; 如果长度为负数 打印错误长度具体值\n            if err.lengthNegative() &#123;\n                fmt.Printf(&quot;error: 长度 %d 小于0\\n&quot;, err.length)\n            &#125;\n            &#x2F;&#x2F; 如果宽度为负数 打印错误宽度具体值\n            if err.widthNegative() &#123;\n                fmt.Printf(&quot;error: 宽度 %d 小于0\\n&quot;, err.width)\n            &#125;\n            return\n        &#125;\n        fmt.Println(err)\n        return\n    &#125;\n    fmt.Println(&quot;Area &#x3D;&quot;, area)\n&#125;</code></pre>\n<p>还是使用之前的例子中的参数，但我们这次报错结果更加具体，运行该程序输出如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nerror: width -10 is less than zero</code></pre>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>错误和异常是两个不同的概念，非常容易混淆。错误指的是可能出现问题的地方出现了问题；而异常指的是不应该出现问题的地方出现了问题。</p>\n<h4 id=\"panic\"><a href=\"#panic\" class=\"headerlink\" title=\"panic\"></a>panic</h4><p>在有些情况，当程序发生异常时，无法继续运行。在这种情况下，我们会使用 <code>panic</code> 来终止程序。当函数发生 <code>panic</code> 时，它会终止运行，在执行完所有的延迟函数后，程序返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 <code>panic</code> 信息，接着打印出堆栈跟踪，最后程序终止。</p>\n<p>我们应该尽可能地使用错误，而不是使用 <code>panic</code> 和 <code>recover</code> 。只有当程序不能继续运行的时候，才应该使用 <code>panic</code> 和 <code>recover</code> 机制。</p>\n<p><code>panic</code> 有两个合理的用例：</p>\n<ul>\n<li>发生了一个不能恢复的错误，此时程序不能继续运行。一个例子就是 web 服务器无法绑定所要求的端口。在这种情况下，就应该使用 <code>panic</code> ，因为如果不能绑定端口，啥也做不了。</li>\n<li>发生了一个编程上的错误。假如我们有一个接收指针参数的方法，而其他人使用 <code>nil</code> 作为参数调用了它。在这种情况下，我们可以使用 <code>panic</code> ，因为这是一个编程错误：用 <code>nil</code> 参数调用了一个只能接收合法指针的方法。</li>\n</ul>\n<h4 id=\"触发-panic\"><a href=\"#触发-panic\" class=\"headerlink\" title=\"触发 panic\"></a>触发 panic</h4><p>下面是内建函数 <code>panic</code> 的签名：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc panic(v interface&#123;&#125;)</code></pre>\n<p>当程序终止时，会打印传入 <code>panic</code> 的参数。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nfunc main() &#123;\n    panic(&quot;panic error&quot;)\n&#125;</code></pre>\n<p>运行上面的程序，会打印出传入 <code>panic</code> 函数的信息，并打印出堆栈跟踪：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npanic: panic error</code></pre>\n<h4 id=\"发生-panic-时的-defer\"><a href=\"#发生-panic-时的-defer\" class=\"headerlink\" title=\"发生 panic 时的 defer\"></a>发生 panic 时的 defer</h4><p>上面已经提到了，当函数发生 <code>panic</code> 时，它会终止运行，在执行完所有的延迟函数后，程序返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 <code>panic</code> 信息，接着打印出堆栈跟踪，最后程序终止。下面通过一个简单的例子看看是不是这样：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc myTest() &#123;\n    defer fmt.Println(&quot;defer myTest&quot;)\n    panic(&quot;panic myTest&quot;)\n&#125;\nfunc main() &#123;\n    defer fmt.Println(&quot;defer main&quot;)\n    myTest()\n&#125;</code></pre>\n<p>运行该程序后输出如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ndefer myTest\ndefer main\npanic: panic myTest</code></pre>\n<h4 id=\"recover\"><a href=\"#recover\" class=\"headerlink\" title=\"recover\"></a>recover</h4><p><code>recover</code> 是一个内建函数，用于重新获得 <code>panic</code> 协程的控制。下面是内建函数 <code>recover</code> 的签名：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc recover() interface&#123;&#125;</code></pre>\n<p><code>recover</code> 必须在 <code>defer</code> 函数中才能生效，在其他作用域下，它是不工作的。在延迟函数内调用 <code>recover</code> ，可以取到 <code>panic</code> 的错误信息，并且停止 <code>panic</code> 续发事件，程序运行恢复正常。下面是网上找的一个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc outOfArray(x int) &#123;\n    defer func() &#123;\n        &#x2F;&#x2F; recover() 可以将捕获到的 panic 信息打印\n        if err :&#x3D; recover(); err !&#x3D; nil &#123;\n            fmt.Println(err)\n        &#125;\n    &#125;()\n    var array [5]int\n    array[x] &#x3D; 1\n&#125;\nfunc main() &#123;\n    &#x2F;&#x2F; 故意制造数组越界 触发 panic\n    outOfArray(20)\n    &#x2F;&#x2F; 如果能执行到这句 说明 panic 被捕获了\n    &#x2F;&#x2F; 后续的程序能继续运行\n    fmt.Println(&quot;main...&quot;)\n&#125;</code></pre>\n<p>虽然该程序触发了 <code>panic</code> ，但由于我们使用了 <code>recover()</code> 捕获了 <code>panic</code> 异常，并输出 <code>panic</code> 信息，即使 <code>panic</code> 会导致整个程序退出，但在退出前，有 <code>defer</code> 延迟函数，还是得执行完 <code>defer</code> 。然后程序还会继续执行下去：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nruntime error: index out of range [20] with length 5\nmain...</code></pre>\n<p>这里要注意一点，只有在相同的协程中调用 <code>recover</code> 才管用， <code>recover</code> 不能恢复一个不同协程的 <code>panic</code> 。</p>\n<h2 id=\"make-和-new\"><a href=\"#make-和-new\" class=\"headerlink\" title=\"make 和 new\"></a>make 和 new</h2><p>内置函数 <code>new</code> 分配内存。该函数只接受一个参数，该参数是一个任意类型(包括自定义类型)，而不是值，返回指向该类型新分配零值的指针。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; The new built-in function allocates memory. The first argument is a type,\n&#x2F;&#x2F; not a value, and the value returned is a pointer to a newly\n&#x2F;&#x2F; allocated zero value of that type.\nfunc new(Type) *Type</code></pre>\n<p>使用 <code>new</code> 函数首先会分配内存，并设置类型零值，最后返回指向该类型新分配零值的指针。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n\t&quot;fmt&quot;\n)\n\nfunc main() &#123;\n\tnum :&#x3D; new(int)\n\t&#x2F;&#x2F; 打印出类型的值\n\tfmt.Println(*num)  &#x2F;&#x2F; 0\n&#125;</code></pre>\n<h3 id=\"make-函数\"><a href=\"#make-函数\" class=\"headerlink\" title=\"make 函数\"></a>make 函数</h3><p>内置函数 <code>make</code> 只能分配和初始化类型为 <code>slice</code> 、 <code>map</code> 或 <code>chan</code> 的对象。与 <code>new</code> 一样，第一个参数是类型，而不是值。与 <code>new</code> 不同， <code>make</code> 的返回类型与其参数的类型相同，而不是指向它的指针。结果取决于类型：</p>\n<ul>\n<li><code>slice</code>：size 指定长度。切片的容量等于其长度。可提供第三个参数以指定不同的容量；它不能小于长度。</li>\n<li><code>map</code>：为空映射分配足够的空间来容纳指定数量的元素。可以省略大小，在这种情况下，分配一个小的起始大小。</li>\n<li><code>chan</code>：使用指定的缓冲区容量初始化通道的缓冲区。如果为零，或者忽略了大小，则通道是无缓冲的。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nfunc make(t Type, size ...IntegerType) Type</code></pre>\n<p>注意，使用 make 函数必须初始化。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; slice\na :&#x3D; make([]int, 2, 10)\n\n&#x2F;&#x2F; map\nb :&#x3D; make(map[string]int)\n\n&#x2F;&#x2F; chan\nc :&#x3D; make(chan int, 10)</code></pre>\n<h3 id=\"new-和-make-的区别\"><a href=\"#new-和-make-的区别\" class=\"headerlink\" title=\"new 和 make 的区别\"></a>new 和 make 的区别</h3><p><code>new</code>：为所有的类型分配内存，并初始化为零值，返回指针。</p>\n<p><code>make</code>：只能为 <code>slice</code> 、 <code>map</code> 、 <code>chan</code> 分配内存，并初始化，返回的是类型。</p>\n<h2 id=\"头等函数\"><a href=\"#头等函数\" class=\"headerlink\" title=\"头等函数\"></a>头等函数</h2><p>Go 语言拥有 <strong>头等函数(First-class Function)</strong> ，头等函数是指函数可以被当作变量一样使用，即函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。</p>\n<h3 id=\"把函数赋值给变量\"><a href=\"#把函数赋值给变量\" class=\"headerlink\" title=\"把函数赋值给变量\"></a>把函数赋值给变量</h3><p>下面是一个把函数赋值给变量的例子，该函数没有名称，调用该函数的唯一方法就是使用赋值后的变量。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    bookFunc :&#x3D; func() &#123;\n        fmt.Println(&quot;《森林书》&quot;)\n    &#125;\n    bookFunc()\n    fmt.Printf(&quot;bookFunc 的类型是 %T\\n&quot;, bookFunc)\n&#125;</code></pre>\n<p>运行该程序输出如下：<br><img src=\"https://img-blog.csdnimg.cn/e0b913c61cc24053976199292da5912d.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n《森林书》\nbookFunc 的类型是 func()</code></pre>\n<h3 id=\"传递一个函数作为参数\"><a href=\"#传递一个函数作为参数\" class=\"headerlink\" title=\"传递一个函数作为参数\"></a>传递一个函数作为参数</h3><p>我们把 <strong>接收一个或多个函数作为参数</strong> 或者 <strong>返回值也是一个函数</strong> 的函数称为 <strong>高阶函数(Hiher-order Function)</strong> 。</p>\n<p>下面的是把函数作为参数，并传递给其他函数的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; printRes 接收一个函数参数\nfunc printRes(show func(author, book string) string) &#123;\n    fmt.Println(show(&quot;电子羊&quot;, &quot;《千朵玫瑰带来的黎明》&quot;))\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 创建匿名函数\n    f :&#x3D; func(x, y string) string &#123;\n       return x + y\n    &#125;\n    &#x2F;&#x2F; 把匿名函数作为参数传入另一个函数\n    printRes(f)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/0f671ebde99e499095dfe59c585297e7.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"返回一个函数\"><a href=\"#返回一个函数\" class=\"headerlink\" title=\"返回一个函数\"></a><strong>返回一个函数</strong></h3><p>下面的是函数返回一个函数的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; show 返回一个函数\nfunc show() func(author, book string) string &#123;\n    return func(x, y string) string &#123;\n        return x + y\n    &#125;\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 变量获取返回的函数\n    s :&#x3D; show()\n    &#x2F;&#x2F; 调用返回的函数\n    fmt.Println(s(&quot;电子羊&quot;, &quot;《为了没有眼泪的明天》&quot;))\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/5abf1ea9128546b8b4dce31e22bee92e.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p><strong>闭包(Closure)</strong> 是匿名函数的一个特例。当一个匿名函数所访问的变量定义在函数体的外部时，就称这样的匿名函数为闭包。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    x :&#x3D; 100\n    func() &#123;\n        fmt.Println(x)\n    &#125;()\n&#125;</code></pre>\n<h2 id=\"静态类型与动态类型\"><a href=\"#静态类型与动态类型\" class=\"headerlink\" title=\"静态类型与动态类型\"></a>静态类型与动态类型</h2><h3 id=\"静态类型-static-type\"><a href=\"#静态类型-static-type\" class=\"headerlink\" title=\"静态类型(static type)\"></a>静态类型(static type)</h3><p><strong>静态类型</strong>就是变量声明时候的类型。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; int 是静态类型\nvar number int\n&#x2F;&#x2F; string 也是静态类型\nvar name string</code></pre>\n<h3 id=\"动态类型-concrete-type\"><a href=\"#动态类型-concrete-type\" class=\"headerlink\" title=\"动态类型(concrete type)\"></a>动态类型(concrete type)</h3><p><strong>动态类型</strong>是程序运行时系统才能看见的类型。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; in 的静态类型为 interface&#123;&#125;\nvar in interface&#123;&#125;\n&#x2F;&#x2F; in 的静态类型为 interface&#123;&#125; 动态类型为 int\nin &#x3D; 100\n&#x2F;&#x2F; in 的静态类型为 interface&#123;&#125; 动态类型为 string\nin &#x3D; &quot;《千朵玫瑰带来的黎明》&quot;</code></pre>\n<p>通过上面的例子，可以看到我们定义了一个空接口 <code>in</code> ，它的静态类型永远是 <code>interface&#123;&#125;</code> ，但它可以接受任何类型，接受整型数据时，它的动态类型就为 <code>int</code> ；接受字符串型数据时，它的动态类型就变为 <code>string</code> 。</p>\n<h3 id=\"接口组成\"><a href=\"#接口组成\" class=\"headerlink\" title=\"接口组成\"></a>接口组成</h3><p>每个接口变量实际上都是由一 <code>pair</code> 对组成，其中记录了实际变量的值和类型。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\nvar number int &#x3D; 100</code></pre>\n<p>这里声明了一个类型为 <code>int</code> 的变量，变量名叫 <code>number</code> 值为 <code>100</code> 。知道了接口的组成，我们也可以使用下面的方式定义一个变量：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    number :&#x3D; (int)(100)\n    &#x2F;&#x2F; 或者写成 number :&#x3D; (interface&#123;&#125;)(100)\n    fmt.Printf(&quot;number type: %T, data: %v&quot;, number, number)\n&#125;</code></pre>\n<p>运行上面的程序输出如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">SHELL\nnumber type: int, data: 100</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/5430fb4fadc742029cbdf0ce8fc5422e.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h3 id=\"reflect-包\"><a href=\"#reflect-包\" class=\"headerlink\" title=\"reflect 包\"></a>reflect 包</h3><p>Go 语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法，而不需要在编译时就知道这些变量的具体类型。这种机制被称为 <strong>反射</strong> 。</p>\n<p>反射是把双刃剑，功能强大但代码可读性并不理想，若非必要并不推荐使用反射。</p>\n<p>在 Go 中 <code>reflect</code> 包实现了运行时反射。<code>reflect</code> 包会帮助识别 <code>interface&#123;&#125;</code> 变量的底层具体类型和具体值。</p>\n<h4 id=\"reflect-Type\"><a href=\"#reflect-Type\" class=\"headerlink\" title=\"reflect.Type\"></a>reflect.Type</h4><p><code>reflect.Type</code> 表示 <code>interface&#123;&#125;</code> 的具体类型。<code>reflect.TypeOf()</code> 方法返回 <code>reflect.Type</code> 。</p>\n<p>像我们之前讲过的空接口参数的函数，可以通过类型断言来判断传入变量的类型，也可以借助反射来确定传入变量的类型。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc reflectType(x interface&#123;&#125;) &#123;\n    obj :&#x3D; reflect.TypeOf(x)\n    fmt.Println(obj)\n&#125;\n\nfunc main() &#123;\n    var a int64 &#x3D; 123\n    reflectType(a)\n    var b string &#x3D; &quot;金色的那菈！&quot;\n    reflectType(b)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/456604490c904428bb62f3b087107456.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"reflect-Value\"><a href=\"#reflect-Value\" class=\"headerlink\" title=\"reflect.Value\"></a>reflect.Value</h4><p><code>reflect.Value</code> 表示 <code>interface&#123;&#125;</code> 的具体值。<code>reflect.ValueOf()</code> 方法返回 <code>reflect.Value</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc reflectType(x interface&#123;&#125;) &#123;\n    typeX :&#x3D; reflect.TypeOf(x)\n    valueX :&#x3D; reflect.ValueOf(x)\n    fmt.Println(typeX)\n    fmt.Println(valueX)\n&#125;\n\nfunc main() &#123;\n    var a int64 &#x3D; 123\n    reflectType(a)\n    var b string &#x3D; &quot;为了果实、种子还有树&quot;\n    reflectType(b)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/c5e4d611e13a47168fc7072ec19442d5.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"relfect-Kind\"><a href=\"#relfect-Kind\" class=\"headerlink\" title=\"relfect.Kind\"></a>relfect.Kind</h4><p><code>relfect.Kind</code> 表示的是种类。在使用反射时，需要理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。</p>\n<p>Go 语言程序中的类型（Type）指的是系统原生数据类型，如 <code>int</code> 、 <code>string</code> 、 <code>bool</code> 、 <code>float32</code> 等类型，以及使用 <code>type</code> 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 <code>type A struct&#123;&#125;</code> 定义结构体时，<code>A</code> 就是 <code>struct&#123;&#125;</code> 的类型。</p>\n<p>种类（Kind）指的是对象归属的品种，在 <code>reflect</code> 包中有如下定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; A Kind represents the specific kind of type that a Type represents.\n&#x2F;&#x2F; The zero Kind is not a valid kind.\ntype Kind uint\n\nconst (\n    Invalid Kind &#x3D; iota\n    Bool\n    Int\n    Int8\n    Int16\n    Int32\n    Int64\n    Uint\n    Uint8\n    Uint16\n    Uint32\n    Uint64\n    Uintptr\n    Float32\n    Float64\n    Complex64\n    Complex128\n    Array\n    Chan\n    Func\n    Interface\n    Map\n    Ptr\n    Slice\n    String\n    Struct\n    UnsafePointer\n)</code></pre>\n<p>通过下面这个程序，相信你会很容易明白这两者的区别：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc reflectType(x interface&#123;&#125;) &#123;\n    typeX :&#x3D; reflect.TypeOf(x)\n    fmt.Println(typeX.Kind()) &#x2F;&#x2F; struct\n    fmt.Println(typeX)        &#x2F;&#x2F; main.book\n&#125;\n\ntype book struct &#123;\n&#125;\n\nfunc main() &#123;\n    var b book\n    reflectType(b)\n&#125;</code></pre>\n<h4 id=\"relfect-NumField\"><a href=\"#relfect-NumField\" class=\"headerlink\" title=\"relfect.NumField()\"></a>relfect.NumField()</h4><p><code>relfect.NumField()</code> 方法返回结构体中字段的数量。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc reflectNumField(x interface&#123;&#125;) &#123;\n    &#x2F;&#x2F; 检查 x 的类别是 struct\n    if reflect.ValueOf(x).Kind() &#x3D;&#x3D; reflect.Struct &#123;\n        v :&#x3D; reflect.ValueOf(x)\n        fmt.Println(&quot;Number of fields&quot;, v.NumField())\n    &#125;\n&#125;\n\ntype book struct &#123;\n    name string\n    spend  int\n&#125;\n\nfunc main() &#123;\n    var b book\n    reflectNumField(b)\n&#125;</code></pre>\n<h3 id=\"relfect-Field\"><a href=\"#relfect-Field\" class=\"headerlink\" title=\"relfect.Field()\"></a>relfect.Field()</h3><p><code>relfect.Field(i int)</code> 方法返回字段 <code>i</code> 的 <code>reflect.Value</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc reflectNumField(x interface&#123;&#125;) &#123;\n    &#x2F;&#x2F; 检查 x 的类别是 struct\n    if reflect.ValueOf(x).Kind() &#x3D;&#x3D; reflect.Struct &#123;\n        v :&#x3D; reflect.ValueOf(x)\n        fmt.Println(&quot;Number of fields&quot;, v.NumField())\n        for i :&#x3D; 0; i &lt; v.NumField(); i++ &#123;\n            fmt.Printf(&quot;Field:%d type:%T value:%v\\n&quot;, i, v.Field(i), v.Field(i))\n        &#125;\n    &#125;\n&#125;\n\ntype book struct &#123;\n    name string\n    spend  int\n&#125;\n\nfunc main() &#123;\n    var b &#x3D; book&#123;&quot;《为了不再哭泣的孩子们》&quot;, 8&#125;\n    reflectNumField(a)\n&#125;</code></pre>\n<h3 id=\"反射的三大定律\"><a href=\"#反射的三大定律\" class=\"headerlink\" title=\"反射的三大定律\"></a>反射的三大定律</h3><p>之前在 <code>静态类型与动态类型</code>章节中讲过，一个接口变量，实际上都是由一 <code>pair</code> 对（type 和 data）组合而成，pair 对中记录着实际变量的值和类型。也就是说在真实世界（反射前环境）里，type 和 value 是合并在一起组成接口变量的。</p>\n<p>而在反射的世界（反射后的环境）里，type 和 data 却是分开的，他们分别由 <code>reflect.Type</code> 和 <code>reflect.Value</code> 来表现。</p>\n<p>Go 语言里有反射三定律，是你在学习反射时，很重要的参考：</p>\n<ol>\n<li>Reflection goes from interface value to reflection object.</li>\n<li>Reflection goes from reflection object to interface value.</li>\n<li>To modify a reflection object, the value must be settable.</li>\n</ol>\n<p>接下来我们就来讲一讲反射三大定律。</p>\n<h4 id=\"反射第一定律\"><a href=\"#反射第一定律\" class=\"headerlink\" title=\"反射第一定律\"></a>反射第一定律</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Reflection goes from interface value to reflection object.</p></blockquote>\n<p>反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”。</p>\n<p>这里反射类型指 <code>reflect.Type</code> 和 <code>reflect.Value</code> 。</p>\n<p>通过之前我们讲过的 <code>reflect.TypeOf()</code> 方法和 <code>reflect.ValueOf()</code> 方法可以分别获得接口值的类型和接口值的值。这两个方法返回的对象，我们称之为反射对象。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc main() &#123;\n    var a interface&#123;&#125; &#x3D; 3.14\n    fmt.Printf(&quot;接口变量的类型为 %T ，值为 %v\\n&quot;, a, a)\n    t :&#x3D; reflect.TypeOf(a)\n    v :&#x3D; reflect.ValueOf(a)\n    fmt.Printf(&quot;从接口变量到反射对象：Type对象类型为 %T\\n&quot;, t)\n    fmt.Printf(&quot;从接口变量到反射对象：Value对象类型为 %T\\n&quot;, v)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/da65b3da25854e378d67ca3cfe40f190.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到，使用 <code>reflect.TypeOf()</code> 和 <code>reflect.ValueOf()</code> 方法完成了从接口类型变量到反射对象的转换。在这里说接口类型是因为 <code>TypeOf</code> 和 <code>ValueOf</code> 两个函数接收的是 <code>interface&#123;&#125;</code> 空接口类型， Go 语言函数都是值传递，会将类型隐式转换成接口类型。</p>\n<h4 id=\"反射第二定律\"><a href=\"#反射第二定律\" class=\"headerlink\" title=\"反射第二定律\"></a>反射第二定律</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Reflection goes from reflection object to interface value.</p></blockquote>\n<p>反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”</p>\n<p>第二定律刚好和第一定律相反，第一定律讲的是从接口变量到反射对象的转换，而第二定律讲的是从反射对象到接口变量的转换。</p>\n<p>一个 <code>reflect.Value</code> 类型的变量，我们可以使用 <code>Interface</code> 方法恢复其接口类型的值。事实上，这个方法会把 <code>type</code> 和 <code>value</code> 信息打包并填充到一个接口变量中，然后返回。</p>\n<p>其函数声明如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; Interface returns v&#39;s current value as an interface&#123;&#125;.\n&#x2F;&#x2F; It is equivalent to:\n&#x2F;&#x2F;    var i interface&#123;&#125; &#x3D; (v&#39;s underlying value)\n&#x2F;&#x2F; It panics if the Value was obtained by accessing\n&#x2F;&#x2F; unexported struct fields.\nfunc (v Value) Interface() (i interface&#123;&#125;) &#123;\n    return valueInterface(v, true)\n&#125;</code></pre>\n<p>最后转换后的对象静态类型为 <code>interface&#123;&#125;</code>，我们可以使用类型断言转换为原始类型。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc main() &#123;\n    var a interface&#123;&#125; &#x3D; 3.14\n\n    fmt.Printf(&quot;接口变量的类型为 %T ，值为 %v\\n&quot;, a, a)\n\n    t :&#x3D; reflect.TypeOf(a)\n    v :&#x3D; reflect.ValueOf(a)\n\n    &#x2F;&#x2F; 反射第一定律\n    fmt.Printf(&quot;从接口变量到反射对象：Type对象类型为 %T\\n&quot;, t)\n    fmt.Printf(&quot;从接口变量到反射对象：Value对象类型为 %T\\n&quot;, v)\n\n    &#x2F;&#x2F; 反射第二定律\n    i :&#x3D; v.Interface()\n    fmt.Printf(&quot;从反射对象到接口变量：对象类型为 %T，值为 %v\\n&quot;, i, i)\n    &#x2F;&#x2F; 使用类型断言进行转换\n    x :&#x3D; v.Interface().(float64)\n    fmt.Printf(&quot;x 类型为 %T，值为 %v\\n&quot;, x, x)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/17490a8f303f460e92a8956df7ef6d26.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"反射第三定律\"><a href=\"#反射第三定律\" class=\"headerlink\" title=\"反射第三定律\"></a>反射第三定律</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>To modify a reflection object, the value must be settable.</p></blockquote>\n<p>反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”</p>\n<p>我们首先来看一看下面这段代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport &quot;reflect&quot;\n\nfunc main() &#123;\n    var a float64 &#x3D; 3.14\n    v :&#x3D; reflect.ValueOf(a)\n    v.SetFloat(2.1)\n&#125;</code></pre>\n<p>运行该代码段将会抛出异常：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npanic: reflect: reflect.Value.SetFloat using unaddressable value</code></pre>\n<p>这里你可能会疑惑，为什么这里会抛出寻址的异常，其实是因为这里的变量 <code>v</code> 是“不可写的”。<code>settable</code>（“可写性”）是反射类型变量的一个属性，但也不是说所有的反射类型变量都有这个属性。</p>\n<p>要想知道一个 <code>reflect.Value</code> 类型变量的“可写性”，我们可以使用 <code>CanSet</code> 方法来进行检查：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc main() &#123;\n    var a float64 &#x3D; 3.14\n    v :&#x3D; reflect.ValueOf(a)\n    fmt.Println(&quot;是否可写:&quot;, v.CanSet())\n&#125;</code></pre>\n<p>可以看到，我们这个变量 <code>v</code> 是不可写的。对于一个不可写的变量，使用 <code>Set</code> 方法会报错。这里实质上还是 Go 语言里的函数都是值传递问题，想象一下这里传递给 <code>reflect.ValueOf</code> 函数的是变量 <code>a</code> 的一个拷贝，而非 <code>a</code> 本身，所以如果对反射对象进行更新，其原始变量 <code>a</code> 根本不会受到影响，所以是不合法的，“可写性”就是为了避免这个问题而设计出来的。</p>\n<p>所以，要让反射对象具备“可写性”，一定要注意创建反射对象时要传入变量的指针，于是乎我们修改代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc main() &#123;\n    var a float64 &#x3D; 3.14\n    v :&#x3D; reflect.ValueOf(&amp;a)\n    fmt.Println(&quot;是否可写:&quot;, v.CanSet())\n&#125;</code></pre>\n<p>但运行该程序还是会输出不可写，因为事实上我们这里要修改的是该指针指向的数据，使用还要使用 <code>Value</code> 类型的 <code>Elem()</code> 方法，对指针进行“解引用”，该方法返回指针指向的数据。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\nfunc main() &#123;\n    var a float64 &#x3D; 3.14\n    v :&#x3D; reflect.ValueOf(&amp;a).Elem()\n    fmt.Println(&quot;是否可写:&quot;, v.CanSet())\n\n    v.SetFloat(2)\n    fmt.Println(v)\n&#125;</code></pre>\n<h2 id=\"结构体里的-Tag-标签\"><a href=\"#结构体里的-Tag-标签\" class=\"headerlink\" title=\"结构体里的 Tag 标签\"></a>结构体里的 Tag 标签</h2><p>在之前结构体的章节里我们讲过结构体的使用，一般情况下，我们定义结构体每个字段都是由字段名字以及字段的类型构成，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ntype Book struct &#123;\n    Name   string\n    Target string\n    Spend  int\n&#125;</code></pre>\n<h3 id=\"Tag-的使用\"><a href=\"#Tag-的使用\" class=\"headerlink\" title=\"Tag 的使用\"></a>Tag 的使用</h3><p>但这一章要讲的是在字段上增加一个属性，这个属性是用反引号括起来的一个字符串，我们称之为 <strong>Tag(标签)</strong> 。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\ntype Person struct &#123;\n    Name   string &#96;json:&quot;name&quot;&#96;\n    Target string &#96;json:&quot;target&quot;&#96;\n    Spend  int    &#96;json:&quot;spend,omitempty&quot;&#96;\n&#125;</code></pre>\n<p>结构体的 <code>Tag</code> 可以是任意的字符串面值，但是通常是一系列用空格分隔的 <code>key:&quot;value&quot;</code> 键值对序列；因为值中含有双引号字符，因此成员 <code>Tag</code> 一般用原生字符串面值的形式书写。一般我们常用在 <code>JSON</code> 的数据处理方面。</p>\n<p><code>json</code> 开头键名对应的值用于控制 <strong>encoding/json</strong> 包的编码和解码的行为，并且 <strong>encoding/…</strong> 下面其它的包也遵循这个约定。<code>Tag</code> 中 <code>json</code> 对应值的第一部分用于指定 <code>JSON</code> 对象的名字，比如将 Go 语言中的 <code>TotalCount</code> 成员对应到 <code>JSON</code> 中的 <code>total_count</code> 对象。</p>\n<p>上面的例子中 <code>gender</code> 字段的 <code>Tag</code> 还带了一个额外的 <code>omitempty</code> 选项，表示当 Go 语言结构体成员为空或零值时不生成该 <code>JSON</code> 对象（这里 <code>false</code> 为零值）。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n\t&quot;encoding&#x2F;json&quot;\n\t&quot;fmt&quot;\n)\n\ntype Book struct &#123;\n\tName   string &#96;json:&quot;name&quot;&#96;\n\tTarget string &#96;json:&quot;target&quot;&#96;\n\tSpend  int    &#96;json:&quot;spend,omitempty&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; Book 1 without Spend\n\tbook1 :&#x3D; Book&#123;\n\t\tName:   &quot;仿生程序员会梦见代码羊吗&quot;,\n\t\tTarget: &quot;赛博朋克&quot;,\n\t&#125;\n\t&#x2F;&#x2F; 结构体转为 JSON\n\tdata1, err :&#x3D; json.Marshal(book1)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\t&#x2F;&#x2F; book1 won&#39;t print Spend attribute\n\tfmt.Printf(&quot;%s\\n&quot;, data1)\n\n\t&#x2F;&#x2F; Book 2 have Gender attribute\n\tbook2 :&#x3D; Book&#123;\n\t\tName:   &quot;献给阿尔吉侬的花束&quot;,\n\t\tTarget: &quot;科幻&quot;,\n\t\tSpend:  9,\n\t&#125;\n\t&#x2F;&#x2F; 结构体转为 JSON\n\tdata2, err :&#x3D; json.Marshal(book2)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\t&#x2F;&#x2F; person2 will print Gender attribute\n\tfmt.Printf(&quot;%s\\n&quot;, data2)\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/599f74823a414c30b763b7085c3fffca.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到，因为 <code>Spend</code> 字段里有 <code>omitempty</code> 属性，因此 <strong>encoding/json</strong> 在将此结构体对象转化为 <code>JSON</code> 字符串时，发现对象里面的 <code>Spend</code> 为 false ， 0 ，空指针，空接口，空数组，空切片，空映射，空字符串中的一种，就会被忽略。</p>\n<h3 id=\"Tag-的获取\"><a href=\"#Tag-的获取\" class=\"headerlink\" title=\"Tag 的获取\"></a>Tag 的获取</h3><p>Tag 的格式上面已经说了，它是由反引号括起来的一系列用空格分隔的 <code>key:&quot;value&quot;</code> 键值对序列：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#96;key1:&quot;value1&quot; key2:&quot;value2&quot; key3:&quot;value3&quot;&#96;</code></pre>\n<p>那么我们如何获取到结构体中的 Tag 呢？这里我们用反射的方法。</p>\n<p>使用反射的方法获取 Tag 步骤如下：</p>\n<ol>\n<li>获取字段</li>\n<li>获取 Tag</li>\n<li>获取键值对</li>\n</ol>\n<p>其中获取字段有三种方式，而获取键值对有两种方式。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\n&#x2F;&#x2F; 三种获取 field\nfield :&#x3D; reflect.TypeOf(obj).FieldByName(&quot;Name&quot;)\nfield :&#x3D; reflect.ValueOf(obj).Type().Field(i)  &#x2F;&#x2F; i 表示第几个字段\nfield :&#x3D; reflect.ValueOf(&amp;obj).Elem().Type().Field(i)  &#x2F;&#x2F; i 表示第几个字段\n\n&#x2F;&#x2F; 获取 Tag\ntag :&#x3D; field.Tag\n\n&#x2F;&#x2F; 获取键值对\nlabelValue :&#x3D; tag.Get(&quot;label&quot;)\nlabelValue,ok :&#x3D; tag.Lookup(&quot;label&quot;)\n&#x2F;&#x2F; Get 当没有获取到对应 Tag 的内容，会返回空字符串</code></pre>\n<p>下面是一个获取 Tag 以及键值对的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GO\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\ntype Book struct &#123;\n    Name   string &#96;json:&quot;name&quot;&#96;\n    Target string &#96;json:&quot;target&quot;&#96;\n    Spend string &#96;json:&quot;spend,omitempty&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    p :&#x3D; reflect.TypeOf(Book&#123;&#125;)\n    name, _ :&#x3D; p.FieldByName(&quot;Name&quot;)\n    tag :&#x3D; name.Tag\n    fmt.Println(&quot;Name Tag :&quot;, tag)\n    keyValue, _ :&#x3D; tag.Lookup(&quot;json&quot;)\n    fmt.Println(&quot;key: json, value:&quot;, keyValue)\n&#125;</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/7af85c43edf84f9a8ac83011f5bfe38c.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d8f77a0601ea4357bc31508609c75eee.gif\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/ecb2ec88397043379f2d905645e67a5c.jpeg\" alt=\"在这里插入图片描述\"></p>\n","text":"方法方法** 其实就是一个函数，在 func 这个关键字和方法名中间加入了一个特殊的接收器类型。接收器可以是结构体类型或者是非结构体类型。接收器是可以在方法的内部访问的。 GO func (t Type) methodName(parameterList) returnList&...","link":"","photos":[],"count_time":{"symbolsCount":"54k","symbolsTime":"49 mins."},"categories":[{"name":"编程语言","slug":"编程语言","count":13,"path":"api/categories/编程语言.json"}],"tags":[{"name":"GO","slug":"GO","count":4,"path":"api/tags/GO.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\">实例绑定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E5%99%A8%E4%B8%8E%E5%80%BC%E6%8E%A5%E6%94%B6%E5%99%A8\"><span class=\"toc-text\">指针接收器与值接收器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E6%8E%A5%E6%94%B6%E5%99%A8-%E4%B8%8E-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">在方法中使用值接收器 与 在函数中使用值参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E9%9D%9E%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">在非结构体上的方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">接口的定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">接口的实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">接口实现多态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">接口的内部表示</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">空接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">类型断言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">类型选择</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">实现多个接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B5%8C%E5%A5%97\"><span class=\"toc-text\">接口的嵌套</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#go-%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">go 协程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA-go-%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">启动一个 go 协程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA-Go-%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">启动多个 Go 协程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#channel-%E9%80%9A%E9%81%93\"><span class=\"toc-text\">channel 通道</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%81%93%E7%9A%84%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">通道的声明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%81%93%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">通道的初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E9%80%9A%E9%81%93%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">使用通道发送和接收数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%81%93%E7%9A%84%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">通道的关闭</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%81%93%E7%9A%84%E5%AE%B9%E9%87%8F%E4%B8%8E%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">通道的容量与长度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E6%97%A0%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93\"><span class=\"toc-text\">缓冲通道与无缓冲通道</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E9%80%9A%E9%81%93\"><span class=\"toc-text\">双向通道</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E5%90%91%E9%80%9A%E9%81%93\"><span class=\"toc-text\">单向通道</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E9%80%9A%E9%81%93\"><span class=\"toc-text\">遍历通道</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E9%80%9A%E9%81%93%E5%81%9A%E9%94%81\"><span class=\"toc-text\">用通道做锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">死锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#WaitGroup\"><span class=\"toc-text\">WaitGroup</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E4%BF%A1%E9%81%93\"><span class=\"toc-text\">使用信道</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-WaitGroup\"><span class=\"toc-text\">使用 WaitGroup</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Select\"><span class=\"toc-text\">Select</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#select-%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">select 的应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%A0%E6%88%90%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">造成死锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#select-%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86\"><span class=\"toc-text\">select 超时处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%8F%96-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">读取&#x2F;写入数据</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">线程同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%B4%E7%95%8C%E5%8C%BA\"><span class=\"toc-text\">临界区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%92%E6%96%A5%E9%94%81-Mutex\"><span class=\"toc-text\">互斥锁 Mutex</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%86%99%E9%94%81-RWMutex\"><span class=\"toc-text\">读写锁 RWMutex</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-sync-Cond\"><span class=\"toc-text\">条件变量 sync.Cond</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">错误与异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">错误</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%BB%BA%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">内建错误</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">自定义错误</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%99%E9%94%99%E8%AF%AF%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">给错误添加更多信息</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#panic\"><span class=\"toc-text\">panic</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91-panic\"><span class=\"toc-text\">触发 panic</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%91%E7%94%9F-panic-%E6%97%B6%E7%9A%84-defer\"><span class=\"toc-text\">发生 panic 时的 defer</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#recover\"><span class=\"toc-text\">recover</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#make-%E5%92%8C-new\"><span class=\"toc-text\">make 和 new</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#make-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">make 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new-%E5%92%8C-make-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">new 和 make 的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">头等函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%8A%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">把函数赋值给变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">传递一个函数作为参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">返回一个函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">静态类型与动态类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B-static-type\"><span class=\"toc-text\">静态类型(static type)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B-concrete-type\"><span class=\"toc-text\">动态类型(concrete type)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90\"><span class=\"toc-text\">接口组成</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">反射</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#reflect-%E5%8C%85\"><span class=\"toc-text\">reflect 包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#reflect-Type\"><span class=\"toc-text\">reflect.Type</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#reflect-Value\"><span class=\"toc-text\">reflect.Value</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#relfect-Kind\"><span class=\"toc-text\">relfect.Kind</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#relfect-NumField\"><span class=\"toc-text\">relfect.NumField()</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#relfect-Field\"><span class=\"toc-text\">relfect.Field()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%89%E5%A4%A7%E5%AE%9A%E5%BE%8B\"><span class=\"toc-text\">反射的三大定律</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B\"><span class=\"toc-text\">反射第一定律</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B\"><span class=\"toc-text\">反射第二定律</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B\"><span class=\"toc-text\">反射第三定律</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E9%87%8C%E7%9A%84-Tag-%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">结构体里的 Tag 标签</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Tag-%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Tag 的使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Tag-%E7%9A%84%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">Tag 的获取</span></a></li></ol></li></ol>","author":{"name":"Algernon","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/68c4c7d8696c482da565ab5c8ebfa2fa.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}},"mapped":true,"prev_post":{"title":"【数据挖掘】（一）用jupyter编程","uid":"6fcdfe05d0345160147b0e4b83a609f1","slug":"数据挖掘1","date":"2022-11-03T14:56:49.000Z","updated":"2022-11-08T16:17:05.932Z","comments":true,"path":"api/articles/数据挖掘1.json","keywords":null,"cover":[],"text":"为熟悉jupyter，找了一本书练习。参考资料：《Python数据挖掘入门与实践》数据集： https://github.com/packtpublishing/learning-data-mining-with-python 第一行代码import numpy as np da...","link":"","photos":[],"count_time":{"symbolsCount":"47k","symbolsTime":"43 mins."},"categories":[{"name":"机器学习","slug":"机器学习","count":9,"path":"api/categories/机器学习.json"}],"tags":[{"name":"数据挖掘","slug":"数据挖掘","count":2,"path":"api/tags/数据挖掘.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/68c4c7d8696c482da565ab5c8ebfa2fa.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}},"next_post":{"title":"【GO语言编程】（二）","uid":"5c84b4745a97bb70561ce70d97fa094d","slug":"GO2","date":"2022-11-03T14:53:49.000Z","updated":"2022-11-08T15:50:29.945Z","comments":true,"path":"api/articles/GO2.json","keywords":null,"cover":[],"text":"第一个go程序注释package main &#x2F;&#x2F; 声明 main 包 import &quot;fmt&quot; &#x2F;&#x2F; 导入 fmt 包，打印字符串时需要用到 func main()&#123; &#x2F;&#x2F; 声明 main ...","link":"","photos":[],"count_time":{"symbolsCount":"41k","symbolsTime":"37 mins."},"categories":[{"name":"编程语言","slug":"编程语言","count":13,"path":"api/categories/编程语言.json"}],"tags":[{"name":"GO","slug":"GO","count":4,"path":"api/tags/GO.json"}],"author":{"name":"Algernon","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/68c4c7d8696c482da565ab5c8ebfa2fa.png","link":"/","description":"谁也没见过风，更别说我和你了","socials":{"github":"https://github.com/Algernon98","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/Algernon98","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/281724502"}}}}}}